Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen\n\nimport androidx.compose.runtime.mutableStateListOf\nimport androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.cyclistance.core.utils.constants.MappingConstants.MAPPING_VM_STATE_KEY\nimport com.example.cyclistance.core.utils.constants.MappingConstants.NEAREST_METERS\nimport com.example.cyclistance.core.utils.validation.FormatterUtils\nimport com.example.cyclistance.core.utils.validation.FormatterUtils.formatToDistanceKm\nimport com.example.cyclistance.core.utils.validation.FormatterUtils.isLocationAvailable\nimport com.example.cyclistance.feature_authentication.domain.use_case.AuthenticationUseCase\nimport com.example.cyclistance.feature_mapping.data.mapper.UserMapper.toRescueRequest\nimport com.example.cyclistance.feature_mapping.domain.exceptions.MappingExceptions\nimport com.example.cyclistance.feature_mapping.domain.helper.TrackingStateHandler\nimport com.example.cyclistance.feature_mapping.domain.model.Role\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue.RescueRequestItemModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RescueTransaction\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RescueTransactionItem\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.NearbyCyclist\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.RescueRequest\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.UserAssistanceModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.UserItem\nimport com.example.cyclistance.feature_mapping.domain.model.location.LiveLocationWSModel\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.MapSelectedRescuee\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.NewRescueRequestsModel\nimport com.example.cyclistance.feature_mapping.domain.use_case.MappingUseCase\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingVmEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.createMockUsers\nimport com.example.cyclistance.feature_settings.domain.use_case.SettingUseCase\nimport com.google.android.gms.maps.model.LatLng\nimport com.google.maps.android.SphericalUtil\nimport com.mapbox.geojson.Point\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.flow.launchIn\nimport kotlinx.coroutines.flow.onEach\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\nimport javax.inject.Inject\n\n@HiltViewModel\nclass MappingViewModel @Inject constructor(\n    private val savedStateHandle: SavedStateHandle,\n    private val authUseCase: AuthenticationUseCase,\n    private val settingUseCase: SettingUseCase,\n    private val mappingUseCase: MappingUseCase,\n    private val defaultDispatcher: CoroutineDispatcher\n) : ViewModel() {\n\n\n    private var loadDataJob: Job? = null\n    private var getUsersUpdatesJob: Job? = null\n    private var locationUpdatesJob: Job? = null\n    private var getRescueTransactionUpdatesJob: Job? = null\n    private var getTransactionLocationUpdatesJob: Job? = null\n    private var trackingHandler: TrackingStateHandler\n\n    private val _state: MutableStateFlow<MappingState> = MutableStateFlow(\n        savedStateHandle[MAPPING_VM_STATE_KEY] ?: MappingState()\n    )\n    val state = _state.asStateFlow()\n\n    private val _eventFlow: MutableSharedFlow<MappingEvent> = MutableSharedFlow()\n    val eventFlow: SharedFlow<MappingEvent> = _eventFlow.asSharedFlow()\n    private var travelledPath: MutableList<LatLng> = mutableStateListOf()\n\n\n\n    init {\n        trackingHandler = TrackingStateHandler(state = _state, eventFlow = _eventFlow)\n        loadData()\n        observeDataChanges()\n    }\n\n    private fun observeDataChanges() {\n        subscribeToLocationUpdates()\n        subscribeToNearbyUsersChanges()\n        subscribeToRescueTransactionUpdates()\n        subscribeToTransactionLocationUpdates()\n    }\n\n    private fun loadData() {\n        if (loadDataJob?.isActive == true) return\n        loadDataJob = viewModelScope.launch(SupervisorJob() + defaultDispatcher) {\n            // TODO: Remove when the backend is ready\n            createMockUpUsers()\n            getNearbyCyclist()\n            loadRescueTransaction()\n            loadClient()\n        }\n\n    }\n\n\n    private suspend fun loadClient() {\n        coroutineScope {\n            trackingHandler.updateClient()\n        }\n    }\n\n    private suspend fun updateClient() {\n        trackingHandler.updateClient()\n    }\n\n\n    private suspend fun getNearbyCyclist() {\n        val userLocation = state.value.getCurrentLocation()\n\n        userLocation?.latitude ?: return\n        userLocation.longitude ?: return\n\n        if (state.value.nearbyCyclists != null) {\n            return\n        }\n\n        coroutineScope {\n\n            mappingUseCase.getUsersUseCase(\n                latitude = userLocation.latitude,\n                longitude = userLocation.longitude\n            ).distinctUntilChanged().catch {\n                it.handleException()\n            }.onEach {\n                it.getUser()\n                it.updateNearbyCyclists()\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }.launchIn(this)\n\n        }\n\n    }\n\n\n    private suspend fun loadRescueTransaction() {\n        coroutineScope {\n            val transactionId = state.value.user.getTransactionId()\n            if (transactionId.isNullOrEmpty()) {\n                return@coroutineScope\n            }\n\n            mappingUseCase.getRescueTransactionByIdUseCase(transactionId).catch {\n                it.handleException()\n            }.onEach { rescueTransaction ->\n                _state.update { it.copy(rescueTransaction = rescueTransaction) }\n            }.launchIn(this).invokeOnCompletion {\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }\n\n        }\n\n    }\n\n\n    private fun acceptRescueRequest(id: String) {\n        viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n\n            val rescuer = state.value.nearbyCyclists?.findUser(id) ?: return@launch\n            _state.update { it.copy(rescueRequestAcceptedUser = rescuer) }\n            val transactionId = trackingHandler.getTransactionId(rescuer)\n            val user = state.value.user\n\n            trackingHandler.checkCurrentTransactions(user = user, rescuer = rescuer) {\n\n                coroutineScope {\n                    runCatching {\n                        isLoading(true)\n                        trackingHandler.getAcceptedRescueRequestItem(\n                            transactionId = transactionId,\n                            rescuer = rescuer\n                        ).apply {\n                            mappingUseCase.createRescueTransactionUseCase(rescueTransaction = this)\n                        }\n\n                    }.onSuccess { rescueTransaction ->\n                        broadcastRescueTransaction()\n                        assignRequestTransaction(\n                            rescueTransaction = rescueTransaction,\n                            user = user,\n                            rescuer = rescuer,\n                            transactionId = transactionId\n                        )\n                        user.location?.let { broadcastRescueTransactionToRespondent(it) }\n                    }.onFailure { exception ->\n                        isLoading(false)\n                        exception.handleException()\n                    }\n                }\n\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n\n            }\n        }\n    }\n\n    private fun cancelHelpRequest() {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                isLoading(true)\n                cancelUserHelpRequest()\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.CancelHelpRequestSuccess)\n                broadcastToNearbyCyclists()\n                _state.update { it.copy(rescueRequestAcceptedUser = null) }\n            }.onFailure { exception ->\n                Timber.e(\"Failed to cancel search assistance: ${exception.message}\")\n                exception.handleException()\n            }\n            isLoading(false)\n            savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n        }\n    }\n\n\n    private fun removeAssignedTransaction() {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                removeUserTransaction(id = getId())\n            }.onSuccess {\n                broadcastToNearbyCyclists()\n                broadcastRescueTransaction()\n                isLoading(false)\n                _eventFlow.emit(value = MappingEvent.RemoveAssignedTransactionSuccess)\n                trackingHandler.clearTransactionRoles()\n            }.onFailure { exception ->\n                isLoading(false)\n                exception.handleException()\n            }\n        }\n\n    }\n\n    private fun selectRescueeMapIcon(id: String) {\n        viewModelScope.launch(context = defaultDispatcher) {\n\n            val userLocation = state.value.user.location ?: state.value.userLocation\n\n            if (!userLocation.isLocationAvailable()) {\n                viewModelScope.launch(context = defaultDispatcher) {\n                    _eventFlow.emit(value = MappingEvent.LocationNotAvailable(\"Tracking your Location\"))\n                }\n                return@launch\n            }\n\n            calculateSelectedRescueeDistance(userLocation, id)\n\n        }\n    }\n\n    private fun respondToHelp(selectedRescuee: MapSelectedRescuee) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                uploadUserProfile(onSuccess = {\n                    viewModelScope.launch(context = defaultDispatcher) {\n                        mappingUseCase.addRescueRespondentUseCase(\n                            userId = selectedRescuee.userId,\n                            respondentId = getId()\n                        )\n                    }\n                })\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.RespondToHelpSuccess())\n                broadcastToNearbyCyclists()\n                broadcastRescueTransaction()\n                _state.update { it.copy(respondedToHelp = true) }\n            }.onFailure {\n                it.handleException()\n            }\n\n        }\n    }\n\n    private fun showRouteDirection(origin: Point, destination: Point) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                mappingUseCase.getRouteDirectionsUseCase(origin = origin, destination = destination)\n            }.onSuccess { routeDirection ->\n                _eventFlow.emit(value = MappingEvent.NewRouteDirection(routeDirection))\n            }.onFailure {\n                Timber.v(\"Failure: ${it.message}\")\n                it.handleException()\n            }\n        }\n    }\n\n\n    private suspend fun broadcastRescueTransaction() {\n        runCatching {\n            mappingUseCase.broadcastRescueTransactionUseCase()\n        }.onFailure {\n            it.handleException()\n        }\n    }\n\n    private suspend fun broadcastToNearbyCyclists() {\n        val location = state.value.userLocation ?: return\n        runCatching {\n            mappingUseCase.broadcastToNearbyCyclists(\n                locationModel = LiveLocationWSModel(\n                    latitude = location.latitude,\n                    longitude = location.longitude\n                )\n            )\n        }.onFailure {\n            it.handleException()\n        }\n    }\n\n    private fun declineRescueRequest(id: String) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                isLoading(true)\n                mappingUseCase.deleteRescueRespondentUseCase(userId = getId(), respondentId = id)\n            }.onSuccess {\n                removeRescueRespondent(id)\n                broadcastToNearbyCyclists()\n            }.onFailure {\n                it.handleDeclineRescueRequest()\n            }\n            isLoading(false)\n            savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n\n        }\n    }\n\n    private suspend fun removeRescueRespondent(id: String) {\n        state.value.newRescueRequest?.request?.toMutableList()?.apply {\n            val respondentRemoved = removeAll { it.id == id }\n            if (!respondentRemoved) {\n                _eventFlow.emit(value = MappingEvent.RemoveRespondentFailed())\n                return@apply\n            }\n            _state.update {\n                it.copy(\n                    newRescueRequest = NewRescueRequestsModel(this)\n                )\n            }\n        }\n    }\n\n\n    private fun requestHelp() {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                uploadUserProfile(onSuccess = {\n                    viewModelScope.launch(context = defaultDispatcher) {\n                        _eventFlow.emit(MappingEvent.RequestHelpSuccess)\n                    }\n                })\n            }.onFailure {\n                it.handleException()\n            }\n        }.invokeOnCompletion {\n            savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n        }\n    }\n\n    fun onEvent(event: MappingVmEvent) {\n        when (event) {\n\n            is MappingVmEvent.SubscribeToDataChanges -> {\n                observeDataChanges()\n            }\n\n\n            is MappingVmEvent.GetRouteDirections -> {\n                showRouteDirection(origin = event.origin, destination = event.destination)\n            }\n\n            is MappingVmEvent.RespondToHelp -> {\n                respondToHelp(event.selectedRescuee)\n            }\n\n            is MappingVmEvent.SelectRescueMapIcon -> {\n                selectRescueeMapIcon(event.id)\n            }\n\n            is MappingVmEvent.RequestHelp -> {\n                requestHelp()\n            }\n\n            is MappingVmEvent.CancelRescueTransaction -> {\n                removeAssignedTransaction()\n                clearTravelledPath()\n            }\n\n\n            is MappingVmEvent.LoadData -> {\n                loadData()\n            }\n\n\n            is MappingVmEvent.DeclineRescueRequest -> {\n                declineRescueRequest(event.id)\n                clearTravelledPath()\n            }\n\n            is MappingVmEvent.AcceptRescueRequest -> {\n                acceptRescueRequest(event.id)\n            }\n\n            is MappingVmEvent.CancelRequestHelp -> {\n                cancelHelpRequest()\n                clearTravelledPath()\n            }\n\n        }\n        savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n    }\n\n\n    private suspend fun calculateSelectedRescueeDistance(userLocation: LocationModel?, id: String) {\n        val selectedRescuee = state.value.nearbyCyclists?.findUser(id) ?: return\n        val selectedRescueeLocation = selectedRescuee.location\n\n\n        runCatching {\n            isLoading(true)\n            mappingUseCase.getCalculatedDistanceUseCase(\n                startingLocation = LocationModel(\n                    latitude = userLocation?.latitude,\n                    longitude = userLocation?.longitude\n                ), destinationLocation = LocationModel(\n                    latitude = selectedRescueeLocation!!.latitude,\n                    longitude = selectedRescueeLocation.longitude\n                )\n            )\n        }.onSuccess { distance ->\n            val timeRemaining = FormatterUtils.getCalculatedETA(distance)\n            trackingHandler.showSelectedRescuee(\n                selectedRescuee = selectedRescuee,\n                distance = distance,\n                timeRemaining = timeRemaining)\n        }.onFailure {\n            _eventFlow.emit(value = MappingEvent.FailedToCalculateDistance)\n        }.also {\n            isLoading(false)\n        }\n    }\n\n\n    private suspend fun removeUserTransaction(id: String) {\n        mappingUseCase.createUserUseCase(\n            user = UserItem.removeUserTransaction(id)\n        )\n    }\n\n\n    private fun subscribeToTransactionLocationUpdates() {\n        if (getRescueTransactionUpdatesJob?.isActive == true) {\n            return\n        }\n        getTransactionLocationUpdatesJob =\n            viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n                mappingUseCase.getTransactionLocationUpdatesUseCase().distinctUntilChanged().catch {\n                    Timber.e(\"ERROR GETTING TRANSACTION LOCATION: ${it.message}\")\n                }.onEach { liveLocation ->\n                    trackingHandler.updateTransactionLocation(location = liveLocation)\n                    liveLocation.updateTransactionETA()\n                    liveLocation.updateTransactionDistance()\n                }.launchIn(this@launch)\n\n            }\n    }\n\n    private suspend fun LiveLocationWSModel.updateTransactionDistance() {\n        coroutineScope {\n            val rescueTransaction = state.value.userLocation\n            latitude ?: return@coroutineScope\n            longitude ?: return@coroutineScope\n\n            rescueTransaction?.let { transaction ->\n\n                val distance = mappingUseCase.getCalculatedDistanceUseCase(\n                    startingLocation = LocationModel(latitude, longitude),\n                    destinationLocation = LocationModel(transaction.latitude, transaction.longitude)\n                ).toInt()\n\n\n                if (distance <= NEAREST_METERS) {\n                    _eventFlow.emit(value = MappingEvent.DestinationReached)\n                    removeAssignedTransaction()\n                    clearTravelledPath()\n                }\n\n            }\n        }\n    }\n\n\n    private fun LiveLocationWSModel.updateTransactionETA() {\n        val userLocation = state.value.userLocation\n        userLocation ?: return\n        this.latitude ?: return\n        this.longitude ?: return\n\n        val eta = getETABetweenTwoPoints(\n            startingLocation = LocationModel(\n                latitude = this.latitude,\n                longitude = this.longitude\n            ), endLocation = userLocation\n        )\n        _state.update { it.copy(rescuerETA = eta) }\n    }\n\n    private fun getETABetweenTwoPoints(\n        startingLocation: LocationModel,\n        endLocation: LocationModel\n    ): String {\n        val distance = mappingUseCase.getCalculatedDistanceUseCase(\n            startingLocation = startingLocation,\n            destinationLocation = endLocation\n        )\n\n        return FormatterUtils.getCalculatedETA(distanceMeters = distance)\n    }\n\n\n    private suspend fun assignRequestTransaction(\n        rescueTransaction: RescueTransactionItem,\n        user: UserItem,\n        rescuer: UserItem,\n        transactionId: String\n    ) {\n\n        runCatching {\n\n            transactionId.assignRequestTransaction(\n                role = Role.RESCUEE.name.lowercase(),\n                id = user.id\n            )\n\n            transactionId.assignRequestTransaction(\n                role = Role.RESCUER.name.lowercase(),\n                id = rescuer.id\n            )\n\n        }.onSuccess {\n            broadcastToNearbyCyclists()\n            _eventFlow.emit(value = MappingEvent.AcceptRescueRequestSuccess)\n            delay(500)\n            updateTransactionETA(rescuer, rescueTransaction)\n            isLoading(false)\n            broadcastRescueTransaction()\n        }.onFailure { exception ->\n            isLoading(false)\n            exception.handleException()\n        }\n\n    }\n\n    private fun updateTransactionETA(rescuer: UserItem, rescueTransaction: RescueTransactionItem) {\n        val userLocation = state.value.userLocation ?: return\n\n        val estimatedTimeArrival = rescuer.location?.let {\n            getETABetweenTwoPoints(\n                startingLocation = it,\n                endLocation = userLocation\n            )\n        }\n        _state.update {\n            it.copy(\n                rescueTransaction = rescueTransaction,\n                rescuerETA = estimatedTimeArrival ?: \"\",\n                rescuer = rescuer\n            )\n        }\n    }\n\n    private fun isLoading(loading: Boolean) {\n        _state.update { it.copy(isLoading = loading) }\n    }\n\n\n    private suspend fun String.assignRequestTransaction(role: String, id: String?) {\n        mappingUseCase.createUserUseCase(\n            user = UserItem.empty(id = id, transactionId = this, role = role)\n        )\n    }\n\n\n    private suspend fun Throwable.handleDeclineRescueRequest() {\n        when (this) {\n            is MappingExceptions.NetworkException -> {\n                _eventFlow.emit(value = MappingEvent.NoInternetConnection)\n            }\n\n            else -> {\n                Timber.d(\"Failed to update user\")\n            }\n        }\n    }\n\n\n    private suspend fun cancelUserHelpRequest() {\n\n        mappingUseCase.createUserUseCase(\n            user = UserItem.cancelUserHelpRequest(id = getId()))\n    }\n\n\n    private fun NearbyCyclist.getUser() {\n\n        val user = findUser(id = getId())\n        _state.update { it.copy(user = user) }\n        val respondents = user.getUserRescueRespondents(this)\n        _state.update {\n            it.copy(\n                newRescueRequest = NewRescueRequestsModel(\n                    request = respondents\n                )\n            )\n        }\n    }\n\n    private fun UserItem.getUserRescueRespondents(nearbyCyclist: NearbyCyclist): List<RescueRequestItemModel> {\n        val rescueRespondentsSnapShot: MutableList<RescueRequestItemModel> = mutableListOf()\n\n        rescueRequest?.respondents?.forEach { respondent ->\n            val userRespondent = nearbyCyclist.findUser(id = respondent.clientId)\n            val distance = calculateDistance(startLocation = location, endLocation = userRespondent.location)\n\n            distance?.let {\n                val formattedETA = FormatterUtils.getCalculatedETA(distanceMeters = it)\n                rescueRespondentsSnapShot.add(\n                    element = userRespondent.toRescueRequest(\n                        distance = it.formatToDistanceKm(),\n                        eta = formattedETA\n                    )\n                )\n            }\n        }\n\n        return rescueRespondentsSnapShot.distinct()\n    }\n\n    private fun calculateDistance(startLocation: LocationModel?, endLocation: LocationModel?): Double? {\n        val startLatitude = startLocation?.latitude ?: return null\n        val startLongitude = startLocation.longitude ?: return null\n        val endLatitude = endLocation?.latitude ?: return null\n        val endLongitude = endLocation.longitude ?: return null\n\n        return mappingUseCase.getCalculatedDistanceUseCase(\n            startingLocation = LocationModel(latitude = startLatitude, longitude = startLongitude),\n            destinationLocation = LocationModel(latitude = endLatitude, longitude = endLongitude)\n        )\n    }\n\n    private fun NearbyCyclist.updateNearbyCyclists() {\n        _state.update { it.copy(nearbyCyclists = this.apply { users.distinctBy { v -> v.id } }) }\n        Timber.v(\"NEARBY CYCLISTS: ${this.users}\")\n    }\n\n    private suspend fun broadcastRescueTransactionToRespondent(location: LocationModel) {\n        val rescueTransaction = state.value.rescueTransaction ?: return\n        runCatching {\n\n            val user = state.value.user\n            mappingUseCase.broadcastRescueTransactionToRespondent(\n                LiveLocationWSModel(\n                    latitude = location.latitude,\n                    longitude = location.longitude,\n                    room = rescueTransaction.id\n                ),\n                user = user,\n                rescueTransactionItem = rescueTransaction\n            )\n\n        }.onFailure {\n            Timber.v(\"Broadcasting location to transaction failed: ${it.message}\")\n        }\n    }\n\n\n    private fun unSubscribeToTransactionLocationUpdates() {\n        getTransactionLocationUpdatesJob?.cancel()\n    }\n\n    private fun subscribeToRescueTransactionUpdates() {\n        if (getRescueTransactionUpdatesJob?.isActive == true) {\n            return\n        }\n        getRescueTransactionUpdatesJob =\n            viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n\n                mappingUseCase.getRescueTransactionUpdatesUseCase().catch {\n                    Timber.e(\"ERROR GETTING RESCUE TRANSACTION: ${it.message}\")\n\n                }.onEach {\n                    it.updateRescueTransaction()\n                    it.updateRescueClient()\n                    trackingHandler.checkRescueRequestAccepted(\n                        rescueTransaction = it,\n                        id = getId()\n                    )\n                }.launchIn(this@launch).invokeOnCompletion {\n                    savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n                }\n\n            }\n    }\n\n\n\n\n    private fun RescueTransaction.updateRescueTransaction() {\n        val rescueTransaction = trackingHandler.getUserRescueTransaction(this)\n        _state.update { it.copy(rescueTransaction = rescueTransaction) }\n    }\n\n    private suspend fun RescueTransaction.updateRescueClient() {\n        coroutineScope {\n            val rescueTransaction =\n                trackingHandler.getUserRescueTransaction(this@updateRescueClient)\n            _state.update { it.copy(rescueTransaction = rescueTransaction) }\n            updateClient()\n\n        }\n    }\n\n    private fun unSubscribeToRescueTransactionUpdates() {\n        getRescueTransactionUpdatesJob?.cancel()\n    }\n\n    private fun unSubscribeToNearbyUsersChanges() {\n        getUsersUpdatesJob?.cancel()\n    }\n\n    private fun subscribeToLocationUpdates() {\n        if (locationUpdatesJob?.isActive == true) {\n            return\n        }\n        locationUpdatesJob = viewModelScope.launch(context = defaultDispatcher) {\n\n            mappingUseCase.getUserLocationUseCase().catch {\n                Timber.e(\"Error Location Updates: ${it.message}\")\n            }.onEach { location ->\n                trackingHandler.updateLocation(location)\n                broadcastRescueTransactionToRespondent(location)\n                updateSpeedometer(location)\n                getNearbyCyclist()\n            }.launchIn(this@launch).invokeOnCompletion {\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n    private fun updateSpeedometer(location: LocationModel){\n        val isUserRescuer = state.value.user.isRescuer()\n        if(isUserRescuer) {\n            trackingHandler.setSpeed(location.speed)\n            trackingHandler.getTopSpeed(location.speed)\n            travelledPath.add(element = LatLng(location.latitude!!, location.longitude!!))\n            val distance = SphericalUtil.computeLength(travelledPath).formatToDistanceKm()\n            trackingHandler.setTravelledDistance(distance)\n        }\n    }\n\n\n    private fun subscribeToNearbyUsersChanges() {\n        if (getUsersUpdatesJob?.isActive == true) {\n            return\n        }\n\n        getUsersUpdatesJob = viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n\n            mappingUseCase.getUserUpdatesUseCase().catch {\n                Timber.e(\"ERROR GETTING USERS: ${it.message}\")\n            }.onEach {\n                it.getUser()\n                it.updateNearbyCyclists()\n                trackingHandler.updateClient()\n            }.launchIn(this).invokeOnCompletion {\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n    private fun unSubscribeToLocationUpdates() {\n        locationUpdatesJob?.cancel()\n    }\n\n\n    private suspend inline fun uploadUserProfile(crossinline onSuccess: () -> Unit) {\n        coroutineScope {\n            val userLocation = state.value.userLocation\n\n            if (userLocation == null) {\n                _eventFlow.emit(MappingEvent.LocationNotAvailable(reason = \"Searching for GPS\"))\n                return@coroutineScope\n            }\n\n            uploadProfile(location = userLocation, onSuccess = onSuccess)\n\n        }\n    }\n\n\n    private suspend inline fun uploadProfile(\n        location: LocationModel,\n        crossinline onSuccess: () -> Unit\n    ) {\n\n        val isProfileUploaded = state.value.profileUploaded\n\n        if (isProfileUploaded) {\n            onSuccess()\n            return\n        }\n\n        val fullAddress = mappingUseCase.getFullAddressUseCase(\n            latitude = location.latitude,\n            longitude = location.longitude\n        )\n\n        coroutineScope {\n\n            runCatching {\n                isLoading(true)\n                mappingUseCase.createUserUseCase(\n                    user = UserItem(\n                        id = getId(),\n                        name = getName(),\n                        address = fullAddress,\n                        profilePictureUrl = getPhotoUrl(),\n                        contactNumber = getPhoneNumber(),\n                        location = LocationModel(\n                            latitude = location.latitude,\n                            longitude = location.longitude\n                        ),\n                        rescueRequest = RescueRequest(), userAssistance = UserAssistanceModel()\n                    )\n                )\n                fullAddress?.let { mappingUseCase::setAddressUseCase }\n\n            }.onSuccess {\n                isLoading(false)\n                broadcastToNearbyCyclists()\n                onSuccess()\n                _state.update { it.copy(profileUploaded = true) }\n\n            }.onFailure { exception ->\n                Timber.e(\"Error uploading profile: ${exception.message}\")\n                isLoading(false)\n                exception.handleException()\n            }\n        }\n    }\n\n\n    private suspend fun Throwable.handleException() {\n        trackingHandler.handleException(this)\n        savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n    }\n\n\n    private suspend fun createMockUpUsers() {\n        runCatching {\n            mappingUseCase.createMockUsers()\n        }.onSuccess {\n            Timber.v(\"CREATED MOCK USERS!\")\n            broadcastToNearbyCyclists()\n        }.onFailure {\n            Timber.e(\"FAILED TO CREATE MOCK USERS: ${it.message}\")\n        }\n    }\n\n\n    override fun onCleared() {\n        super.onCleared()\n        unSubscribeToLocationUpdates()\n        unSubscribeToNearbyUsersChanges()\n        unSubscribeToRescueTransactionUpdates()\n        unSubscribeToTransactionLocationUpdates()\n\n    }\n\n\n    private fun getId(): String = authUseCase.getIdUseCase()\n\n    private suspend fun getName(): String = settingUseCase.getNameUseCase()\n\n    private suspend fun getPhoneNumber(): String =\n        settingUseCase.getPhoneNumberUseCase()\n\n    private suspend fun getPhotoUrl() = settingUseCase.getPhotoUrlUseCase()\n\n    private fun clearTravelledPath(){\n        travelledPath = mutableListOf()\n    }\n\n\n\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt	(date 1692092204062)
@@ -79,11 +79,15 @@
     private val _eventFlow: MutableSharedFlow<MappingEvent> = MutableSharedFlow()
     val eventFlow: SharedFlow<MappingEvent> = _eventFlow.asSharedFlow()
     private var travelledPath: MutableList<LatLng> = mutableStateListOf()
-
+    private var _nearbyCyclistState = mutableStateListOf<UserItem>()
+    val nearbyCyclistState = _nearbyCyclistState
 
 
     init {
-        trackingHandler = TrackingStateHandler(state = _state, eventFlow = _eventFlow)
+        trackingHandler = TrackingStateHandler(
+            state = _state,
+            eventFlow = _eventFlow,
+            nearbyCyclist = _nearbyCyclistState)
         loadData()
         observeDataChanges()
     }
@@ -125,7 +129,7 @@
         userLocation?.latitude ?: return
         userLocation.longitude ?: return
 
-        if (state.value.nearbyCyclists != null) {
+        if (_nearbyCyclistState.isNotEmpty()) {
             return
         }
 
@@ -167,10 +171,11 @@
     }
 
 
+
     private fun acceptRescueRequest(id: String) {
         viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {
 
-            val rescuer = state.value.nearbyCyclists?.findUser(id) ?: return@launch
+            val rescuer = _nearbyCyclistState?.findUser(id) ?: return@launch
             _state.update { it.copy(rescueRequestAcceptedUser = rescuer) }
             val transactionId = trackingHandler.getTransactionId(rescuer)
             val user = state.value.user
@@ -425,7 +430,7 @@
 
 
     private suspend fun calculateSelectedRescueeDistance(userLocation: LocationModel?, id: String) {
-        val selectedRescuee = state.value.nearbyCyclists?.findUser(id) ?: return
+        val selectedRescuee = _nearbyCyclistState?.findUser(id) ?: return
         val selectedRescueeLocation = selectedRescuee.location
 
 
@@ -662,8 +667,7 @@
     }
 
     private fun NearbyCyclist.updateNearbyCyclists() {
-        _state.update { it.copy(nearbyCyclists = this.apply { users.distinctBy { v -> v.id } }) }
-        Timber.v("NEARBY CYCLISTS: ${this.users}")
+        _nearbyCyclistState.addAll(this.users)
     }
 
     private suspend fun broadcastRescueTransactionToRespondent(location: LocationModel) {
Index: app/src/main/java/com/example/cyclistance/feature_messaging/presentation/chat/chats/ChatsViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_messaging.presentation.chat.chats\n\nimport androidx.compose.runtime.mutableStateListOf\nimport androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.cyclistance.core.utils.constants.MessagingConstants\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.MESSAGING_VM_STATE_KEY\nimport com.example.cyclistance.feature_messaging.domain.model.helper.MessagingUserHandler\nimport com.example.cyclistance.feature_messaging.domain.model.ui.chats.ChatItemModel\nimport com.example.cyclistance.feature_messaging.domain.model.ui.chats.MessagingUserItemModel\nimport com.example.cyclistance.feature_messaging.domain.model.ui.chats.MessagingUserModel\nimport com.example.cyclistance.feature_messaging.domain.model.ui.chats.MessagingUserModel.Companion.filterWithout\nimport com.example.cyclistance.feature_messaging.domain.model.ui.chats.MessagingUserModel.Companion.findUser\nimport com.example.cyclistance.feature_messaging.domain.use_case.MessagingUseCase\nimport com.example.cyclistance.feature_messaging.presentation.chat.chats.event.ChatVmEvent\nimport com.example.cyclistance.feature_messaging.presentation.chat.chats.state.ChatState\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\nimport javax.inject.Inject\n\n@HiltViewModel\nclass ChatsViewModel @Inject constructor(\n    private val savedStateHandle: SavedStateHandle,\n    private val messagingUseCase: MessagingUseCase) : ViewModel() {\n\n    private val _state = MutableStateFlow(savedStateHandle[MESSAGING_VM_STATE_KEY] ?: ChatState())\n    val state = _state.asStateFlow()\n\n    private val messageUserFlow = MutableStateFlow(MessagingUserModel())\n\n\n    private val _chatsState = mutableStateListOf<Pair<MessagingUserItemModel, ChatItemModel>>()\n    val chatsState: List<Pair<MessagingUserItemModel, ChatItemModel>> = _chatsState\n\n    init {\n        refreshToken()\n        initializeListener()\n        saveState()\n    }\n\n\n    fun onEvent(event: ChatVmEvent) {\n        when (event) {\n            is ChatVmEvent.RefreshChat -> {\n                _chatsState.clear()\n                removeChatListener()\n                removeUserListener()\n                initializeListener()\n            }\n        }\n    }\n\n\n    private fun isLoading(isLoading: Boolean) {\n        _state.update { it.copy(isLoading = isLoading) }\n    }\n\n    private fun initializeListener() {\n        viewModelScope.launch(SupervisorJob()) {\n            addUserListener()\n            addChatListener()\n        }\n\n    }\n\n    private suspend fun addUserListener() {\n\n        coroutineScope {\n            runCatching {\n                messagingUseCase.addUserListenerUseCase(onNewMessageUser = { messageUser ->\n                    this.launch(SupervisorJob()) {\n                        messageUserFlow.emit(value = messageUser)\n                    }\n                })\n            }.onFailure {\n                Timber.e(\"Failed to retrieve chats ${it.message}\")\n            }\n            saveState()\n        }\n    }\n\n    private fun saveState() {\n        savedStateHandle[MessagingConstants.SEARCH_USER_VM_STATE_KEY] = _state.value\n    }\n\n    private suspend fun addChatListener() {\n        coroutineScope {\n            runCatching {\n                messagingUseCase.addChatListenerUseCase(onAddedChat = { chat ->\n                    this.launch(SupervisorJob()) {\n                        handleAddChat(chat)\n                    }\n                }, onModifiedChat = { chat ->\n                    handleModifiedChat(chat)\n                })\n\n            }.onFailure {\n                Timber.e(\"Failed to retrieve chats ${it.message}\")\n            }.also {\n                isLoading(false)\n                saveState()\n            }\n        }\n    }\n\n\n    private suspend fun handleAddChat(chat: ChatItemModel) {\n        val uid = messagingUseCase.getUidUseCase()\n        messageUserFlow.collect { messageUser ->\n            val matchedMessageUser = messageUser.filterWithout(uid).findUser(chat.conversionId)\n            _state.update { it.copy(messageUserInfo = messageUser.findUser(uid)) }\n            val messagingUserHandler = matchedMessageUser?.let { foundUser ->\n                MessagingUserHandler(\n                    messagingUserItem = foundUser,\n                    chatItem = chat,\n                    chats = _chatsState)\n            }\n            messagingUserHandler?.handleNewAddedChat()\n            isLoading(false)\n        }\n\n    }\n\n\n    private fun handleModifiedChat(chat: ChatItemModel) {\n        val uid = messagingUseCase.getUidUseCase()\n        _state.update { it.copy(messageUserInfo = messageUserFlow.value.findUser(uid)) }\n\n        val matchedMessageUser = messageUserFlow.value.findUser(chat.conversionId)\n        val messagingUserHandler = matchedMessageUser?.let { foundUser ->\n            MessagingUserHandler(\n                messagingUserItem = foundUser,\n                chatItem = chat,\n                chats = _chatsState)\n        }\n        messagingUserHandler?.handleModifiedChat()\n        isLoading(false)\n    }\n\n\n    private fun removeChatListener() {\n        messagingUseCase.removeChatListenerUseCase()\n    }\n\n    private fun removeUserListener() {\n        messagingUseCase.removeUserListenerUseCase()\n    }\n\n    private fun refreshToken() {\n        viewModelScope.launch(SupervisorJob()) {\n            runCatching {\n                isLoading(true)\n                messagingUseCase.refreshTokenUseCase()\n            }.onSuccess {\n                Timber.v(\"Successfully refreshed token\")\n            }.onFailure {\n                Timber.e(\"Failed to refresh token ${it.message}\")\n            }\n\n        }\n        saveState()\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        removeChatListener()\n        removeUserListener()\n    }\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_messaging/presentation/chat/chats/ChatsViewModel.kt b/app/src/main/java/com/example/cyclistance/feature_messaging/presentation/chat/chats/ChatsViewModel.kt
--- a/app/src/main/java/com/example/cyclistance/feature_messaging/presentation/chat/chats/ChatsViewModel.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/feature_messaging/presentation/chat/chats/ChatsViewModel.kt	(date 1692090368272)
@@ -22,6 +22,7 @@
 import kotlinx.coroutines.flow.asStateFlow
 import kotlinx.coroutines.flow.update
 import kotlinx.coroutines.launch
+import okhttp3.internal.toImmutableList
 import timber.log.Timber
 import javax.inject.Inject
 
@@ -37,7 +38,7 @@
 
 
     private val _chatsState = mutableStateListOf<Pair<MessagingUserItemModel, ChatItemModel>>()
-    val chatsState: List<Pair<MessagingUserItemModel, ChatItemModel>> = _chatsState
+    val chatsState: List<Pair<MessagingUserItemModel, ChatItemModel>> = _chatsState.toImmutableList()
 
     init {
         refreshToken()
Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.BottomSheetScaffoldState\nimport androidx.compose.material.CircularProgressIndicator\nimport androidx.compose.material.ExperimentalMaterialApi\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.remember\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.unit.dp\nimport androidx.constraintlayout.compose.ConstraintLayout\nimport androidx.constraintlayout.compose.Dimension\nimport com.example.cyclistance.core.presentation.dialogs.no_internet_dialog.NoInternetDialog\nimport com.example.cyclistance.core.presentation.dialogs.permissions_dialog.DialogForegroundLocationPermission\nimport com.example.cyclistance.core.presentation.dialogs.permissions_dialog.DialogPhonePermission\nimport com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.components.emergency_call.EmergencyCallDialog\nimport com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.state.EmergencyCallState\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.CancelledRescueModel\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.banner.MappingExpandableBanner\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.bottomSheet.MappingBottomSheet\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.RequestHelpButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.RespondToHelpButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.fabs.ExpandableFABSection\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.fabs.FloatingButtonSection\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.request.MappingRequestAccepted\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.request.MappingRequestCancelled\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.rescue_request.RescueRequestDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.rescue_results.RescueResultsDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.sino_track.SinoTrackWebView\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState\nimport com.google.accompanist.permissions.ExperimentalPermissionsApi\nimport com.google.accompanist.permissions.MultiplePermissionsState\nimport com.google.accompanist.permissions.rememberMultiplePermissionsState\nimport com.mapbox.mapboxsdk.maps.MapboxMap\n\n\n@OptIn(ExperimentalPermissionsApi::class, ExperimentalMaterialApi::class)\n@Composable\nfun MappingScreenContent(\n    modifier: Modifier,\n    bottomSheetScaffoldState: BottomSheetScaffoldState,\n    state: MappingState,\n    emergencyState: EmergencyCallState,\n    mapboxMap: MapboxMap?,\n    hasTransaction: Boolean = false,\n    isRescueCancelled: Boolean = false,\n    isNavigating: Boolean,\n    uiState: MappingUiState,\n    locationPermissionState: MultiplePermissionsState = rememberMultiplePermissionsState(permissions = emptyList()),\n    event: (MappingUiEvent) -> Unit = {},\n) {\n\n    val respondentCount by remember(state.newRescueRequest?.request?.size) {\n        derivedStateOf { (state.newRescueRequest?.request)?.size ?: 0 }\n    }\n\n\n    val configuration = LocalConfiguration.current\n\n    Surface(\n        modifier = modifier\n            .fillMaxSize(),\n        color = MaterialTheme.colors.background) {\n\n\n        Box {\n\n            if (uiState.isRescueRequestDialogVisible) {\n                RescueRequestDialog(\n                    modifier = Modifier\n                        .fillMaxSize(),\n                    mappingState = state,\n                    uiState = uiState,\n                    event = event\n                )\n            }\n\n\n            if(uiState.isRescueResultsDialogVisible){\n\n                RescueResultsDialog(\n                    modifier = Modifier.fillMaxSize(),\n                    mappingState = state,\n                    uiState = uiState,\n                    event = event\n                )\n\n            }\n\n\n            MappingBottomSheet(\n                state = state,\n                onClickRescueArrivedButton = { event(MappingUiEvent.RescueArrivedConfirmed) },\n                onClickReachedDestinationButton = { event(MappingUiEvent.DestinationReachedConfirmed) },\n                onClickCancelSearchButton = { event(MappingUiEvent.CancelSearchConfirmed) },\n                onClickCallRescueTransactionButton = { event(MappingUiEvent.CallRescueTransaction) },\n                onClickChatRescueTransactionButton = { event(MappingUiEvent.ChatRescueTransaction) },\n                onClickCancelRescueTransactionButton = { event(MappingUiEvent.CancelRescueTransaction) },\n                bottomSheetScaffoldState = bottomSheetScaffoldState,\n                bottomSheetType = uiState.bottomSheetType,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(horizontal = 12.dp),\n                onClickReportIncident = { event(MappingUiEvent.OnReportIncident(it)) }) {\n\n\n                ConstraintLayout(modifier = Modifier.fillMaxSize()) {\n\n                    val (mapScreen, requestHelpButton, circularProgressbar, dialog, respondToHelpButton, fabSection, expandableFabSection) = createRefs()\n\n\n                    MappingMapsScreen(\n                        state = state,\n                        modifier = Modifier.constrainAs(mapScreen) {\n                            top.linkTo(parent.top)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                            bottom.linkTo(parent.bottom)\n                        },\n                        hasTransaction = hasTransaction,\n                        isRescueCancelled = isRescueCancelled,\n                        mapboxMap = mapboxMap,\n                        routeDirection = uiState.routeDirection,\n                        isNavigating = isNavigating,\n                        event = event,\n                        uiState = uiState\n                    )\n\n\n\n\n                    AnimatedVisibility(\n                        visible = uiState.mapSelectedRescuee != null,\n                        enter = expandVertically(expandFrom = Alignment.Top) { 20 },\n                        exit = shrinkVertically(animationSpec = tween()) { fullHeight ->\n                            fullHeight / 2\n                        },\n                    ) {\n                        if (uiState.mapSelectedRescuee != null) {\n                            MappingExpandableBanner(\n                                modifier = Modifier\n                                    .padding(all = 6.dp)\n                                    .fillMaxWidth(), banner = uiState.mapSelectedRescuee,\n                                onClickDismissButton = { event(MappingUiEvent.DismissBanner) })\n                        }\n                    }\n\n                    FloatingButtonSection(\n                        modifier = Modifier\n                            .constrainAs(fabSection) {\n                                end.linkTo(parent.end, margin = 8.dp)\n                                bottom.linkTo(\n                                    parent.bottom,\n                                    margin = (configuration.screenHeightDp / 2.5).dp)\n                            },\n                        locationPermissionGranted = locationPermissionState.allPermissionsGranted,\n                        onClickLocateUserButton = { event(MappingUiEvent.LocateUser) },\n                        onClickRouteOverviewButton = { event(MappingUiEvent.RouteOverview) },\n                        onClickRecenterButton = { event(MappingUiEvent.RecenterRoute) },\n                        onClickOpenNavigationButton = { event(MappingUiEvent.OpenNavigation) },\n                        isNavigating = isNavigating,\n                        uiState = uiState\n                    )\n\n\n\n\n                    AnimatedVisibility(\n                        visible = bottomSheetScaffoldState.bottomSheetState.isCollapsed,\n                        enter = fadeIn(),\n                        exit = fadeOut(), modifier = Modifier.constrainAs(expandableFabSection) {\n                            end.linkTo(parent.end, margin = 8.dp)\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                        }) {\n\n                        ExpandableFABSection(\n                            onClickEmergencyCall = { event(MappingUiEvent.ShowEmergencyCallDialog) },\n                            onClickFamilyTracker = { event(MappingUiEvent.OpenFamilyTracker) },\n                            onClickRescueRequest = { event(MappingUiEvent.ShowRescueRequestDialog) },\n                            onClickFab = { event(MappingUiEvent.OnToggleExpandableFAB) },\n                            onClickBikeTracker = { event(MappingUiEvent.ShowSinoTrackWebView) },\n                            isFabExpanded = uiState.isFabExpanded,\n                            badgeCount = respondentCount\n                        )\n                    }\n\n\n                    val buttonVisible =\n                        isNavigating.not() && uiState.isFabExpanded.not() && bottomSheetScaffoldState.bottomSheetState.isCollapsed\n                    val requestHelpVisible = uiState.requestHelpButtonVisible && buttonVisible\n                    val respondToHelpVisible =\n                        uiState.requestHelpButtonVisible.not() && buttonVisible\n\n                    RequestHelpButton(\n                        modifier = Modifier.constrainAs(requestHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        }, onClickRequestHelpButton = { event(MappingUiEvent.RequestHelp) },\n                        state = state,\n                        visible = requestHelpVisible\n\n                    )\n\n                    RespondToHelpButton(\n                        modifier = Modifier.constrainAs(respondToHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        },\n                        onClickRespondButton = { event(MappingUiEvent.RespondToHelp) },\n                        state = state,\n                        visible = respondToHelpVisible\n                    )\n\n                    if (state.isLoading) {\n                        CircularProgressIndicator(\n                            modifier = Modifier.constrainAs(\n                                circularProgressbar) {\n                                top.linkTo(parent.top)\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                this.centerTo(parent)\n                            })\n                    }\n\n\n                    if (uiState.isEmergencyCallDialogVisible) {\n                        EmergencyCallDialog(\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                            },\n                            onDismiss = { event(MappingUiEvent.DismissEmergencyCallDialog) },\n                            emergencyCallModel = emergencyState.emergencyCallModel,\n                            onClick = {\n                                event(\n                                    MappingUiEvent.OnEmergencyCall(\n                                        it.phoneNumber\n                                    )\n                                )\n                            }, onAddContact = {\n                                event(MappingUiEvent.OnAddEmergencyContact)\n                                event(MappingUiEvent.DismissEmergencyCallDialog)\n                            }\n\n                        )\n                    }\n\n                    if (uiState.isNoInternetVisible) {\n                        NoInternetDialog(\n                            onDismiss = { event(MappingUiEvent.DismissNoInternetDialog) },\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                            })\n                    }\n\n                    if (uiState.locationPermissionDialogVisible) {\n                        DialogForegroundLocationPermission(\n                            modifier = Modifier.constrainAs(\n                                dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            }, onDismiss = { event(MappingUiEvent.DismissLocationPermission) }\n                        )\n                    }\n\n                    if (uiState.phonePermissionDialogVisible) {\n                        DialogPhonePermission(modifier = Modifier.constrainAs(dialog) {\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                            bottom.linkTo(parent.bottom)\n                            height = Dimension.wrapContent\n                            centerTo(parent)\n                        }, onDismiss = { event(MappingUiEvent.DismissPhonePermission) })\n                    }\n\n                    AnimatedVisibility(\n                        visible = isRescueCancelled && uiState.rescueRequestAccepted.not(),\n                        enter = fadeIn(),\n                        exit = fadeOut(animationSpec = tween(durationMillis = 220))) {\n\n                        val rescueTransaction = state.rescueTransaction ?: return@AnimatedVisibility\n\n                        MappingRequestCancelled(\n                            modifier = Modifier.fillMaxSize(),\n                            onClickOkButton = { event(MappingUiEvent.CancelledRescueConfirmed) },\n                            cancelledRescueModel = CancelledRescueModel(\n                                transactionID = rescueTransaction.id,\n                                rescueCancelledBy = rescueTransaction.getCancellationName(),\n                                reason = rescueTransaction.getCancellationReason(),\n                                message = rescueTransaction.getCancellationMessage()\n                            ))\n                    }\n\n                    AnimatedVisibility(\n                        visible = uiState.rescueRequestAccepted && isRescueCancelled.not(),\n                        enter = fadeIn(),\n                        exit = fadeOut(animationSpec = tween(durationMillis = 220))) {\n                        MappingRequestAccepted(\n                            modifier = Modifier.fillMaxSize(),\n                            onClickOkButton = { event(MappingUiEvent.RescueRequestAccepted) },\n                            acceptedName = state.rescuee?.name ?: \"Name placeholder\",\n                        )\n                    }\n                }\n            }\n\n\n            if (uiState.isSinoTrackWebViewVisible) {\n                SinoTrackWebView(onDismiss = { event(MappingUiEvent.DismissSinoTrackWebView) })\n            }\n\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt	(date 1692090369839)
@@ -30,6 +30,7 @@
 import com.example.cyclistance.core.presentation.dialogs.permissions_dialog.DialogPhonePermission
 import com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.components.emergency_call.EmergencyCallDialog
 import com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.state.EmergencyCallState
+import com.example.cyclistance.feature_mapping.domain.model.api.user.UserItem
 import com.example.cyclistance.feature_mapping.domain.model.ui.rescue.CancelledRescueModel
 import com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.banner.MappingExpandableBanner
 import com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.bottomSheet.MappingBottomSheet
@@ -63,6 +64,7 @@
     isRescueCancelled: Boolean = false,
     isNavigating: Boolean,
     uiState: MappingUiState,
+    nearbyCyclist: List<UserItem>,
     locationPermissionState: MultiplePermissionsState = rememberMultiplePermissionsState(permissions = emptyList()),
     event: (MappingUiEvent) -> Unit = {},
 ) {
@@ -140,7 +142,8 @@
                         routeDirection = uiState.routeDirection,
                         isNavigating = isNavigating,
                         event = event,
-                        uiState = uiState
+                        uiState = uiState,
+                        nearbyCyclist = nearbyCyclist,
                     )
 
 
Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen\n\nimport android.Manifest\nimport android.annotation.SuppressLint\nimport android.app.Activity.RESULT_OK\nimport android.widget.Toast\nimport androidx.activity.compose.rememberLauncherForActivityResult\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.animation.*\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material.*\nimport androidx.compose.runtime.*\nimport androidx.compose.runtime.saveable.rememberSaveable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.hilt.navigation.compose.hiltViewModel\nimport androidx.lifecycle.compose.collectAsStateWithLifecycle\nimport androidx.navigation.NavController\nimport com.example.cyclistance.R\nimport com.example.cyclistance.core.domain.model.AlertDialogState\nimport com.example.cyclistance.core.utils.connection.ConnectionStatus.checkLocationSetting\nimport com.example.cyclistance.core.utils.connection.ConnectionStatus.hasGPSConnection\nimport com.example.cyclistance.core.utils.constants.EmergencyCallConstants.SHOULD_OPEN_CONTACT_DIALOG\nimport com.example.cyclistance.core.utils.constants.MappingConstants.DEFAULT_CAMERA_ANIMATION_DURATION\nimport com.example.cyclistance.core.utils.constants.MappingConstants.FAST_CAMERA_ANIMATION_DURATION\nimport com.example.cyclistance.core.utils.constants.MappingConstants.LOCATE_USER_ZOOM_LEVEL\nimport com.example.cyclistance.core.utils.constants.MappingConstants.ROUTE_SOURCE_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.SELECTION_RESCUEE_TYPE\nimport com.example.cyclistance.core.utils.constants.MappingConstants.SELECTION_RESCUER_TYPE\nimport com.example.cyclistance.core.utils.constants.NavigationConstants.LATITUDE\nimport com.example.cyclistance.core.utils.constants.NavigationConstants.LONGITUDE\nimport com.example.cyclistance.core.utils.contexts.callPhoneNumber\nimport com.example.cyclistance.core.utils.contexts.startLocationServiceIntentAction\nimport com.example.cyclistance.core.utils.permissions.requestPermission\nimport com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.EmergencyCallViewModel\nimport com.example.cyclistance.feature_mapping.domain.model.Role\nimport com.example.cyclistance.feature_mapping.domain.model.ui.camera.CameraState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.*\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingVmEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.BottomSheetType\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.animateCameraPosition\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.changeToNormalPuckIcon\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.openNavigationApp\nimport com.example.cyclistance.navigation.Screens\nimport com.example.cyclistance.navigation.nav_graph.navigateScreen\nimport com.google.accompanist.permissions.ExperimentalPermissionsApi\nimport com.google.accompanist.permissions.isGranted\nimport com.google.accompanist.permissions.rememberMultiplePermissionsState\nimport com.google.accompanist.permissions.rememberPermissionState\nimport com.mapbox.core.constants.Constants.PRECISION_6\nimport com.mapbox.geojson.Feature\nimport com.mapbox.geojson.FeatureCollection\nimport com.mapbox.geojson.LineString\nimport com.mapbox.geojson.Point\nimport com.mapbox.mapboxsdk.geometry.LatLng\nimport com.mapbox.mapboxsdk.location.LocationComponentActivationOptions\nimport com.mapbox.mapboxsdk.location.modes.CameraMode\nimport com.mapbox.mapboxsdk.location.modes.RenderMode\nimport com.mapbox.mapboxsdk.maps.MapboxMap\nimport com.mapbox.mapboxsdk.style.sources.GeoJsonSource\nimport kotlinx.coroutines.flow.collectLatest\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\n\n\n@SuppressLint(\"MissingPermission\")\n@OptIn(ExperimentalMaterialApi::class)\n@ExperimentalPermissionsApi\n@Composable\nfun MappingScreen(\n    hasInternetConnection: Boolean,\n    mappingViewModel: MappingViewModel = hiltViewModel(),\n    emergencyViewModel: EmergencyCallViewModel = hiltViewModel(),\n    paddingValues: PaddingValues,\n    isNavigating: Boolean,\n    onChangeNavigatingState: (isNavigating: Boolean) -> Unit,\n    navController: NavController) {\n\n\n    val context = LocalContext.current\n    val state by mappingViewModel.state.collectAsStateWithLifecycle()\n    val emergencyState by emergencyViewModel.state.collectAsStateWithLifecycle()\n    val coroutineScope = rememberCoroutineScope()\n\n    var uiState by rememberSaveable { mutableStateOf(MappingUiState()) }\n    var cameraState by rememberSaveable { mutableStateOf(CameraState()) }\n    val locationComponentOptions = MappingUtils.rememberLocationComponentOptions()\n    var mapboxMap by remember<MutableState<MapboxMap?>> {\n        mutableStateOf(null)\n    }\n\n    val bottomSheetScaffoldState = rememberBottomSheetScaffoldState(\n        bottomSheetState = rememberBottomSheetState(initialValue = BottomSheetValue.Collapsed)\n    )\n\n    val collapseBottomSheet = remember {\n        {\n            coroutineScope.launch {\n                if (bottomSheetScaffoldState.bottomSheetState.isExpanded) {\n                    bottomSheetScaffoldState.bottomSheetState.collapse()\n                }\n            }\n        }\n    }\n\n    val expandBottomSheet = remember {\n        {\n            coroutineScope.launch {\n                if (bottomSheetScaffoldState.bottomSheetState.isCollapsed) {\n                    bottomSheetScaffoldState.bottomSheetState.expand()\n                }\n            }\n        }\n    }\n\n\n    val foregroundLocationPermissionsState = rememberMultiplePermissionsState(\n        permissions = listOf(\n            Manifest.permission.ACCESS_FINE_LOCATION,\n            Manifest.permission.ACCESS_COARSE_LOCATION))\n\n\n    val userLocationAvailable by remember(\n        foregroundLocationPermissionsState.allPermissionsGranted,\n        state.userLocation) {\n        derivedStateOf {\n            foregroundLocationPermissionsState.allPermissionsGranted.and(state.userLocation != null)\n        }\n    }\n\n\n    val pulsingEnabled by remember(\n        uiState.searchingAssistance,\n        foregroundLocationPermissionsState.allPermissionsGranted\n    ) {\n        derivedStateOf { uiState.searchingAssistance.and(foregroundLocationPermissionsState.allPermissionsGranted) }\n    }\n\n\n    val showUserLocation = remember(mapboxMap, isNavigating, userLocationAvailable) {\n        {\n            mapboxMap?.style?.let { style ->\n                if (isNavigating) {\n\n                    val buildLocationComponentActivationOptions =\n                        LocationComponentActivationOptions.builder(context, style)\n                            .locationComponentOptions(locationComponentOptions.build())\n                            .build()\n                    mapboxMap?.locationComponent?.apply {\n                        activateLocationComponent(buildLocationComponentActivationOptions)\n                        isLocationComponentEnabled = userLocationAvailable\n                        cameraMode = CameraMode.NONE\n                        renderMode = RenderMode.GPS\n\n                    }\n\n                } else {\n                    val buildLocationComponentActivationOptions =\n                        LocationComponentActivationOptions.builder(context, style)\n                            .locationComponentOptions(\n                                locationComponentOptions\n                                    .changeToNormalPuckIcon(context)\n                                    .pulseEnabled(pulsingEnabled)\n                                    .build())\n                            .build()\n                    mapboxMap?.locationComponent?.apply {\n                        activateLocationComponent(buildLocationComponentActivationOptions)\n                        isLocationComponentEnabled = userLocationAvailable\n                        cameraMode = CameraMode.NONE\n                        renderMode = RenderMode.NORMAL\n                    }\n                }\n            }\n            Unit\n        }\n    }\n\n\n    val locateUser =\n        remember(userLocationAvailable, mapboxMap) {\n            { zoomLevel: Double, latLng: LatLng, cameraAnimationDuration: Int ->\n\n                val mapboxLoaded =\n                    (mapboxMap?.locationComponent != null) && (mapboxMap?.style?.isFullyLoaded\n                                                               ?: false)\n                if (userLocationAvailable && mapboxLoaded) {\n                    showUserLocation()\n                    mapboxMap?.animateCameraPosition(\n                        latLng = latLng,\n                        zoomLevel = zoomLevel,\n                        cameraAnimationDuration = cameraAnimationDuration)\n                }\n            }\n        }\n\n\n    val onInitializeMapboxMap = remember(userLocationAvailable) {\n        { mbm: MapboxMap ->\n            if (mapboxMap == null) {\n                mapboxMap = mbm\n            }\n\n            if (userLocationAvailable) {\n                val camera = cameraState\n                locateUser(camera.zoom, camera.position, FAST_CAMERA_ANIMATION_DURATION)\n\n            }\n        }\n    }\n\n\n    val settingResultRequest = rememberLauncherForActivityResult(\n        contract = ActivityResultContracts.StartIntentSenderForResult()\n    ) { activityResult ->\n        if (activityResult.resultCode == RESULT_OK) {\n            context.startLocationServiceIntentAction()\n            Timber.d(\"GPS Setting Request Accepted\")\n            return@rememberLauncherForActivityResult\n        }\n        Timber.d(\"GPS Setting Request Denied\")\n    }\n\n    val requestHelp = remember {\n        {\n            if (!context.hasGPSConnection()) {\n                context.checkLocationSetting(\n                    onDisabled = settingResultRequest::launch,\n                    onEnabled = {\n                        mappingViewModel.onEvent(\n                            event = MappingVmEvent.RequestHelp)\n\n                    })\n            } else {\n                mappingViewModel.onEvent(\n                    event = MappingVmEvent.RequestHelp)\n\n            }\n        }\n    }\n\n    val onClickRequestHelpButton = remember {\n        {\n            foregroundLocationPermissionsState.requestPermission(\n                onGranted = {\n                    context.startLocationServiceIntentAction()\n                    requestHelp()\n                }, onExplain = {\n                    uiState = uiState.copy(locationPermissionDialogVisible = true)\n                })\n\n        }\n    }\n\n\n    val showRouteDirection = remember(uiState.routeDirection, mapboxMap) {\n        {\n\n            uiState.routeDirection?.geometry?.let { geometry ->\n\n                mapboxMap?.getStyle { style ->\n                    if (style.isFullyLoaded.not() || geometry.isEmpty()) {\n                        return@getStyle\n                    }\n\n                    val routeLineSource = style.getSourceAs<GeoJsonSource>(ROUTE_SOURCE_ID)\n                    routeLineSource?.setGeoJson(\n                        FeatureCollection.fromFeature(\n                            Feature.fromGeometry(\n                                LineString.fromPolyline(geometry, PRECISION_6))))\n                }\n            }\n            Unit\n        }\n    }\n\n    val removeRouteDirection = remember(mapboxMap) {\n        {\n            mapboxMap?.getStyle { style ->\n\n                if (style.isFullyLoaded.not()) {\n                    return@getStyle\n                }\n\n                val routeLineSource = style.getSourceAs<GeoJsonSource>(ROUTE_SOURCE_ID)\n                routeLineSource?.setGeoJson(FeatureCollection.fromFeatures(arrayOf()))\n            }\n            Unit\n        }\n    }\n\n\n    val onClickLocateUserButton = remember {\n        {\n            foregroundLocationPermissionsState.requestPermission(\n                onGranted = {\n                    if (!context.hasGPSConnection()) {\n                        context.checkLocationSetting(\n                            onDisabled = settingResultRequest::launch)\n                    }\n                    state.userLocation?.let {\n                        it.latitude ?: return@let\n                        it.longitude ?: return@let\n                        val point = LatLng(it.latitude, it.longitude)\n                        locateUser(LOCATE_USER_ZOOM_LEVEL, point, DEFAULT_CAMERA_ANIMATION_DURATION)\n                    }\n\n                }, onExplain = {\n                    uiState = uiState.copy(locationPermissionDialogVisible = true)\n                })\n        }\n    }\n\n    val openNavigationApp = remember(state.rescueTransaction?.route) {\n        {\n            val rescueTransaction = state.rescueTransaction\n            rescueTransaction?.let{\n                val latitude =  it.getDestinationLatitude() ?: return@let\n                val longitude = it.getDestinationLongitude() ?: return@let\n                context.openNavigationApp(latitude = latitude, longitude = longitude)\n            }\n\n        }\n    }\n\n    val onClickRouteOverViewButton = remember(mapboxMap) {\n        {\n            mapboxMap?.locationComponent?.cameraMode = CameraMode.TRACKING\n        }\n    }\n\n    val onClickRecenterButton = remember(mapboxMap) {\n        {\n            mapboxMap?.locationComponent?.cameraMode = CameraMode.TRACKING_GPS\n        }\n    }\n\n    val onClickOpenNavigationButton = remember {\n        {\n            openNavigationApp()\n        }\n    }\n\n    val onClickCancelSearchButton = remember {\n        {\n            coroutineScope.launch {\n                collapseBottomSheet()\n            }.invokeOnCompletion {\n                mappingViewModel.onEvent(event = MappingVmEvent.CancelRequestHelp)\n                uiState = uiState.copy(searchingAssistance = false)\n            }\n            Unit\n        }\n    }\n\n    val onChangeCameraPosition = remember {\n        { _cameraState: CameraState ->\n            cameraState = _cameraState\n\n        }\n    }\n\n    val onClickCancelRescueButton = remember(state.rescuer, state.rescueTransaction) {\n        {\n            val role = state.user.transaction?.role\n            val isRescuee = role == Role.RESCUEE.name.lowercase()\n            val transactionId = state.rescueTransaction?.id\n            val selectionType = if (isRescuee) SELECTION_RESCUEE_TYPE else SELECTION_RESCUER_TYPE\n            val clientId = state.rescuer?.id ?: state.rescuee?.id\n\n            navController.navigateScreen(route = \"${Screens.MappingNavigation.Cancellation.screenRoute}/$selectionType/$transactionId/$clientId\")\n\n        }\n    }\n\n    val onDismissNoInternetDialog = remember {\n        {\n            uiState = uiState.copy(\n                isNoInternetVisible = false\n            )\n        }\n    }\n\n    val hasTransaction = remember(key1 = state.rescueTransaction, key2 = state.user.transaction) {\n        val transaction = state.rescueTransaction\n        val rescueTransactionId = state.rescueTransaction?.id ?: \"\"\n        val userTransactionId = state.user.transaction?.transactionId ?: \"\"\n        transaction != null && rescueTransactionId.isNotEmpty() && userTransactionId.isNotEmpty()\n    }\n\n    val isRescueCancelled =\n        remember(state.rescueTransaction) {\n            (state.rescueTransaction?.cancellation)?.rescueCancelled == true\n        }\n\n    val clientPhoneNumber = remember(state.rescuee, state.rescuer) {\n        val client = state.rescuee ?: state.rescuer\n        client?.contactNumber\n    }\n\n    val callClient = remember(clientPhoneNumber) {\n        {\n            clientPhoneNumber?.let(context::callPhoneNumber)\n        }\n    }\n    val phonePermissionState =\n        rememberPermissionState(permission = Manifest.permission.CALL_PHONE) { permissionGranted ->\n            if (permissionGranted) {\n                callClient()\n            }\n        }\n    val onClickChatButton = remember(clientPhoneNumber) {\n        {\n\n\n        }\n    }\n\n    val onClickCallButton = remember(clientPhoneNumber) {\n        {\n            phonePermissionState.requestPermission(\n                onGranted = {\n                    callClient()\n                },\n                onExplain = {\n                    uiState = uiState.copy(phonePermissionDialogVisible = true)\n                })\n        }\n    }\n\n    val onRequestNavigationCameraToOverview = remember(mapboxMap) {\n        {\n            val locationComponent = mapboxMap?.locationComponent\n            locationComponent?.cameraMode = CameraMode.TRACKING\n        }\n    }\n\n    val onClickOkCancelledRescue = remember {\n        {\n            mappingViewModel.onEvent(event = MappingVmEvent.CancelRescueTransaction)\n        }\n    }\n\n    val onClickRescueeMapIcon = remember {\n        { id: String ->\n            mappingViewModel.onEvent(event = MappingVmEvent.SelectRescueMapIcon(id))\n        }\n    }\n\n    val onDismissRescueeBanner = remember {\n        {\n            val isRescueeBannerVisible = uiState.mapSelectedRescuee != null\n            if (isRescueeBannerVisible) {\n                uiState = uiState.copy(\n                    mapSelectedRescuee = null,\n                    requestHelpButtonVisible = true\n                )\n            }\n        }\n    }\n\n\n    val onCollapseExpandableFAB = remember {\n        {\n            uiState = uiState.copy(\n                isFabExpanded = false\n            )\n        }\n    }\n\n\n    val onToggleExpandedFAB = remember {\n        {\n            uiState = uiState.copy(\n                isFabExpanded = !uiState.isFabExpanded\n            )\n        }\n    }\n\n    val onMapClick = remember {\n        {\n            if (uiState.bottomSheetType == BottomSheetType.ReportIncident.type) {\n                collapseBottomSheet()\n            }\n            onDismissRescueeBanner()\n            onCollapseExpandableFAB()\n\n        }\n    }\n\n    val onMapLongClick = remember {\n        {\n            onDismissRescueeBanner()\n            onCollapseExpandableFAB()\n            uiState = uiState.copy(bottomSheetType = BottomSheetType.ReportIncident.type).also {\n                expandBottomSheet()\n            }\n        }\n    }\n\n    val onClickRespondToHelpButton = remember {\n        {\n            uiState.mapSelectedRescuee?.let {\n                mappingViewModel.onEvent(\n                    event = MappingVmEvent.RespondToHelp(\n                        selectedRescuee = it\n                    ))\n            }\n            Unit\n        }\n    }\n    val onClickOkAcceptedRescue = remember {\n        {\n            onChangeNavigatingState(true)\n            uiState = uiState.copy(\n                rescueRequestAccepted = false,\n                bottomSheetType = BottomSheetType.OnGoingRescue.type\n            ).also {\n                expandBottomSheet()\n            }\n        }\n    }\n\n    val onDismissLocationPermissionDialog = remember {\n        {\n            uiState = uiState.copy(locationPermissionDialogVisible = false)\n        }\n    }\n\n    val onDismissPhonePermissionDialog = remember {\n        {\n            uiState = uiState.copy(phonePermissionDialogVisible = false)\n        }\n    }\n    val onClickCancelButton = remember {\n        { id: String ->\n            mappingViewModel.onEvent(MappingVmEvent.DeclineRescueRequest(id))\n        }\n    }\n\n    val onClickConfirmButton = remember {\n        { id: String ->\n            mappingViewModel.onEvent(MappingVmEvent.AcceptRescueRequest(id))\n        }\n    }\n\n    val onClickReportIncident = remember {\n        {\n\n        }\n    }\n\n    val showEmergencyCallDialog = remember {\n        {\n            uiState = uiState.copy(\n                isEmergencyCallDialogVisible = true\n            )\n        }\n    }\n\n    val dismissEmergencyCallDialog = remember {\n        {\n            uiState = uiState.copy(\n                isEmergencyCallDialogVisible = false\n            )\n        }\n    }\n\n    val onDismissAlertDialog = remember {\n        {\n            uiState = uiState.copy(\n                alertDialogState = AlertDialogState()\n            )\n        }\n    }\n\n    val onShowRescueRequestDialog = remember {\n        {\n            uiState = uiState.copy(\n                isRescueRequestDialogVisible = true\n            )\n        }\n    }\n\n    val onDismissRescueRequestDialog = remember {\n        {\n            uiState = uiState.copy(\n                isRescueRequestDialogVisible = false\n            )\n        }\n    }\n\n    val onDismissSinoTrackWebView = remember {\n        {\n            uiState = uiState.copy(\n                isSinoTrackWebViewVisible = false\n            )\n        }\n    }\n\n    val onShowSinoTrackWebView = remember {\n        {\n            uiState = uiState.copy(\n                isSinoTrackWebViewVisible = true\n            )\n        }\n    }\n\n    val onDismissRescueResultsDialog = remember {\n        {\n            uiState = uiState.copy(\n                isRescueResultsDialogVisible = false\n            )\n        }\n    }\n\n    val callPhoneNumber = remember {\n        { phoneNumber: String ->\n            context.callPhoneNumber(phoneNumber)\n        }\n    }\n\n    val openPhoneCallPermissionState =\n        rememberPermissionState(permission = Manifest.permission.CALL_PHONE) { permissionGranted ->\n            if (permissionGranted) {\n                uiState.selectedPhoneNumber.takeIf { it.isNotEmpty() }\n                    ?.let { callPhoneNumber(it) }\n            }\n        }\n\n    val onEmergencyCall = remember {\n        { phoneNumber: String ->\n            if (!openPhoneCallPermissionState.status.isGranted) {\n                uiState = uiState.copy(selectedPhoneNumber = phoneNumber)\n                openPhoneCallPermissionState.launchPermissionRequest()\n            } else {\n                callPhoneNumber(phoneNumber)\n            }\n        }\n    }\n\n    val onAddEmergencyContact = remember {\n        {\n            navController.navigateScreen(Screens.EmergencyCallNavigation.EmergencyCall.screenRoute + \"?$SHOULD_OPEN_CONTACT_DIALOG=${true}\")\n        }\n    }\n\n\n    LaunchedEffect(key1 = true, key2 = state.userLocation) {\n\n        mappingViewModel.eventFlow.collectLatest { event ->\n            when (event) {\n\n\n                is MappingEvent.RequestHelpSuccess -> {\n                    navController.navigateScreen(\n                        Screens.MappingNavigation.ConfirmDetails.screenRoute + \"?$LATITUDE=${state.userLocation?.latitude}&$LONGITUDE=${state.userLocation?.longitude}\")\n                }\n\n                is MappingEvent.InsufficientUserCredential -> {\n                    navController.navigateScreen(\n                        Screens.SettingsNavigation.EditProfile.screenRoute)\n                }\n\n                is MappingEvent.LocationNotAvailable -> {\n                    Toast.makeText(context, event.reason, Toast.LENGTH_SHORT).show()\n                }\n\n                is MappingEvent.RescuerLocationNotAvailable -> {\n                    Toast.makeText(context, event.reason, Toast.LENGTH_SHORT).show()\n                }\n\n                is MappingEvent.UnexpectedError -> {\n                    Toast.makeText(context, event.reason, Toast.LENGTH_SHORT).show()\n                }\n\n                is MappingEvent.UserFailed -> {\n                    Toast.makeText(context, event.reason, Toast.LENGTH_SHORT).show()\n                }\n\n                is MappingEvent.RespondToHelpSuccess -> {\n                    Toast.makeText(context, event.reason, Toast.LENGTH_SHORT).show()\n                }\n\n                is MappingEvent.AddressFailed -> {\n                    Toast.makeText(context, event.reason, Toast.LENGTH_SHORT).show()\n                }\n\n                is MappingEvent.NoInternetConnection -> {\n                    uiState = uiState.copy(\n                        isNoInternetVisible = true\n                    )\n                }\n\n                is MappingEvent.NewSelectedRescuee -> {\n                    uiState = uiState.copy(\n                        mapSelectedRescuee = event.selectedRescuee,\n                        requestHelpButtonVisible = false\n                    )\n                }\n\n                is MappingEvent.NewRouteDirection -> {\n                    uiState = uiState.copy(\n                        routeDirection = event.routeDirection\n                    )\n                }\n\n                is MappingEvent.RemoveAssignedTransactionSuccess -> {\n                    uiState = uiState.copy(\n                        rescueRequestAccepted = false,\n                        requestHelpButtonVisible = true,\n                        searchingAssistance = false,\n                        routeDirection = null,\n                        mapSelectedRescuee = null,\n                    ).also {\n                        collapseBottomSheet()\n                    }\n                    onChangeNavigatingState(false)\n\n                }\n\n                is MappingEvent.RescueRequestAccepted -> {\n                    uiState = uiState.copy(\n                        rescueRequestAccepted = true\n                    )\n                }\n\n                is MappingEvent.CancelHelpRequestSuccess -> {\n                    uiState = uiState.copy(\n                        requestHelpButtonVisible = true\n                    )\n                }\n\n                is MappingEvent.AcceptRescueRequestSuccess -> {\n                    uiState = uiState.copy(\n                        requestHelpButtonVisible = false,\n                        bottomSheetType = BottomSheetType.OnGoingRescue.type\n                    ).also {\n                        expandBottomSheet()\n                        onDismissRescueRequestDialog()\n                    }\n                }\n\n                is MappingEvent.FailedToCalculateDistance -> {\n                    Toast.makeText(context, \"Failed to Calculate Distance\", Toast.LENGTH_SHORT)\n                        .show()\n                }\n\n                is MappingEvent.DestinationReached -> {\n                    val role = state.user.transaction?.role\n                    val type = if (role == Role.RESCUEE.name.lowercase()) {\n                        BottomSheetType.RescuerArrived.type\n                    } else {\n                        BottomSheetType.DestinationReached.type\n                    }\n                    uiState = uiState.copy(bottomSheetType = type).also {\n                        expandBottomSheet()\n                    }\n\n                }\n\n                is MappingEvent.RemoveRespondentFailed -> {\n                    Toast.makeText(context, event.reason, Toast.LENGTH_SHORT).show()\n                }\n\n                is MappingEvent.RescueHasTransaction -> {\n                    uiState = uiState.copy(\n                        alertDialogState = AlertDialogState(\n                            title = \"Cannot Request\",\n                            description = \"Unfortunately the Rescuer is currently in a Rescue.\",\n                            icon = R.raw.error\n                        )\n                    )\n                }\n\n                is MappingEvent.UserHasCurrentTransaction -> {\n                    uiState = uiState.copy(\n                        alertDialogState = AlertDialogState(\n                            title = \"Cannot Request\",\n                            description = \"You can only have one transaction at a time\",\n                            icon = R.raw.error\n                        )\n                    )\n                }\n\n\n                else -> {}\n            }\n        }\n    }\n\n\n    LaunchedEffect(key1 = uiState.routeDirection, key2 = mapboxMap) {\n\n        val route = uiState.routeDirection ?: return@LaunchedEffect\n\n        if (route.geometry.isEmpty()) {\n            removeRouteDirection()\n            return@LaunchedEffect\n        }\n        showRouteDirection()\n    }\n\n\n    LaunchedEffect(\n        key1 = state.rescueTransaction?.route,\n        key2 = hasTransaction,\n        key3 = isRescueCancelled) {\n\n        val rescueTransaction = state.rescueTransaction\n\n\n        if (hasTransaction.not() || isRescueCancelled) {\n            uiState = uiState.copy(routeDirection = null)\n            return@LaunchedEffect\n        }\n\n\n        val startingLongitude = rescueTransaction?.getStartingLongitude() ?: return@LaunchedEffect\n        val startingLatitude = rescueTransaction.getStartingLatitude() ?: return@LaunchedEffect\n        val destinationLongitude = rescueTransaction.getDestinationLongitude() ?: return@LaunchedEffect\n        val destinationLatitude = rescueTransaction.getDestinationLatitude() ?: return@LaunchedEffect\n\n        mappingViewModel.onEvent(\n            event = MappingVmEvent.GetRouteDirections(\n                origin = Point.fromLngLat(startingLongitude, startingLatitude),\n                destination = Point.fromLngLat(\n                    destinationLongitude,\n                    destinationLatitude)))\n\n\n    }\n\n\n\n    LaunchedEffect(key1 = hasInternetConnection) {\n        val nearbyCyclistLoaded = state.nearbyCyclists != null\n        val userLoaded = state.user.id != null\n        val dataHaveBeenLoaded = userLoaded && nearbyCyclistLoaded\n\n        if (hasInternetConnection.not()) {\n            return@LaunchedEffect\n        }\n\n        if (dataHaveBeenLoaded.not()) {\n            mappingViewModel.onEvent(MappingVmEvent.LoadData)\n        }\n        mappingViewModel.onEvent(MappingVmEvent.SubscribeToDataChanges)\n    }\n\n\n\n    LaunchedEffect(key1 = isNavigating, key2 = userLocationAvailable, key3 = pulsingEnabled) {\n        showUserLocation()\n    }\n\n    LaunchedEffect(key1 = uiState.bottomSheetType) {\n        coroutineScope.launch {\n            if (uiState.bottomSheetType?.isNotEmpty() == true) {\n                expandBottomSheet()\n            }\n        }\n    }\n\n\n\n    LaunchedEffect(key1 = hasTransaction, key2 = isRescueCancelled) {\n\n        if (hasTransaction.not()) {\n            return@LaunchedEffect\n        }\n\n        if (isRescueCancelled) {\n            return@LaunchedEffect\n        }\n\n        onChangeNavigatingState(false)\n\n    }\n\n\n    LaunchedEffect(key1 = foregroundLocationPermissionsState.allPermissionsGranted) {\n        if (!foregroundLocationPermissionsState.allPermissionsGranted) {\n            return@LaunchedEffect\n        }\n\n        if (!context.hasGPSConnection()) {\n            context.checkLocationSetting(onDisabled = settingResultRequest::launch)\n        }\n\n        context.startLocationServiceIntentAction()\n\n    }\n\n\n\n\n\n    MappingScreenContent(\n        modifier = Modifier.padding(paddingValues),\n        state = state,\n        locationPermissionState = foregroundLocationPermissionsState,\n        bottomSheetScaffoldState = bottomSheetScaffoldState,\n        hasTransaction = hasTransaction,\n        isRescueCancelled = isRescueCancelled,\n        isNavigating = isNavigating,\n        mapboxMap = mapboxMap,\n        uiState = uiState,\n        emergencyState = emergencyState,\n        event = { event ->\n            when (event) {\n                is MappingUiEvent.RequestHelp -> onClickRequestHelpButton()\n                is MappingUiEvent.RespondToHelp -> onClickRespondToHelpButton()\n                is MappingUiEvent.CancelSearchConfirmed -> onClickCancelSearchButton()\n                is MappingUiEvent.CallRescueTransaction -> onClickCallButton()\n                is MappingUiEvent.ChatRescueTransaction -> onClickChatButton()\n                is MappingUiEvent.CancelRescueTransaction -> onClickCancelRescueButton()\n                is MappingUiEvent.CancelledRescueConfirmed -> onClickOkCancelledRescue()\n                is MappingUiEvent.OnInitializeMap -> onInitializeMapboxMap(event.mapboxMap)\n                is MappingUiEvent.RescueRequestAccepted -> onClickOkAcceptedRescue()\n                is MappingUiEvent.OnChangeCameraState -> onChangeCameraPosition(event.cameraState)\n                is MappingUiEvent.DismissNoInternetDialog -> onDismissNoInternetDialog()\n                is MappingUiEvent.RescueeMapIconSelected -> onClickRescueeMapIcon(event.id)\n                is MappingUiEvent.OnMapClick -> onMapClick()\n                is MappingUiEvent.DismissBanner -> onDismissRescueeBanner()\n                is MappingUiEvent.LocateUser -> onClickLocateUserButton()\n                is MappingUiEvent.RouteOverview -> onClickRouteOverViewButton()\n                is MappingUiEvent.RecenterRoute -> onClickRecenterButton()\n                is MappingUiEvent.OpenNavigation -> onClickOpenNavigationButton()\n                is MappingUiEvent.OnRequestNavigationCameraToOverview -> onRequestNavigationCameraToOverview()\n                is MappingUiEvent.RescueArrivedConfirmed -> {}\n                is MappingUiEvent.DestinationReachedConfirmed -> {}\n                is MappingUiEvent.DismissLocationPermission -> onDismissLocationPermissionDialog()\n                is MappingUiEvent.DismissPhonePermission -> onDismissPhonePermissionDialog()\n                is MappingUiEvent.OnToggleExpandableFAB -> onToggleExpandedFAB()\n                is MappingUiEvent.ShowEmergencyCallDialog -> showEmergencyCallDialog()\n                is MappingUiEvent.DismissEmergencyCallDialog -> dismissEmergencyCallDialog()\n                is MappingUiEvent.OpenFamilyTracker -> {}\n                is MappingUiEvent.ShowRescueRequestDialog -> onShowRescueRequestDialog()\n                is MappingUiEvent.DismissRescueRequestDialog -> onDismissRescueRequestDialog()\n                is MappingUiEvent.CancelRequestHelp -> onClickCancelButton(event.id)\n                is MappingUiEvent.ConfirmRequestHelp -> onClickConfirmButton(event.id)\n                is MappingUiEvent.DismissAlertDialog -> onDismissAlertDialog()\n                is MappingUiEvent.OnCollapseExpandableFAB -> onCollapseExpandableFAB()\n                is MappingUiEvent.OnMapLongClick -> onMapLongClick()\n                is MappingUiEvent.OnReportIncident -> onClickReportIncident()\n                is MappingUiEvent.DismissSinoTrackWebView -> onDismissSinoTrackWebView()\n                is MappingUiEvent.ShowSinoTrackWebView -> onShowSinoTrackWebView()\n                is MappingUiEvent.DismissRescueResultsDialog -> onDismissRescueResultsDialog()\n                is MappingUiEvent.OnEmergencyCall -> onEmergencyCall(event.phoneNumber)\n                is MappingUiEvent.OnAddEmergencyContact -> onAddEmergencyContact()\n\n\n            }\n        }\n\n\n    )\n\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingScreen.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingScreen.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingScreen.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingScreen.kt	(date 1692092204082)
@@ -86,6 +86,7 @@
     val emergencyState by emergencyViewModel.state.collectAsStateWithLifecycle()
     val coroutineScope = rememberCoroutineScope()
 
+    val nearbyCyclist = mappingViewModel.nearbyCyclistState
     var uiState by rememberSaveable { mutableStateOf(MappingUiState()) }
     var cameraState by rememberSaveable { mutableStateOf(CameraState()) }
     val locationComponentOptions = MappingUtils.rememberLocationComponentOptions()
@@ -837,7 +838,7 @@
 
 
     LaunchedEffect(key1 = hasInternetConnection) {
-        val nearbyCyclistLoaded = state.nearbyCyclists != null
+        val nearbyCyclistLoaded = nearbyCyclist.isNotEmpty()
         val userLoaded = state.user.id != null
         val dataHaveBeenLoaded = userLoaded && nearbyCyclistLoaded
 
@@ -902,6 +903,7 @@
     MappingScreenContent(
         modifier = Modifier.padding(paddingValues),
         state = state,
+        nearbyCyclist = nearbyCyclist,
         locationPermissionState = foregroundLocationPermissionsState,
         bottomSheetScaffoldState = bottomSheetScaffoldState,
         hasTransaction = hasTransaction,
Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/state/MappingState.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state\n\nimport android.os.Parcelable\nimport com.example.cyclistance.core.utils.annotations.StableState\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RescueTransactionItem\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.NearbyCyclist\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.UserItem\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.NewRescueRequestsModel\nimport kotlinx.parcelize.Parcelize\n\n@Parcelize\n@StableState\ndata class MappingState(\n    val isLoading: Boolean = false,\n    val userLocation: LocationModel? = null,\n    val rescueTransaction: RescueTransactionItem? = null,\n    val user: UserItem = UserItem(),\n    val rescueRequestAcceptedUser: UserItem? = null,\n    val rescuer: UserItem? = null,\n    val rescuee: UserItem? = null,\n    val profileUploaded: Boolean = false,\n    val respondedToHelp: Boolean = false,\n    val transactionLocation: LocationModel? = null,\n    val rescuerETA: String = \"\",\n    val rescuerDistance: String = \"\",\n    val nearbyCyclists: NearbyCyclist? = null,\n    val newRescueRequest: NewRescueRequestsModel? = null,\n    val speedometerState: SpeedometerState = SpeedometerState(),\n) : Parcelable{\n\n\n    fun getTravelledDistance() = speedometerState.travelledDistance\n    fun getTopSpeed() = speedometerState.topSpeed\n    fun getCurrentSpeedKph() = speedometerState.currentSpeedKph\n\n\n    fun getCurrentLocation() = user.location ?: userLocation\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/state/MappingState.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/state/MappingState.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/state/MappingState.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/state/MappingState.kt	(date 1692088036449)
@@ -4,7 +4,6 @@
 import com.example.cyclistance.core.utils.annotations.StableState
 import com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RescueTransactionItem
 import com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel
-import com.example.cyclistance.feature_mapping.domain.model.api.user.NearbyCyclist
 import com.example.cyclistance.feature_mapping.domain.model.api.user.UserItem
 import com.example.cyclistance.feature_mapping.domain.model.ui.rescue.NewRescueRequestsModel
 import kotlinx.parcelize.Parcelize
@@ -24,7 +23,6 @@
     val transactionLocation: LocationModel? = null,
     val rescuerETA: String = "",
     val rescuerDistance: String = "",
-    val nearbyCyclists: NearbyCyclist? = null,
     val newRescueRequest: NewRescueRequestsModel? = null,
     val speedometerState: SpeedometerState = SpeedometerState(),
 ) : Parcelable{
Index: app/src/main/java/com/example/cyclistance/core/utils/validation/FormatterUtils.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.core.utils.validation\n\nimport android.content.Context\nimport android.graphics.drawable.Drawable\nimport androidx.appcompat.content.res.AppCompatResources\nimport com.example.cyclistance.R\nimport com.example.cyclistance.core.utils.constants.MappingConstants\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel\nimport java.text.SimpleDateFormat\nimport java.util.Date\nimport java.util.Locale\n\nobject FormatterUtils {\n    private const val METER_TO_KILOMETER = 1000\n\n    fun Double.formatToDistanceKm(): String {\n\n        return if (this <= 0.0) {\n            \"0 m\"\n        } else if (this < 1000) {\n            \"%.2f m\".format(this)\n        } else {\n            \"%.2f km\".format((this / METER_TO_KILOMETER))\n        }\n    }\n\n\n\n\n    // TODO: test this code\n    fun LocationModel?.isLocationAvailable() = (this?.latitude != null).and(this?.longitude != null)\n\n    fun getCalculatedETA(\n        distanceMeters: Double,\n        averageSpeedKm: Double = MappingConstants.DEFAULT_BIKE_AVERAGE_SPEED_KM): String {\n        val distanceToKm = distanceMeters / 1000\n        if (distanceToKm <= 0.0) {\n            return \"0 min\"\n        }\n        val eta = distanceToKm / averageSpeedKm\n        val hours = eta.toInt()\n        val minutes = (eta - hours) * 60\n        val minutesInt = minutes.toInt()\n        val minsFormat = if (minutesInt <= 1) \"$minutesInt min\" else \"$minutesInt mins\"\n        val hourFormat = if (hours >= 1) \"$hours hrs \" else \"\"\n        return \"$hourFormat$minsFormat\"\n    }\n\n    // TODO: test this code\n    fun String.getMapIconImageDescription(context: Context): Drawable? {\n        this.getMapIconImage().let { image ->\n            return AppCompatResources.getDrawable(context, image)\n        }\n        return null\n    }\n\n    fun String.bikeDescriptionToIcon(): Int {\n        return when (this) {\n            MappingConstants.INJURY_TEXT -> {\n                R.drawable.ic_injury\n            }\n\n            MappingConstants.BROKEN_FRAME_TEXT -> {\n                R.drawable.ic_broken_frame\n            }\n\n            MappingConstants.INCIDENT_TEXT -> {\n                R.drawable.ic_injury\n            }\n\n            MappingConstants.BROKEN_CHAIN_TEXT -> {\n                R.drawable.ic_broken_chain\n            }\n\n            MappingConstants.FLAT_TIRES_TEXT -> {\n                R.drawable.ic_flat_tire\n            }\n\n            MappingConstants.FAULTY_BRAKES_TEXT -> {\n                R.drawable.ic_faulty_brakes\n            }\n\n            else -> throw RuntimeException(\"No icon found for $this\")\n        }\n    }\n\n    fun String.getMapIconImage(): Int {\n        return when (this) {\n            MappingConstants.INJURY_TEXT -> {\n                R.drawable.ic_injury_em\n            }\n\n            MappingConstants.BROKEN_FRAME_TEXT -> {\n                R.drawable.ic_broken_frame_em\n            }\n\n            MappingConstants.INCIDENT_TEXT -> {\n                R.drawable.ic_incident_em\n            }\n\n            MappingConstants.BROKEN_CHAIN_TEXT -> {\n                R.drawable.ic_broken_chain_em\n            }\n\n            MappingConstants.FLAT_TIRES_TEXT -> {\n                R.drawable.ic_flat_tire_em\n            }\n\n            MappingConstants.FAULTY_BRAKES_TEXT -> {\n                R.drawable.ic_faulty_brakes_em\n            }\n\n            else -> throw RuntimeException(\"No icon found for $this\")\n        }\n    }\n\n\n    fun Date.toReadableDateTime(pattern: String = \"dd/MM/yyyy HH:mm\"): String {\n        return SimpleDateFormat(pattern, Locale.getDefault()).format(this)\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/core/utils/validation/FormatterUtils.kt b/app/src/main/java/com/example/cyclistance/core/utils/validation/FormatterUtils.kt
--- a/app/src/main/java/com/example/cyclistance/core/utils/validation/FormatterUtils.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/core/utils/validation/FormatterUtils.kt	(date 1692089690533)
@@ -6,6 +6,7 @@
 import com.example.cyclistance.R
 import com.example.cyclistance.core.utils.constants.MappingConstants
 import com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel
+import com.example.cyclistance.feature_mapping.domain.model.api.user.UserItem
 import java.text.SimpleDateFormat
 import java.util.Date
 import java.util.Locale
@@ -24,7 +25,9 @@
         }
     }
 
-
+    fun MutableList<UserItem>.findUser(id: String): UserItem {
+        return find { it.id == id } ?: UserItem()
+    }
 
 
     // TODO: test this code
Index: app/src/main/java/com/example/cyclistance/feature_mapping/domain/helper/TrackingStateHandler.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.domain.helper\n\nimport com.example.cyclistance.core.utils.constants.MappingConstants\nimport com.example.cyclistance.core.utils.validation.FormatterUtils.formatToDistanceKm\nimport com.example.cyclistance.core.utils.validation.FormatterUtils.isLocationAvailable\nimport com.example.cyclistance.feature_authentication.domain.exceptions.AuthExceptions\nimport com.example.cyclistance.feature_mapping.domain.exceptions.MappingExceptions\nimport com.example.cyclistance.feature_mapping.domain.model.Role\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RescueTransaction\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RescueTransactionItem\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RouteModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.StatusModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.TransactionModel\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.UserItem\nimport com.example.cyclistance.feature_mapping.domain.model.location.LiveLocationWSModel\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.MapSelectedRescuee\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.NewRescueRequestsModel\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_settings.domain.exceptions.SettingExceptions\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.update\nimport timber.log.Timber\n\nclass TrackingStateHandler(\n\n    val state: MutableStateFlow<MappingState>,\n    val eventFlow: MutableSharedFlow<MappingEvent>) {\n\n\n    suspend fun updateClient() {\n\n        coroutineScope {\n            val rescueTransaction = state.value.rescueTransaction\n            val cyclists = state.value.nearbyCyclists\n            val userRole = state.value.user.getRole()\n\n            if (userRole == Role.RESCUEE.name.lowercase()) {\n                rescueTransaction?.rescuerId?.let { id ->\n                    state.update { it.copy(rescuer = cyclists?.findUser(id), rescuee = null) }\n                }\n                return@coroutineScope\n            }\n\n            rescueTransaction?.rescueeId?.let { rescueeId ->\n                state.update { it.copy(rescuee = cyclists?.findUser(rescueeId), rescuer = null) }\n            }\n\n        }\n    }\n\n    fun getUserRescueTransaction(rescueTransaction: RescueTransaction): RescueTransactionItem? {\n\n        val transactionId = state.value.user.transaction?.transactionId\n        return transactionId?.let { rescueTransaction.findTransaction(it) }\n\n    }\n\n    fun clearTransactionRoles() {\n        state.update {\n            it.copy(\n                respondedToHelp = true,\n                rescueTransaction = RescueTransactionItem(),\n                rescuee = null,\n                rescuer = null,\n                newRescueRequest = NewRescueRequestsModel(),\n                user = it.user.copy(transaction = TransactionModel())\n            )\n        }\n    }\n\n    suspend fun showSelectedRescuee(\n        selectedRescuee: UserItem,\n        distance: Double,\n        timeRemaining: String\n    ) {\n\n        eventFlow.emit(\n            value = MappingEvent.NewSelectedRescuee(\n                selectedRescuee = MapSelectedRescuee(\n                    userId = selectedRescuee.id!!,\n                    userProfileImage = selectedRescuee.profilePictureUrl\n                                       ?: MappingConstants.IMAGE_PLACEHOLDER_URL,\n                    name = selectedRescuee.name ?: \"name unavailable\",\n                    issue = selectedRescuee.getDescription() ?: \"\",\n                    bikeType = selectedRescuee.getBikeType() ?: \"\",\n                    address = selectedRescuee.address ?: \"\",\n                    message = selectedRescuee.getMessage() ?: \"\",\n                    distanceRemaining = distance.formatToDistanceKm(),\n                    timeRemaining = timeRemaining\n                )\n            )\n        )\n    }\n\n    fun updateLocation(location: LocationModel) {\n        val latitude = location.latitude ?: return\n        val longitude = location.longitude ?: return\n        state.update {\n            it.copy(\n                userLocation = LocationModel(\n                    latitude = latitude,\n                    longitude = longitude\n                )\n            )\n        }\n\n\n    }\n\n    fun updateTransactionLocation(location: LiveLocationWSModel) {\n        val longitude = location.longitude ?: return\n        val latitude = location.latitude ?: return\n        state.update {\n            it.copy(\n                transactionLocation = LocationModel(\n                    latitude = latitude,\n                    longitude = longitude\n                )\n            )\n        }\n    }\n\n    suspend inline fun checkCurrentTransactions(\n        user: UserItem,\n        rescuer: UserItem,\n        crossinline noCurrentTransaction: suspend () -> Unit\n    ) {\n\n        val userHasCurrentTransaction =\n            (user.transaction ?: TransactionModel()).transactionId.isNotEmpty()\n\n        val rescuerHasCurrentTransaction =\n            (rescuer.transaction ?: TransactionModel()).transactionId.isNotEmpty()\n\n        val rescuerLocationAvailable = rescuer.location.isLocationAvailable()\n        val userLocationAvailable = user.location.isLocationAvailable()\n\n        if (!rescuerLocationAvailable) {\n            eventFlow.emit(value = MappingEvent.RescuerLocationNotAvailable())\n            return\n        }\n\n        if (!userLocationAvailable) {\n            eventFlow.emit(value = MappingEvent.LocationNotAvailable(\"Location not found\"))\n            return\n        }\n\n        if (rescuerHasCurrentTransaction) {\n            eventFlow.emit(value = MappingEvent.RescueHasTransaction)\n            return\n        }\n\n        if (userHasCurrentTransaction) {\n            eventFlow.emit(value = MappingEvent.UserHasCurrentTransaction)\n            return\n        }\n\n\n        noCurrentTransaction()\n    }\n\n\n    fun getAcceptedRescueRequestItem(\n        transactionId: String,\n        rescuer: UserItem,\n\n    ): RescueTransactionItem {\n        val user = state.value.user\n        return RescueTransactionItem(\n            id = transactionId,\n            rescuerId = rescuer.id,\n            rescueeId = user.id,\n            status = StatusModel(started = true, onGoing = true),\n            route = RouteModel(\n                startingLocation = LocationModel(\n                    latitude = rescuer.location!!.latitude,\n                    longitude = rescuer.location.longitude\n                ),\n                destinationLocation = LocationModel(\n                    latitude = user.location!!.latitude,\n                    longitude = user.location.longitude\n                )\n            )\n        )\n    }\n\n    fun getTransactionId(rescuer: UserItem): String {\n        val user = state.value.user\n        return user.id?.take(3) + rescuer.id?.take(3) + System.currentTimeMillis().toString()\n            .takeLast(6)\n    }\n\n    suspend fun checkRescueRequestAccepted(rescueTransaction: RescueTransaction, id: String) {\n        val respondedToHelp = state.value.respondedToHelp\n        val user = state.value.user\n\n        val userId = state.value.user.id ?: id\n\n        if (respondedToHelp.not()) {\n            return\n        }\n\n\n\n        getUserRescueTransaction(rescueTransaction = rescueTransaction)\n            ?.let { transaction ->\n\n                if (transaction.isRescueCancelled()) {\n                    return@let\n                }\n\n                if (transaction.rescuerId != userId) {\n                    return@let\n                }\n\n                if (user.isRescuee()) {\n                    return@let\n                }\n\n                if (transaction.rescueeId.isNullOrEmpty()) {\n                    return@let\n                }\n\n                eventFlow.emit(value = MappingEvent.RescueRequestAccepted)\n            }\n\n\n    }\n\n    suspend fun handleException(exception: Throwable) {\n        when (exception) {\n\n            is MappingExceptions.NetworkException -> {\n                eventFlow.emit(value = MappingEvent.NoInternetConnection)\n            }\n\n            is MappingExceptions.UnexpectedErrorException -> {\n                eventFlow.emit(\n                    MappingEvent.UnexpectedError(\n                        reason = exception.message\n                    )\n                )\n            }\n\n            is AuthExceptions.UserException -> {\n                eventFlow.emit(\n                    MappingEvent.UserFailed(\n                        reason = exception.message\n                    )\n                )\n            }\n\n            is MappingExceptions.AddressException -> {\n                eventFlow.emit(\n                    MappingEvent.AddressFailed(\n                        reason = exception.message ?: \"Searching for GPS\"\n                    )\n                )\n            }\n\n            is SettingExceptions.PhoneNumberException, is MappingExceptions.NameException -> {\n                eventFlow.emit(MappingEvent.InsufficientUserCredential)\n            }\n\n            else -> {\n                Timber.e(\"Error HandleException: ${exception.message}\")\n            }\n\n        }\n    }\n\n\n    fun getTopSpeed(currentSpeed: Double) {\n        val topSpeed = state.value.getTopSpeed()\n        if (currentSpeed > topSpeed) {\n            state.update { it.copy(speedometerState = it.speedometerState.copy(topSpeed = currentSpeed)) }\n        }\n    }\n\n    fun setSpeed(currentSpeedKph: Double){\n        state.update { it.copy(speedometerState = it.speedometerState.copy(currentSpeedKph = currentSpeedKph)) }\n    }\n\n    fun setTravelledDistance(distance: String){\n\n        state.update { it.copy(speedometerState = it.speedometerState.copy(travelledDistance = distance)) }\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/domain/helper/TrackingStateHandler.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/domain/helper/TrackingStateHandler.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/domain/helper/TrackingStateHandler.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/domain/helper/TrackingStateHandler.kt	(date 1692089690546)
@@ -1,6 +1,7 @@
 package com.example.cyclistance.feature_mapping.domain.helper
 
 import com.example.cyclistance.core.utils.constants.MappingConstants
+import com.example.cyclistance.core.utils.validation.FormatterUtils.findUser
 import com.example.cyclistance.core.utils.validation.FormatterUtils.formatToDistanceKm
 import com.example.cyclistance.core.utils.validation.FormatterUtils.isLocationAvailable
 import com.example.cyclistance.feature_authentication.domain.exceptions.AuthExceptions
@@ -26,7 +27,7 @@
 import timber.log.Timber
 
 class TrackingStateHandler(
-
+    val nearbyCyclist: MutableList<UserItem>,
     val state: MutableStateFlow<MappingState>,
     val eventFlow: MutableSharedFlow<MappingEvent>) {
 
@@ -35,18 +36,18 @@
 
         coroutineScope {
             val rescueTransaction = state.value.rescueTransaction
-            val cyclists = state.value.nearbyCyclists
+            val cyclists = nearbyCyclist
             val userRole = state.value.user.getRole()
 
             if (userRole == Role.RESCUEE.name.lowercase()) {
                 rescueTransaction?.rescuerId?.let { id ->
-                    state.update { it.copy(rescuer = cyclists?.findUser(id), rescuee = null) }
+                    state.update { it.copy(rescuer = cyclists.findUser(id), rescuee = null) }
                 }
                 return@coroutineScope
             }
 
             rescueTransaction?.rescueeId?.let { rescueeId ->
-                state.update { it.copy(rescuee = cyclists?.findUser(rescueeId), rescuer = null) }
+                state.update { it.copy(rescuee = cyclists.findUser(rescueeId), rescuer = null) }
             }
 
         }
Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components\n\nimport android.annotation.SuppressLint\nimport android.graphics.Color\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.viewinterop.AndroidViewBinding\nimport androidx.core.content.ContextCompat\nimport androidx.core.graphics.drawable.toBitmap\nimport androidx.lifecycle.*\nimport com.example.cyclistance.R\nimport com.example.cyclistance.core.utils.constants.MappingConstants.ICON_LAYER_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.ICON_SOURCE_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.ROUTE_LAYER_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.ROUTE_SOURCE_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.TRANSACTION_ICON_ID\nimport com.example.cyclistance.core.utils.validation.FormatterUtils.getMapIconImageDescription\nimport com.example.cyclistance.databinding.ActivityMappingBinding\nimport com.example.cyclistance.feature_mapping.domain.model.Role\nimport com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RouteDirection\nimport com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.*\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.setDefaultSettings\nimport com.example.cyclistance.navigation.IsDarkTheme\nimport com.mapbox.geojson.Feature\nimport com.mapbox.geojson.FeatureCollection\nimport com.mapbox.geojson.Point\nimport com.mapbox.mapboxsdk.annotations.IconFactory\nimport com.mapbox.mapboxsdk.annotations.MarkerOptions\nimport com.mapbox.mapboxsdk.geometry.LatLng\nimport com.mapbox.mapboxsdk.maps.MapboxMap\nimport com.mapbox.mapboxsdk.maps.Style\nimport com.mapbox.mapboxsdk.style.expressions.Expression.*\nimport com.mapbox.mapboxsdk.style.layers.LineLayer\nimport com.mapbox.mapboxsdk.style.layers.Property\nimport com.mapbox.mapboxsdk.style.layers.PropertyFactory.*\nimport com.mapbox.mapboxsdk.style.layers.SymbolLayer\nimport com.mapbox.mapboxsdk.style.sources.GeoJsonSource\nimport timber.log.Timber\n\n\n@SuppressLint(\"MissingPermission\")\n@Suppress(\"Deprecation\")\n@Composable\nfun MappingMapsScreen(\n    modifier: Modifier,\n    state: MappingState,\n    uiState: MappingUiState,\n    mapboxMap: MapboxMap?,\n    hasTransaction: Boolean,\n    isNavigating: Boolean,\n    routeDirection: RouteDirection?,\n    isRescueCancelled: Boolean,\n    event: (MappingUiEvent) -> Unit\n//    requestNavigationCameraToOverview: () -> Unit, //todo use this one\n) {\n\n\n    val context = LocalContext.current\n\n\n    val nearbyCyclists = remember(state.nearbyCyclists?.users?.size, mapboxMap) {\n        state.nearbyCyclists?.users\n    }\n    val dismissNearbyCyclistsIcon = remember(mapboxMap) {\n        {\n            mapboxMap?.removeAnnotations()\n        }\n    }\n\n    val showNearbyCyclistsIcon = remember(nearbyCyclists, mapboxMap) {\n        {\n            dismissNearbyCyclistsIcon()\n\n            nearbyCyclists?.filter{\n                it.id != state.user.id\n            }?.filter {\n                it.isUserNeedHelp() == true\n            }?.forEach { cyclist ->\n                val location = cyclist.location\n                val latitude = location?.latitude ?: return@forEach\n                val longitude = location.longitude ?: return@forEach\n                val description = cyclist.getDescription()\n                val iconImage = description?.getMapIconImageDescription(context)\n                    ?.toBitmap(width = 120, height = 120)\n                iconImage?.let { bitmap ->\n                    mapboxMap ?: return@let\n                    val icon = IconFactory.getInstance(context).fromBitmap(bitmap)\n                    MarkerOptions().apply {\n                        setIcon(icon)\n                        position(LatLng(latitude, longitude))\n                        title = cyclist.id\n                    }.also(mapboxMap::addMarker)\n                }\n            }\n        }\n    }\n\n\n    val hasActiveTransaction = remember(hasTransaction, isRescueCancelled) {\n        hasTransaction || isRescueCancelled\n    }\n\n    val isUserNavigating = remember(key1 = isNavigating, key2 = routeDirection?.geometry) {\n        val geometry = routeDirection?.geometry\n        isNavigating || geometry?.isNotEmpty() == true\n    }\n\n    val shouldDismissNearbyIcons = remember(nearbyCyclists, isUserNavigating, hasActiveTransaction) {\n        isUserNavigating || hasActiveTransaction\n    }\n    LaunchedEffect(key1 = shouldDismissNearbyIcons, key2 = mapboxMap, key3= nearbyCyclists) {\n\n        if (shouldDismissNearbyIcons) {\n            dismissNearbyCyclistsIcon()\n            return@LaunchedEffect\n        }\n\n        showNearbyCyclistsIcon()\n    }\n\n\n    LaunchedEffect(key1 = mapboxMap, uiState.isFabExpanded) {\n\n        mapboxMap?.setOnMarkerClickListener {\n            event(MappingUiEvent.RescueeMapIconSelected(it.title))\n            true\n        }\n\n        mapboxMap?.addOnMapClickListener {\n            event(MappingUiEvent.OnMapClick)\n            true\n        }\n\n        mapboxMap?.addOnCameraMoveListener {\n            if (uiState.isFabExpanded) {\n                event(MappingUiEvent.OnCollapseExpandableFAB)\n            }\n        }\n\n        mapboxMap?.addOnMapLongClickListener {\n            event(MappingUiEvent.OnMapLongClick)\n            true\n        }\n\n    }\n\n\n    val clientLocation =\n        remember(state.transactionLocation, state.rescuer?.location, state.rescuee?.location) {\n            with(state) {\n                transactionLocation ?: rescuer?.location ?: rescuee?.location\n            }\n        }\n\n    val hasTransactionLocationChanges = remember(clientLocation) {\n        clientLocation != null\n    }\n\n    val dismissTransactionLocationIcon = remember(mapboxMap) {\n        {\n            mapboxMap?.getStyle { style ->\n                if (style.isFullyLoaded) {\n                    style.removeImage(TRANSACTION_ICON_ID)\n                    val geoJsonSource = style.getSourceAs<GeoJsonSource>(ICON_SOURCE_ID)\n                    geoJsonSource?.setGeoJson(FeatureCollection.fromFeatures(arrayOf()))\n                }\n            }\n        }\n    }\n\n    val showTransactionLocationIcon = remember(mapboxMap, state.user) {\n        { location: LocationModel ->\n            dismissTransactionLocationIcon()\n            val role = state.user.transaction?.role\n            val mapIcon = if (role == Role.RESCUEE.name.lowercase()) {\n                R.drawable.ic_map_rescuer\n            } else {\n                R.drawable.ic_map_rescuee\n            }\n            mapboxMap?.getStyle { style ->\n                if (style.isFullyLoaded) {\n                    val longitude = location.longitude ?: return@getStyle\n                    val latitude = location.latitude ?: return@getStyle\n                    style.removeImage(TRANSACTION_ICON_ID)\n                    ContextCompat.getDrawable(context, mapIcon)?.toBitmap(width = 100, height = 100)\n                        ?.let { iconBitmap ->\n                            style.addImage(TRANSACTION_ICON_ID, iconBitmap)\n                            val geoJsonSource = style.getSourceAs<GeoJsonSource>(ICON_SOURCE_ID)\n                            val feature =\n                                Feature.fromGeometry(Point.fromLngLat(longitude, latitude))\n                            geoJsonSource?.setGeoJson(feature)\n                        }\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(\n        key1 = hasActiveTransaction,\n        key2 = hasTransactionLocationChanges,\n        key3 = clientLocation) {\n\n        if (hasTransactionLocationChanges.not() || hasActiveTransaction.not()) {\n            dismissTransactionLocationIcon()\n            return@LaunchedEffect\n        }\n\n        clientLocation?.latitude ?: return@LaunchedEffect\n        showTransactionLocationIcon(clientLocation)\n    }\n\n    Map(\n        modifier = modifier,\n        event = event)\n\n}\n\n\n@Composable\nprivate fun Map(\n    modifier: Modifier,\n    event: (MappingUiEvent) -> Unit) {\n\n\n    val isDarkTheme = IsDarkTheme.current\n    Box(modifier = modifier) {\n\n        AndroidViewBinding(\n            factory = ActivityMappingBinding::inflate,\n            modifier = Modifier.fillMaxSize()) {\n            val viewContext = this.root.context\n            var mapboxMap: MapboxMap? = null\n\n            val initSource = { loadedMapStyle: Style ->\n                loadedMapStyle.addSource(GeoJsonSource(ICON_SOURCE_ID))\n                loadedMapStyle.addSource(GeoJsonSource(ROUTE_SOURCE_ID))\n            }\n\n            val initLayers = { loadedMapStyle: Style ->\n\n\n                val drawableIcon = ContextCompat.getDrawable(viewContext, R.drawable.ic_map_rescuer)\n                val bitmapIcon = drawableIcon?.toBitmap(width = 100, height = 100)\n                bitmapIcon?.let { loadedMapStyle.addImage(TRANSACTION_ICON_ID, it) }\n\n                loadedMapStyle.addLayer(\n                    SymbolLayer(ICON_LAYER_ID, ICON_SOURCE_ID).apply {\n                        setProperties(\n                            iconImage(TRANSACTION_ICON_ID),\n                            iconAllowOverlap(true),\n                            iconIgnorePlacement(true)\n                        )\n                    }\n                )\n\n\n                loadedMapStyle.addLayerBelow(\n                    LineLayer(ROUTE_LAYER_ID, ROUTE_SOURCE_ID).apply {\n                        setProperties(\n                            lineCap(Property.LINE_CAP_ROUND),\n                            lineJoin(Property.LINE_JOIN_ROUND),\n                            lineWidth(5f),\n                            lineColor(Color.parseColor(\"#006eff\"))\n                        )\n                    }, ICON_LAYER_ID)\n\n\n            }\n\n\n            root.findViewTreeLifecycleOwner()?.lifecycle?.addObserver(\n                LifecycleEventObserver { _, event ->\n                    when (event) {\n                        Lifecycle.Event.ON_CREATE -> {\n\n                            Timber.v(\"Lifecycle Event: ON_CREATE\")\n                            mapView.getMapAsync {\n\n\n                                it.setStyle(if (isDarkTheme) Style.DARK else Style.LIGHT) { loadedStyle ->\n\n                                    if (loadedStyle.isFullyLoaded) {\n                                        event(MappingUiEvent.OnInitializeMap(it))\n                                        mapboxMap = it\n                                        initSource(loadedStyle)\n                                        initLayers(loadedStyle)\n                                    }\n                                }\n                                it.setDefaultSettings()\n                            }\n                        }\n\n                        Lifecycle.Event.ON_START -> {\n                            Timber.v(\"Lifecycle Event: ON_START\")\n                            mapView.onStart()\n                        }\n\n                        Lifecycle.Event.ON_RESUME -> {\n                            Timber.v(\"Lifecycle Event: ON_RESUME\")\n                        }\n\n                        Lifecycle.Event.ON_PAUSE -> {\n                            val camera = mapboxMap?.cameraPosition\n                            val cameraCenter = camera?.target\n                            val cameraZoom = camera?.zoom\n                            cameraCenter?.let {\n                                cameraZoom?.let {\n                                    val cameraMoved =\n                                        cameraCenter.latitude != 0.0 && cameraCenter.longitude != 0.0 && cameraZoom != 3.0\n\n                                    if (!cameraMoved) {\n                                        return@let\n                                    }\n\n\n                                    /*  event(\n                                          MappingUiEvent.OnChangeCameraState(\n                                              cameraState = CameraState(\n                                                  position = cameraCenter,\n                                                  zoom = cameraZoom)))*/\n                                }\n                            }\n                        }\n\n                        Lifecycle.Event.ON_STOP -> {\n                            Timber.v(\"Lifecycle Event: ON_STOP\")\n\n                            mapView.onStop()\n                        }\n\n                        Lifecycle.Event.ON_DESTROY -> {\n\n                            mapView.onDestroy()\n                        }\n\n                        else -> {}\n\n                    }\n                }\n            )\n        }\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt	(revision cea8388e8c150db9962f0c7e4615c7b6f9c7d83e)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt	(date 1692092934637)
@@ -22,6 +22,7 @@
 import com.example.cyclistance.feature_mapping.domain.model.Role
 import com.example.cyclistance.feature_mapping.domain.model.api.rescue_transaction.RouteDirection
 import com.example.cyclistance.feature_mapping.domain.model.api.user.LocationModel
+import com.example.cyclistance.feature_mapping.domain.model.api.user.UserItem
 import com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent
 import com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState
 import com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState
@@ -57,6 +58,7 @@
     isNavigating: Boolean,
     routeDirection: RouteDirection?,
     isRescueCancelled: Boolean,
+    nearbyCyclist: List<UserItem>,
     event: (MappingUiEvent) -> Unit
 //    requestNavigationCameraToOverview: () -> Unit, //todo use this one
 ) {
@@ -65,24 +67,23 @@
     val context = LocalContext.current
 
 
-    val nearbyCyclists = remember(state.nearbyCyclists?.users?.size, mapboxMap) {
-        state.nearbyCyclists?.users
-    }
+
     val dismissNearbyCyclistsIcon = remember(mapboxMap) {
         {
             mapboxMap?.removeAnnotations()
         }
     }
 
-    val showNearbyCyclistsIcon = remember(nearbyCyclists, mapboxMap) {
+    val showNearbyCyclistsIcon = remember(nearbyCyclist.size, mapboxMap) {
         {
             dismissNearbyCyclistsIcon()
 
-            nearbyCyclists?.filter{
+            nearbyCyclist.filter{
                 it.id != state.user.id
-            }?.filter {
+            }.filter {
                 it.isUserNeedHelp() == true
-            }?.forEach { cyclist ->
+            }.forEach { cyclist ->
+                Timber.v("Cyclist Name: ${cyclist.name}")
                 val location = cyclist.location
                 val latitude = location?.latitude ?: return@forEach
                 val longitude = location.longitude ?: return@forEach
@@ -112,10 +113,10 @@
         isNavigating || geometry?.isNotEmpty() == true
     }
 
-    val shouldDismissNearbyIcons = remember(nearbyCyclists, isUserNavigating, hasActiveTransaction) {
+    val shouldDismissNearbyIcons = remember(nearbyCyclist, isUserNavigating, hasActiveTransaction) {
         isUserNavigating || hasActiveTransaction
     }
-    LaunchedEffect(key1 = shouldDismissNearbyIcons, key2 = mapboxMap, key3= nearbyCyclists) {
+    LaunchedEffect(key1 = shouldDismissNearbyIcons, key2 = mapboxMap, key3= nearbyCyclist.size) {
 
         if (shouldDismissNearbyIcons) {
             dismissNearbyCyclistsIcon()
