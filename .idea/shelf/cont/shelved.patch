Index: app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/manage_user/UpdateUserAvailability.kt
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/manage_user/UpdateUserAvailability.kt b/app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/manage_user/UpdateUserAvailability.kt
deleted file mode 100644
--- a/app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/manage_user/UpdateUserAvailability.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ /dev/null	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
@@ -1,9 +0,0 @@
-package com.example.cyclistance.feature_messaging.domain.use_case.manage_user
-
-import com.example.cyclistance.feature_messaging.domain.repository.MessagingRepository
-
-class UpdateUserAvailability(private val repository: MessagingRepository) {
-    operator fun invoke(isUserAvailable: Boolean){
-        repository.updateUserAvailability(isUserAvailable)
-    }
-}
\ No newline at end of file
Index: app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_up/SignUpViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_authentication.presentation.auth_sign_up\n\nimport androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.cyclistance.core.domain.model.UserDetails\nimport com.example.cyclistance.core.utils.constants.AuthConstants.SIGN_UP_VM_STATE_KEY\nimport com.example.cyclistance.feature_authentication.domain.exceptions.AuthExceptions\nimport com.example.cyclistance.feature_authentication.domain.model.AuthModel\nimport com.example.cyclistance.feature_authentication.domain.use_case.AuthenticationUseCase\nimport com.example.cyclistance.feature_authentication.presentation.auth_sign_up.event.SignUpEvent\nimport com.example.cyclistance.feature_authentication.presentation.auth_sign_up.event.SignUpVmEvent\nimport com.example.cyclistance.feature_authentication.presentation.auth_sign_up.state.SignUpState\nimport com.example.cyclistance.feature_messaging.domain.use_case.MessagingUseCase\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\nimport javax.inject.Inject\n\n@HiltViewModel\nclass SignUpViewModel @Inject constructor(\n    private val savedStateHandle: SavedStateHandle,\n    private val authUseCase: AuthenticationUseCase,\n    private val messagingUseCase: MessagingUseCase,\n    private val defaultDispatcher: CoroutineDispatcher\n    ) : ViewModel() {\n\n    private val _state: MutableStateFlow<SignUpState> = MutableStateFlow(savedStateHandle[SIGN_UP_VM_STATE_KEY] ?: SignUpState())\n    val state = _state.asStateFlow()\n\n    private val _eventFlow: MutableSharedFlow<SignUpEvent> = MutableSharedFlow()\n    val eventFlow: SharedFlow<SignUpEvent> = _eventFlow.asSharedFlow()\n\n    init {\n        _state.update {\n            it.copy(\n                hasAccountSignedIn = authUseCase.hasAccountSignedInUseCase(),\n                savedAccountEmail = authUseCase.getEmailUseCase() ?: \"\",\n            )\n        }\n        savedStateHandle[SIGN_UP_VM_STATE_KEY] = state.value\n\n    }\n\n    fun onEvent(event: SignUpVmEvent) {\n        when (event) {\n\n            is SignUpVmEvent.SignUp -> {\n                signUp(\n                    email = event.email,\n                    password = event.password,\n                    confirmPassword = event.confirmPassword\n                )\n            }\n\n            is SignUpVmEvent.SignOut -> {\n                authUseCase.signOutUseCase()\n            }\n\n            is SignUpVmEvent.AgreedToPrivacyPolicy -> {\n                _state.update { it.copy(userAgreedToPrivacyPolicy = true) }\n            }\n        }\n        savedStateHandle[SIGN_UP_VM_STATE_KEY] = state.value\n    }\n\n\n    private fun signUp(\n         email: String,\n         password: String,\n         confirmPassword: String) {\n\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                _state.update { it.copy(isLoading = true) }\n                with(state.value) {\n                    authUseCase.createWithEmailAndPasswordUseCase(\n                        authModel = AuthModel(\n                            email = email.trim(),\n                            password = password.trim(),\n                            confirmPassword = confirmPassword.trim()\n                        ))\n                }\n            }.onSuccess { accountCreation ->\n                _state.update { it.copy(isLoading = false) }\n                if (accountCreation?.isSuccessful == true) {\n                    createUser(user = accountCreation.user)\n                    _eventFlow.emit(SignUpEvent.SignUpSuccess)\n                } else {\n                    _eventFlow.emit(SignUpEvent.CreateAccountFailed())\n                }\n            }.onFailure { exception ->\n                _state.update { it.copy(isLoading = false) }\n                handleException(exception)\n            }\n        }.invokeOnCompletion {\n            savedStateHandle[SIGN_UP_VM_STATE_KEY] = state.value\n        }\n    }\n\n    private fun createUser(user: UserDetails) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                _state.update { it.copy(isLoading = true) }\n                authUseCase.createUserUseCase(user)\n            }.onSuccess {\n                _state.update { it.copy(isLoading = false) }\n                messagingUseCase.updateUserAvailability(true)\n            }.onFailure { exception ->\n                _state.update { it.copy(isLoading = false) }\n                handleException(exception)\n            }\n        }.apply {\n            invokeOnCompletion {\n                savedStateHandle[SIGN_UP_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n\n    private suspend fun handleException(exception: Throwable) {\n        when (exception) {\n            is AuthExceptions.EmailException -> {\n                _eventFlow.emit(\n                    value = SignUpEvent.InvalidEmail(\n                        reason = exception.message ?: \"Invalid email. Please try again.\"))\n            }\n\n            is AuthExceptions.NewPasswordException -> {\n                _eventFlow.emit(\n                    value = SignUpEvent.InvalidPassword(\n                        reason = exception.message ?: \"Invalid password. Please try again.\"))\n            }\n            is AuthExceptions.ConfirmPasswordException -> {\n                _eventFlow.emit(value = SignUpEvent.InvalidConfirmPassword(reason = exception.message ?: \"Passwords do not match. Please try again.\"))\n            }\n            is AuthExceptions.NetworkException -> {\n                _eventFlow.emit(value = SignUpEvent.NoInternetConnection)\n            }\n            is AuthExceptions.UserAlreadyExistsException -> {\n                _eventFlow.emit(value = SignUpEvent.AccountAlreadyTaken)\n            }\n            else -> {\n                Timber.e(\"${this@SignUpViewModel.javaClass.name}: ${exception.message}\")\n            }\n        }\n        savedStateHandle[SIGN_UP_VM_STATE_KEY] = state.value\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_up/SignUpViewModel.kt b/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_up/SignUpViewModel.kt
--- a/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_up/SignUpViewModel.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_up/SignUpViewModel.kt	(date 1696832047986)
@@ -112,7 +112,6 @@
                 authUseCase.createUserUseCase(user)
             }.onSuccess {
                 _state.update { it.copy(isLoading = false) }
-                messagingUseCase.updateUserAvailability(true)
             }.onFailure { exception ->
                 _state.update { it.copy(isLoading = false) }
                 handleException(exception)
Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen\n\nimport androidx.compose.runtime.mutableStateListOf\nimport androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.cyclistance.core.utils.constants.MappingConstants.DEFAULT_RADIUS\nimport com.example.cyclistance.core.utils.constants.MappingConstants.MAPPING_VM_STATE_KEY\nimport com.example.cyclistance.core.utils.constants.MappingConstants.NEAREST_METERS\nimport com.example.cyclistance.core.utils.formatter.FormatterUtils\nimport com.example.cyclistance.core.utils.formatter.FormatterUtils.formatToDistanceKm\nimport com.example.cyclistance.core.utils.formatter.FormatterUtils.isLocationAvailable\nimport com.example.cyclistance.feature_authentication.domain.use_case.AuthenticationUseCase\nimport com.example.cyclistance.feature_mapping.data.mapper.UserMapper.toRescueRequest\nimport com.example.cyclistance.feature_mapping.domain.exceptions.MappingExceptions\nimport com.example.cyclistance.feature_mapping.domain.helper.TrackingStateHandler\nimport com.example.cyclistance.feature_mapping.domain.model.Role\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.hazardous_lane.HazardousLaneMarker\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.live_location.LiveLocationSocketModel\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.rescue.RescueRequestItemModel\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.rescue_transaction.RescueTransaction\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.rescue_transaction.RescueTransactionItem\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.user.LocationModel\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.user.NearbyCyclist\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.user.RescuePending\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.user.RescueRequest\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.user.UserAssistanceModel\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.user.UserItem\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.MapSelectedRescuee\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.NewRescueRequestsModel\nimport com.example.cyclistance.feature_mapping.domain.use_case.MappingUseCase\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingVmEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.createMockUsers\nimport com.example.cyclistance.feature_messaging.domain.use_case.MessagingUseCase\nimport com.example.cyclistance.feature_rescue_record.domain.use_case.RescueRecordUseCase\nimport com.example.cyclistance.feature_user_profile.domain.use_case.UserProfileUseCase\nimport com.google.maps.android.SphericalUtil\nimport com.mapbox.geojson.Point\nimport com.mapbox.mapboxsdk.geometry.LatLng\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.distinctUntilChanged\nimport kotlinx.coroutines.flow.launchIn\nimport kotlinx.coroutines.flow.onEach\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\nimport javax.inject.Inject\nimport com.google.android.gms.maps.model.LatLng as GoogleLatLng\n\n\n@HiltViewModel\nclass MappingViewModel @Inject constructor(\n    private val savedStateHandle: SavedStateHandle,\n    private val authUseCase: AuthenticationUseCase,\n    private val mappingUseCase: MappingUseCase,\n    private val userProfileUseCase: UserProfileUseCase,\n    private val defaultDispatcher: CoroutineDispatcher,\n    private val messagingUseCase: MessagingUseCase,\n    private val rescueRecordUseCase: RescueRecordUseCase\n) : ViewModel() {\n\n\n    private var loadDataJob: Job? = null\n    private var getUsersUpdatesJob: Job? = null\n    private var locationUpdatesJob: Job? = null\n    private var getRescueTransactionUpdatesJob: Job? = null\n    private var getTransactionLocationUpdatesJob: Job? = null\n    private var trackingHandler: TrackingStateHandler\n\n    private val _state: MutableStateFlow<MappingState> = MutableStateFlow(\n        savedStateHandle[MAPPING_VM_STATE_KEY] ?: MappingState(userId = getId())\n    )\n    val state = _state.asStateFlow()\n\n    private val _eventFlow: MutableSharedFlow<MappingEvent> = MutableSharedFlow()\n    val eventFlow: SharedFlow<MappingEvent> = _eventFlow.asSharedFlow()\n    private var travelledPath: MutableList<GoogleLatLng> = mutableStateListOf()\n\n    private val _hazardousLaneMarkers = mutableStateListOf<HazardousLaneMarker>()\n    val hazardousLaneMarkers: List<HazardousLaneMarker> = _hazardousLaneMarkers\n\n    init {\n        trackingHandler = TrackingStateHandler(state = _state, eventFlow = _eventFlow)\n        loadData()\n        observeDataChanges()\n        getMapType()\n        getShouldShowHazardousStartingInfo()\n        refreshToken()\n    }\n\n    private fun setShouldShowHazardousStartingInfo(shouldShow: Boolean) {\n        viewModelScope.launch {\n            mappingUseCase.shouldHazardousStartingInfoUseCase(shouldShow = shouldShow)\n        }\n    }\n\n    private fun getShouldShowHazardousStartingInfo() {\n        viewModelScope.launch {\n            mappingUseCase.shouldHazardousStartingInfoUseCase().catch {\n                it.handleException()\n            }.onEach { shouldShow ->\n                _state.update { it.copy(shouldShowHazardousStartingInfo = shouldShow) }\n            }.launchIn(this)\n        }\n    }\n\n\n    private fun observeDataChanges() {\n        subscribeToLocationUpdates()\n        subscribeToNearbyUsersChanges()\n        subscribeToRescueTransactionUpdates()\n        subscribeToTransactionLocationUpdates()\n        subscribeToBottomSheetTypeUpdates()\n        subscribeToHazardousLaneUpdates()\n    }\n\n    private fun getMapType() {\n        viewModelScope.launch {\n            mappingUseCase.mapTypeUseCase()\n                .distinctUntilChanged()\n                .catch {\n                    Timber.v(\"Error getting map type: ${it.message}\")\n                }.onEach { mapType ->\n                    _state.update { it.copy(mapType = mapType) }\n                }.launchIn(viewModelScope)\n\n        }\n    }\n\n    private fun subscribeToHazardousLaneUpdates() {\n        viewModelScope.launch(SupervisorJob() + defaultDispatcher) {\n\n            mappingUseCase.newHazardousLaneUseCase(\n                onAddedHazardousMarker = { marker ->\n\n                    _hazardousLaneMarkers.removeAll { modifiedMarker ->\n                        marker.id == modifiedMarker.id\n                    }\n                    _hazardousLaneMarkers.add(marker)\n                },\n                onModifiedHazardousMarker = { modifiedMarker ->\n                    _hazardousLaneMarkers.removeAll { marker ->\n                        marker.id == modifiedMarker.id\n                    }\n                    _hazardousLaneMarkers.add(modifiedMarker)\n                },\n                onRemovedHazardousMarker = { markerId ->\n                    _hazardousLaneMarkers.removeAll { marker ->\n                        marker.id == markerId\n                    }\n                }\n            )\n\n        }\n    }\n\n    private fun subscribeToBottomSheetTypeUpdates() {\n        viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n            mappingUseCase.bottomSheetTypeUseCase().catch {\n                it.handleException()\n            }.onEach {\n                if(it.isEmpty()){\n                    return@onEach\n                }\n                _eventFlow.emit(value = MappingEvent.NewBottomSheetType(it))\n            }.launchIn(this)\n        }\n    }\n\n    private fun loadData() {\n        if (loadDataJob?.isActive == true) return\n        loadDataJob = viewModelScope.launch(SupervisorJob() + defaultDispatcher) {\n            // TODO: Remove when the backend is ready\n            createMockUpUsers()\n            getNearbyCyclist()\n            trackingHandler.updateClient()\n        }\n\n    }\n\n\n    private suspend fun loadRescueTransaction(transactionId: String) {\n        coroutineScope {\n            if (transactionId.isEmpty()) {\n                return@coroutineScope\n            }\n\n            mappingUseCase.getRescueTransactionByIdUseCase(transactionId).catch {\n                it.handleException()\n            }.onEach { rescueTransaction ->\n                _state.update { it.copy(rescueTransaction = rescueTransaction) }\n            }.launchIn(this).invokeOnCompletion {\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n    private suspend fun getNearbyCyclist() {\n        val userLocation = state.value.getCurrentLocation()\n        Timber.v(\"Getting nearby cyclist $userLocation\")\n\n        val dataLoaded = state.value.user.id != null\n        userLocation?.latitude ?: return\n        userLocation.longitude ?: return\n\n        if (dataLoaded) {\n            return\n        }\n\n        coroutineScope {\n\n\n            mappingUseCase.getUsersUseCase(\n                latitude = userLocation.latitude,\n                longitude = userLocation.longitude\n            ).distinctUntilChanged().catch {\n                it.handleException()\n            }.onEach {\n                it.filterUser()\n                it.updateNearbyCyclists()\n                Timber.v(\"Receiving from getNearbyCyclist\")\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }.launchIn(this)\n\n        }\n\n    }\n\n\n    private fun acceptRescueRequest(id: String) {\n        viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n\n            val rescuer = state.value.nearbyCyclist?.findUser(id) ?: return@launch\n            _state.update { it.copy(rescueRequestAcceptedUser = rescuer) }\n            val transactionId = trackingHandler.getTransactionId(rescuer)\n            val user = state.value.user\n\n            trackingHandler.checkCurrentTransactions(user = user, rescuer = rescuer) {\n\n                coroutineScope {\n                    runCatching {\n                        isLoading(true)\n                        trackingHandler.getAcceptedRescueRequestItem(\n                            transactionId = transactionId,\n                            rescuer = rescuer\n                        ).apply {\n                            mappingUseCase.acceptRescueRequestUseCase(rescueTransaction = this)\n                        }\n\n                    }.onSuccess { rescueTransaction ->\n                        broadcastRescueTransaction()\n                        assignRequestTransaction(\n                            rescueTransaction = rescueTransaction,\n                            user = user,\n                            rescuer = rescuer,\n                            transactionId = transactionId\n                        )\n                        user.location?.let { broadcastRescueTransactionToRespondent(it) }\n                    }.onFailure { exception ->\n                        isLoading(false)\n                        exception.handleException()\n                    }\n                }\n\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n\n            }\n        }\n    }\n\n    private fun cancelHelpRequest() {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                isLoading(true)\n                cancelUserHelpRequest()\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.CancelHelpRequestSuccess)\n                broadcastToNearbyCyclists()\n                _state.update { it.copy(rescueRequestAcceptedUser = null) }\n            }.onFailure { exception ->\n                Timber.e(\"Failed to cancel search assistance: ${exception.message}\")\n                exception.handleException()\n            }\n            isLoading(false)\n            savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n        }\n    }\n\n\n    private fun removeAssignedTransaction() {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                removeUserTransaction(id = getId())\n            }.onSuccess {\n                broadcastToNearbyCyclists()\n                broadcastRescueTransaction()\n                isLoading(false)\n                _eventFlow.emit(value = MappingEvent.RemoveAssignedTransactionSuccess)\n                trackingHandler.clearTransactionRoles()\n            }.onFailure { exception ->\n                isLoading(false)\n                exception.handleException()\n            }\n        }\n\n    }\n\n    private fun selectRescueeMapIcon(id: String) {\n        viewModelScope.launch(context = defaultDispatcher) {\n\n            val userLocation = state.value.user.location ?: state.value.userLocation\n\n            if (!userLocation.isLocationAvailable()) {\n                viewModelScope.launch(context = defaultDispatcher) {\n                    _eventFlow.emit(value = MappingEvent.LocationNotAvailable(\"Tracking your Location\"))\n                }\n                return@launch\n            }\n\n            calculateSelectedRescueeDistance(userLocation, id)\n\n        }\n    }\n\n    private fun respondToHelp(selectedRescuee: MapSelectedRescuee) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                uploadUserProfile(onSuccess = {\n                    viewModelScope.launch(context = defaultDispatcher) {\n                        mappingUseCase.addRescueRespondentUseCase(\n                            userId = selectedRescuee.userId,\n                            respondentId = getId()\n                        )\n                    }\n                })\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.RespondToHelpSuccess())\n                broadcastToNearbyCyclists()\n                broadcastRescueTransaction()\n                _state.update { it.copy(respondedToHelp = true) }\n            }.onFailure {\n                it.handleException()\n            }\n\n        }\n    }\n\n    private fun showRouteDirection(origin: Point, destination: Point) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                mappingUseCase.getRouteDirectionsUseCase(origin = origin, destination = destination)\n            }.onSuccess { routeDirection ->\n                _eventFlow.emit(value = MappingEvent.GenerateRouteNavigationSuccess(routeDirection))\n            }.onFailure {\n                it.handleException()\n            }\n        }\n    }\n\n\n    private suspend fun broadcastRescueTransaction() {\n        runCatching {\n            mappingUseCase.broadcastRescueTransactionUseCase()\n        }.onFailure {\n            it.handleException()\n        }\n    }\n\n    private suspend fun broadcastToNearbyCyclists() {\n        val location = state.value.userLocation ?: return\n        runCatching {\n            mappingUseCase.nearbyCyclistsUseCase(\n                locationModel = LiveLocationSocketModel(\n                    latitude = location.latitude,\n                    longitude = location.longitude\n                )\n            )\n        }.onFailure {\n            it.handleException()\n        }\n    }\n\n    private fun refreshToken() {\n        viewModelScope.launch(SupervisorJob()) {\n            runCatching {\n                isLoading(true)\n                messagingUseCase.refreshTokenUseCase()\n            }.onSuccess {\n                Timber.v(\"Successfully refreshed token\")\n            }.onFailure {\n                Timber.e(\"Failed to refresh token ${it.message}\")\n            }.also {\n                isLoading(false)\n            }\n        }\n    }\n\n    private fun declineRescueRequest(id: String) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                isLoading(true)\n                mappingUseCase.deleteRescueRespondentUseCase(userId = getId(), respondentId = id)\n            }.onSuccess {\n                removeRescueRespondent(id)\n                broadcastToNearbyCyclists()\n            }.onFailure {\n                it.handleDeclineRescueRequest()\n            }\n            isLoading(false)\n            savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n\n        }\n    }\n\n    private suspend fun removeRescueRespondent(id: String) {\n        state.value.newRescueRequest?.request?.toMutableList()?.apply {\n            val respondentRemoved = removeAll { it.id == id }\n            if (!respondentRemoved) {\n                _eventFlow.emit(value = MappingEvent.RemoveRespondentFailed())\n                return@apply\n            }\n            _state.update {\n                it.copy(\n                    newRescueRequest = NewRescueRequestsModel(this)\n                )\n            }\n        }\n    }\n\n\n    private fun requestHelp() {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                uploadUserProfile(onSuccess = {\n                    viewModelScope.launch(context = defaultDispatcher) {\n                        _eventFlow.emit(MappingEvent.RequestHelpSuccess)\n                    }\n                })\n            }.onFailure {\n                it.handleException()\n            }\n        }.invokeOnCompletion {\n            savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n        }\n    }\n\n    fun onEvent(event: MappingVmEvent) {\n        when (event) {\n\n            is MappingVmEvent.SubscribeToDataChanges -> {\n                observeDataChanges()\n            }\n\n\n            is MappingVmEvent.GetRouteDirections -> {\n                showRouteDirection(origin = event.origin, destination = event.destination)\n            }\n\n            is MappingVmEvent.RespondToHelp -> {\n                respondToHelp(event.selectedRescuee)\n            }\n\n            is MappingVmEvent.SelectRescueMapIcon -> {\n                selectRescueeMapIcon(event.id)\n            }\n\n            is MappingVmEvent.RequestHelp -> {\n                requestHelp()\n            }\n\n            is MappingVmEvent.CancelRescueTransaction -> {\n                removeAssignedTransaction()\n                clearTravelledPath()\n            }\n\n\n            is MappingVmEvent.LoadData -> {\n                loadData()\n            }\n\n\n            is MappingVmEvent.DeclineRescueRequest -> {\n                declineRescueRequest(event.id)\n                clearTravelledPath()\n            }\n\n            is MappingVmEvent.AcceptRescueRequest -> {\n                acceptRescueRequest(event.id)\n            }\n\n            is MappingVmEvent.CancelSearchingAssistance -> {\n                cancelHelpRequest()\n                clearTravelledPath()\n            }\n\n            is MappingVmEvent.ReportIncident -> {\n                calculateIncidentDistance(\n                    latLng = event.latLng,\n                    label = event.label,\n                    incidentDescription = event.description)\n            }\n\n            is MappingVmEvent.SetMapType -> {\n                setMapType(mapType = event.mapType)\n            }\n\n            is MappingVmEvent.SelectHazardousLaneMarker -> {\n                selectHazardousLaneMarker(id = event.id)\n            }\n\n            is MappingVmEvent.DeleteHazardousLaneMarker -> {\n                deleteHazardousLaneMarker(id = event.id)\n            }\n\n            is MappingVmEvent.UpdateReportedIncident -> {\n                updateReportedIncident(marker = event.marker)\n            }\n\n            is MappingVmEvent.ShouldShowHazardousStartingInfo ->\n                setShouldShowHazardousStartingInfo(event.shouldShow)\n\n            is MappingVmEvent.NotifyUser -> {\n                mappingUseCase.showNotificationUseCase(\n                    title = event.title,\n                    message = event.message\n                )\n            }\n\n            is MappingVmEvent.CancelRespondHelp -> cancelRespondToHelp(respondentId = event.id)\n            MappingVmEvent.RescuerArrived -> rescuerArrived()\n        }\n        savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n    }\n\n\n    private fun rescuerArrived(){\n        viewModelScope.launch {\n            rescueRecordUseCase.rescueDetailsUseCase(details = trackingHandler.getRideDetails())\n        }\n    }\n\n    private fun cancelRespondToHelp(respondentId: String){\n        viewModelScope.launch {\n            runCatching {\n                isLoading(true)\n                mappingUseCase.cancelHelpRespondUseCase(userId = getId(), respondentId = respondentId)\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.CancelRespondSuccess)\n                broadcastToNearbyCyclists()\n            }.onFailure {\n                it.handleException()\n            }.also {\n                isLoading(false)\n            }\n        }\n    }\n\n\n    private fun updateReportedIncident(marker: HazardousLaneMarker) {\n        viewModelScope.launch {\n            runCatching {\n                mappingUseCase.updateHazardousLaneUseCase(\n                    hazardousLaneMarker = marker\n                )\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.UpdateIncidentSuccess)\n            }.onFailure {\n                _eventFlow.emit(\n                    value = MappingEvent.UpdateIncidentFailed(\n                        it.message ?: \"Failed to update incident\"))\n            }\n        }\n    }\n\n\n    private fun deleteHazardousLaneMarker(id: String) {\n        viewModelScope.launch {\n            runCatching {\n                mappingUseCase.deleteHazardousLaneUseCase(id)\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.DeleteHazardousLaneMarkerSuccess)\n            }.onFailure {\n                _eventFlow.emit(\n                    value = MappingEvent.DeleteHazardousLaneMarkerFailed(\n                        it.message ?: \"Failed to delete incident marker\"))\n            }\n        }\n    }\n\n    private fun selectHazardousLaneMarker(id: String) {\n        viewModelScope.launch {\n            hazardousLaneMarkers.find { it.id == id }?.let { marker ->\n                _eventFlow.emit(value = MappingEvent.SelectHazardousLaneMarker(marker))\n            }\n        }\n    }\n\n\n    private fun calculateIncidentDistance(\n        latLng: LatLng,\n        label: String,\n        incidentDescription: String) {\n\n        viewModelScope.launch {\n            val userLocation = state.value.getCurrentLocation()\n\n            if (userLocation == null) {\n                _eventFlow.emit(MappingEvent.LocationNotAvailable(reason = \"Searching for GPS\"))\n                return@launch\n            }\n\n            val distance = mappingUseCase.getCalculatedDistanceUseCase(\n                startingLocation = userLocation,\n                destinationLocation = LocationModel(\n                    latitude = latLng.latitude,\n                    longitude = latLng.longitude\n                )\n            )\n\n            if (distance > DEFAULT_RADIUS) {\n                _eventFlow.emit(MappingEvent.IncidentDistanceTooFar)\n                return@launch\n            }\n\n            reportIncident(\n                label = label,\n                latLng = latLng,\n                incidentDescription = incidentDescription)\n\n\n        }\n\n    }\n\n    private fun setMapType(mapType: String) {\n        viewModelScope.launch {\n            runCatching {\n                mappingUseCase.mapTypeUseCase(mapType = mapType)\n            }.onSuccess {\n                Timber.v(\"Success setting map type: $it\")\n            }.onFailure {\n                Timber.e(\"Error setting map type: ${it.message}\")\n            }\n        }\n    }\n\n    private suspend fun reportIncident(\n        label: String,\n        latLng: LatLng,\n        incidentDescription: String) {\n\n\n        coroutineScope {\n            runCatching {\n                mappingUseCase.newHazardousLaneUseCase(\n                    hazardousLaneMarker = HazardousLaneMarker(\n                        id = getId() + System.currentTimeMillis(),\n                        idCreator = getId(),\n                        latitude = latLng.latitude,\n                        longitude = latLng.longitude,\n                        label = label,\n                        description = incidentDescription,\n\n                        ))\n            }.onSuccess {\n                _eventFlow.emit(value = MappingEvent.ReportIncidentSuccess)\n            }.onFailure {\n                _eventFlow.emit(\n                    value = MappingEvent.ReportIncidentFailed(\n                        reason = it.message ?: \"Failed to report incident\"))\n            }\n        }\n    }\n\n    private suspend fun calculateSelectedRescueeDistance(userLocation: LocationModel?, id: String) {\n        val selectedRescuee = state.value.nearbyCyclist?.findUser(id) ?: return\n        val selectedRescueeLocation = selectedRescuee.location\n\n\n        runCatching {\n            isLoading(true)\n            mappingUseCase.getCalculatedDistanceUseCase(\n                startingLocation = LocationModel(\n                    latitude = userLocation?.latitude,\n                    longitude = userLocation?.longitude\n                ), destinationLocation = LocationModel(\n                    latitude = selectedRescueeLocation!!.latitude,\n                    longitude = selectedRescueeLocation.longitude\n                )\n            )\n        }.onSuccess { distance ->\n            val timeRemaining = FormatterUtils.getCalculatedETA(distance)\n            trackingHandler.showSelectedRescuee(\n                selectedRescuee = selectedRescuee,\n                distance = distance,\n                timeRemaining = timeRemaining)\n        }.onFailure {\n            _eventFlow.emit(value = MappingEvent.FailedToCalculateDistance)\n        }.also {\n            isLoading(false)\n        }\n    }\n\n\n    private suspend fun removeUserTransaction(id: String) {\n        mappingUseCase.createUserUseCase(\n            user = UserItem.removeUserTransaction(id)\n        )\n    }\n\n\n    private fun subscribeToTransactionLocationUpdates() {\n        if (getTransactionLocationUpdatesJob?.isActive == true) {\n            return\n        }\n        getTransactionLocationUpdatesJob =\n            viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n                mappingUseCase.transactionLocationUseCase().distinctUntilChanged().catch {\n                    Timber.e(\"ERROR GETTING TRANSACTION LOCATION: ${it.message}\")\n                }.onEach { liveLocation ->\n                    trackingHandler.updateTransactionLocation(location = liveLocation)\n                    liveLocation.updateTransactionETA()\n                    liveLocation.updateTransactionDistance()\n                }.launchIn(this@launch)\n\n            }\n    }\n\n    private suspend fun LiveLocationSocketModel.updateTransactionDistance() {\n        coroutineScope {\n            val rescueTransaction = state.value.userLocation\n            latitude ?: return@coroutineScope\n            longitude ?: return@coroutineScope\n\n            rescueTransaction?.let { transaction ->\n\n                val distance = mappingUseCase.getCalculatedDistanceUseCase(\n                    startingLocation = LocationModel(latitude, longitude),\n                    destinationLocation = LocationModel(transaction.latitude, transaction.longitude)\n                ).toInt()\n\n\n                if (distance <= NEAREST_METERS) {\n                    _eventFlow.emit(value = MappingEvent.DestinationReached)\n                    removeAssignedTransaction()\n                    clearTravelledPath()\n                }\n\n            }\n        }\n    }\n\n\n    private fun LiveLocationSocketModel.updateTransactionETA() {\n        val userLocation = state.value.userLocation\n        userLocation ?: return\n        this.latitude ?: return\n        this.longitude ?: return\n\n        val eta = getETABetweenTwoPoints(\n            startingLocation = LocationModel(\n                latitude = this.latitude,\n                longitude = this.longitude\n            ), endLocation = userLocation\n        )\n\n        val distance = mappingUseCase.getCalculatedDistanceUseCase(\n            startingLocation = LocationModel(\n                latitude = this.latitude,\n                longitude = this.longitude\n            ),\n            destinationLocation = userLocation)\n        _state.update { it.copy(rescueETA = eta, rescueDistance = distance.formatToDistanceKm()) }\n    }\n\n    private fun getETABetweenTwoPoints(\n        startingLocation: LocationModel,\n        endLocation: LocationModel\n    ): String {\n        val distance = mappingUseCase.getCalculatedDistanceUseCase(\n            startingLocation = startingLocation,\n            destinationLocation = endLocation\n        )\n\n        return FormatterUtils.getCalculatedETA(distanceMeters = distance)\n    }\n\n\n    private suspend fun assignRequestTransaction(\n        rescueTransaction: RescueTransactionItem,\n        user: UserItem,\n        rescuer: UserItem,\n        transactionId: String\n    ) {\n\n        runCatching {\n\n            transactionId.assignRequestTransaction(\n                role = Role.RESCUEE.name.lowercase(),\n                id = user.id\n            )\n\n            transactionId.assignRequestTransaction(\n                role = Role.RESCUER.name.lowercase(),\n                id = rescuer.id\n            )\n\n        }.onSuccess {\n            broadcastToNearbyCyclists()\n            _eventFlow.emit(value = MappingEvent.AcceptRescueRequestSuccess)\n            delay(500)\n            updateTransactionETA(rescuer, rescueTransaction)\n            isLoading(false)\n            broadcastRescueTransaction()\n        }.onFailure { exception ->\n            isLoading(false)\n            exception.handleException()\n        }\n\n    }\n\n    private fun updateTransactionETA(rescuer: UserItem, rescueTransaction: RescueTransactionItem) {\n        val userLocation = state.value.userLocation ?: return\n\n        val estimatedTimeArrival = rescuer.location?.let {\n            getETABetweenTwoPoints(\n                startingLocation = it,\n                endLocation = userLocation\n            )\n        }\n\n        val distance = rescuer.location?.let { mappingUseCase.getCalculatedDistanceUseCase(\n            startingLocation = it,\n            destinationLocation = userLocation)\n        }\n        _state.update {\n            it.copy(\n                rescueTransaction = rescueTransaction,\n                rescueETA = estimatedTimeArrival ?: \"\",\n                rescueDistance = distance?.formatToDistanceKm() ?: \"\",\n                rescuer = rescuer\n            )\n        }\n    }\n\n    private fun isLoading(loading: Boolean) {\n        _state.update { it.copy(isLoading = loading) }\n    }\n\n\n    private suspend fun String.assignRequestTransaction(role: String, id: String?) {\n        mappingUseCase.createUserUseCase(\n            user = UserItem.empty(id = id, transactionId = this, role = role)\n        )\n    }\n\n\n    private suspend fun Throwable.handleDeclineRescueRequest() {\n        when (this) {\n            is MappingExceptions.NetworkException -> {\n                _eventFlow.emit(value = MappingEvent.NoInternetConnection)\n            }\n\n            else -> {\n                Timber.d(\"Failed to update user\")\n            }\n        }\n    }\n\n\n    private suspend fun cancelUserHelpRequest() {\n\n        mappingUseCase.createUserUseCase(\n            user = UserItem.cancelUserHelpRequest(id = getId()))\n    }\n\n\n    private suspend fun NearbyCyclist.filterUser() {\n\n        runCatching {\n            getId()\n        }.onSuccess { id ->\n            findUser(id = id)?.let { user ->\n                val respondents = user.getUserRescueRespondents(this).distinctBy { it.id }\n                _state.update {\n                    it.copy(\n                        newRescueRequest = NewRescueRequestsModel(request = respondents),\n                        user = user)\n                }\n                user.getTransactionId()?.let { loadRescueTransaction(transactionId = it) }\n            }\n\n        }.onFailure {\n            Timber.e(\"Failed to get user: ${it.message}\")\n        }\n\n    }\n\n\n\n    private fun UserItem.getUserRescueRespondents(nearbyCyclist: NearbyCyclist): List<RescueRequestItemModel> {\n        val rescueRespondentsSnapShot: MutableList<RescueRequestItemModel> = mutableListOf()\n\n        rescueRequest?.respondents?.forEach { respondent ->\n            val userRespondent = nearbyCyclist.findUser(id = respondent.clientId) ?: UserItem()\n            val distance =\n                calculateDistance(startLocation = location, endLocation = userRespondent.location)\n\n            distance?.let {\n                val formattedETA = FormatterUtils.getCalculatedETA(distanceMeters = it)\n                rescueRespondentsSnapShot.add(\n                    element = userRespondent.toRescueRequest(\n                        distance = it.formatToDistanceKm(),\n                        eta = formattedETA,\n                        timestamp = respondent.timeStamp\n                    )\n                )\n            }\n        }\n\n        return rescueRespondentsSnapShot.distinct()\n    }\n\n    private fun calculateDistance(\n        startLocation: LocationModel?,\n        endLocation: LocationModel?): Double? {\n        val startLatitude = startLocation?.latitude ?: return null\n        val startLongitude = startLocation.longitude ?: return null\n        val endLatitude = endLocation?.latitude ?: return null\n        val endLongitude = endLocation.longitude ?: return null\n\n        return mappingUseCase.getCalculatedDistanceUseCase(\n            startingLocation = LocationModel(latitude = startLatitude, longitude = startLongitude),\n            destinationLocation = LocationModel(latitude = endLatitude, longitude = endLongitude)\n        )\n    }\n\n    private fun NearbyCyclist.updateNearbyCyclists() {\n\n        _state.update {\n            it.copy(nearbyCyclist = NearbyCyclist())\n        }\n        _state.update {\n            it.copy(nearbyCyclist = this)\n        }\n    }\n\n    private suspend fun broadcastRescueTransactionToRespondent(location: LocationModel) {\n        val rescueTransaction = state.value.rescueTransaction ?: return\n        runCatching {\n\n            val user = state.value.user\n            mappingUseCase.transactionLocationUseCase(\n                LiveLocationSocketModel(\n                    latitude = location.latitude,\n                    longitude = location.longitude,\n                    room = rescueTransaction.id\n                ),\n                user = user,\n                rescueTransactionItem = rescueTransaction\n            )\n\n        }.onSuccess {\n            Timber.v(\"Broadcasting location to transaction success\")\n        }.onFailure {\n            Timber.v(\"Broadcasting location to transaction failed: ${it.message}\")\n        }\n    }\n\n\n    private fun unSubscribeToTransactionLocationUpdates() {\n        getTransactionLocationUpdatesJob?.cancel()\n    }\n\n    private fun removeHazardousLaneListener() {\n        mappingUseCase.removeHazardousListenerUseCase()\n    }\n\n\n    private fun subscribeToRescueTransactionUpdates() {\n        if (getRescueTransactionUpdatesJob?.isActive == true) {\n            return\n        }\n        getRescueTransactionUpdatesJob =\n            viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n\n                mappingUseCase.getRescueTransactionUpdatesUseCase().catch {\n                    Timber.e(\"ERROR GETTING RESCUE TRANSACTION: ${it.message}\")\n\n                }.onEach { rescueTransactions ->\n                    rescueTransactions.updateCurrentRescueTransaction()\n\n                    trackingHandler.checkRescueRequestAccepted(\n                        rescueTransaction = rescueTransactions,\n                        id = getId()\n                    )\n\n                    trackingHandler.updateClient()\n                }.launchIn(this@launch).invokeOnCompletion {\n                    savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n                }\n\n            }\n    }\n\n\n    private fun RescueTransaction.updateCurrentRescueTransaction() {\n        val rescueTransaction = trackingHandler.filterUserRescueTransaction(this)\n        _state.update { it.copy(rescueTransaction = rescueTransaction) }\n    }\n\n\n    private fun unSubscribeToRescueTransactionUpdates() {\n        getRescueTransactionUpdatesJob?.cancel()\n    }\n\n    private fun unSubscribeToNearbyUsersChanges() {\n        getUsersUpdatesJob?.cancel()\n    }\n\n    private fun subscribeToLocationUpdates() {\n        if (locationUpdatesJob?.isActive == true) {\n            return\n        }\n        locationUpdatesJob = viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n\n            mappingUseCase.getUserLocationUseCase().catch {\n                Timber.e(\"Error Location Updates: ${it.message}\")\n            }.onEach { location ->\n                trackingHandler.updateLocation(location)\n                broadcastRescueTransactionToRespondent(location)\n                updateSpeedometer(location)\n                if(state.value.nearbyCyclist == null) {\n                    broadcastToNearbyCyclists()\n                }\n\n            }.launchIn(this@launch).invokeOnCompletion {\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n    private fun updateSpeedometer(location: LocationModel) {\n        val isUserRescuer = state.value.user.isRescuer()\n        if (isUserRescuer) {\n            trackingHandler.setSpeed(location.speed)\n            trackingHandler.getTopSpeed(location.speed)\n            travelledPath.add(element = GoogleLatLng(location.latitude!!, location.longitude!!))\n            val distance = SphericalUtil.computeLength(travelledPath).formatToDistanceKm()\n            trackingHandler.setTravelledDistance(distance)\n        }\n    }\n\n\n    private fun subscribeToNearbyUsersChanges() {\n        if (getUsersUpdatesJob?.isActive == true) {\n            return\n        }\n\n        getUsersUpdatesJob = viewModelScope.launch(context = SupervisorJob() + defaultDispatcher) {\n\n            mappingUseCase.nearbyCyclistsUseCase().catch {\n                Timber.e(\"ERROR GETTING USERS: ${it.message}\")\n            }.onEach {\n                it.filterUser()\n                it.updateNearbyCyclists()\n                Timber.v(\"Receiving from subscribeToNearbyUsersChanges\")\n                trackingHandler.updateClient()\n            }.launchIn(this).invokeOnCompletion {\n                savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n    private fun unSubscribeToLocationUpdates() {\n        locationUpdatesJob?.cancel()\n    }\n\n\n    private suspend inline fun uploadUserProfile(crossinline onSuccess: () -> Unit) {\n        coroutineScope {\n            val userLocation = state.value.userLocation\n\n            if (userLocation == null) {\n                _eventFlow.emit(MappingEvent.LocationNotAvailable(reason = \"Searching for GPS\"))\n                return@coroutineScope\n            }\n\n            uploadProfile(location = userLocation, onSuccess = onSuccess)\n\n        }\n    }\n\n\n    private suspend inline fun uploadProfile(\n        location: LocationModel,\n        crossinline onSuccess: () -> Unit\n    ) {\n\n        val isProfileUploaded = state.value.profileUploaded\n\n        if (isProfileUploaded) {\n            onSuccess()\n            return\n        }\n\n        val fullAddress = mappingUseCase.getFullAddressUseCase(\n            latitude = location.latitude,\n            longitude = location.longitude\n        )\n\n        coroutineScope {\n\n            runCatching {\n                isLoading(true)\n                fullAddress?.let { mappingUseCase.addressUseCase(it) }\n                mappingUseCase.createUserUseCase(\n                    user = UserItem(\n                        id = getId(),\n                        name = getName(),\n                        address = fullAddress,\n                        profilePictureUrl = getPhotoUrl(),\n                        location = LocationModel(\n                            latitude = location.latitude,\n                            longitude = location.longitude\n                        ),\n                        rescueRequest = RescueRequest(),\n                        userAssistance = UserAssistanceModel(),\n                        rescuePending = RescuePending()\n                    )\n                )\n\n\n            }.onSuccess {\n                isLoading(false)\n                broadcastToNearbyCyclists()\n                onSuccess()\n                _state.update { it.copy(profileUploaded = true) }\n\n            }.onFailure { exception ->\n                Timber.e(\"Error uploading profile: ${exception.message}\")\n                isLoading(false)\n                exception.handleException()\n            }\n        }\n    }\n\n\n    private suspend fun Throwable.handleException() {\n        trackingHandler.handleException(this)\n        savedStateHandle[MAPPING_VM_STATE_KEY] = state.value\n    }\n\n\n    private suspend fun createMockUpUsers() {\n        runCatching {\n            mappingUseCase.createMockUsers()\n        }.onSuccess {\n            Timber.v(\"CREATED MOCK USERS!\")\n            broadcastToNearbyCyclists()\n        }.onFailure {\n            Timber.e(\"FAILED TO CREATE MOCK USERS: ${it.message}\")\n        }\n    }\n\n    private fun removeBottomSheet() {\n        viewModelScope.launch(SupervisorJob()) {\n            mappingUseCase.bottomSheetTypeUseCase(bottomSheet = \"\")\n        }\n    }\n\n\n    override fun onCleared() {\n        super.onCleared()\n        removeBottomSheet()\n        unSubscribeToLocationUpdates()\n        unSubscribeToNearbyUsersChanges()\n        unSubscribeToRescueTransactionUpdates()\n        unSubscribeToTransactionLocationUpdates()\n        removeHazardousLaneListener()\n\n\n    }\n\n\n    private fun getId(): String = authUseCase.getIdUseCase()\n\n    private suspend fun getName(): String = userProfileUseCase.getNameUseCase()\n\n    private suspend fun getPhotoUrl() = userProfileUseCase.getPhotoUrlUseCase()\n\n    private fun clearTravelledPath() {\n        travelledPath = mutableListOf()\n    }\n\n\n}\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/MappingViewModel.kt	(date 1696832336683)
@@ -98,7 +98,7 @@
         observeDataChanges()
         getMapType()
         getShouldShowHazardousStartingInfo()
-        refreshToken()
+//        refreshToken()
     }
 
     private fun setShouldShowHazardousStartingInfo(shouldShow: Boolean) {
Index: firestore-debug.log
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>Oct 07, 2023 7:05:16 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketServer start\nINFO: Started WebSocket server on ws://0.0.0.0:46235\nAPI endpoint: http://0.0.0.0:9299\nIf you are using a library that supports the FIRESTORE_EMULATOR_HOST environment variable, run:\n\n   export FIRESTORE_EMULATOR_HOST=0.0.0.0:9299\n\nDev App Server is now running.\n\nOct 07, 2023 7:05:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nOct 07, 2023 7:05:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nOct 07, 2023 7:05:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nOct 07, 2023 7:05:43 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel\nINFO: Connected to new websocket client\nOct 07, 2023 7:05:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nOct 07, 2023 7:06:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead\nINFO: Detected non-HTTP/2 connection.\nOct 07, 2023 7:06:23 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler channelClosed\nINFO: Websocket client disconnected\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/firestore-debug.log b/firestore-debug.log
--- a/firestore-debug.log	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/firestore-debug.log	(date 1696833200876)
@@ -1,5 +1,5 @@
-Oct 07, 2023 7:05:16 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketServer start
-INFO: Started WebSocket server on ws://0.0.0.0:46235
+Oct 09, 2023 11:37:10 AM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketServer start
+INFO: Started WebSocket server on ws://0.0.0.0:39661
 API endpoint: http://0.0.0.0:9299
 If you are using a library that supports the FIRESTORE_EMULATOR_HOST environment variable, run:
 
@@ -7,17 +7,906 @@
 
 Dev App Server is now running.
 
-Oct 07, 2023 7:05:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+Oct 09, 2023 11:37:25 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:37:27 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:37:33 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:38:21 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:38:21 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:38:22 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:40:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:40:51 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:43:51 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:43:51 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:49:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:49:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:49:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:49:27 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:49:27 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:50:57 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:50:57 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:52:17 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:52:17 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:55:08 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:55:08 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:55:09 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:55:22 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:55:22 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:55:52 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:55:52 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:55:53 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:56:05 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:56:05 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 11:59:39 AM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 11:59:39 AM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:16:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:16:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:16:40 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:16:40 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:16:40 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:16:40 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:18:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:20:41 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:20:41 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:28:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:28:35 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:28:36 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:28:36 PM com.google.cloud.datastore.emulator.impl.util.WrappedStreamObserver onError
+INFO: operation failed: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+com.google.cloud.datastore.core.exception.DatastoreException: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+	at com.google.cloud.datastore.core.exception.DatastoreException.withProblem(DatastoreException.java:184)
+	at com.google.cloud.datastore.emulator.impl.util.FirestoreEmulatorConverters.checkMutation(FirestoreEmulatorConverters.java:169)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.commitHelper(CloudFirestoreV1.java:967)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:868)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:851)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.write(CloudFirestoreV1.java:840)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.handleRequest(CloudFirestoreV1WriteStream.java:208)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.write(CloudFirestoreV1WriteStream.java:136)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:92)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:25)
+	at io.grpc.stub.ServerCalls$StreamingServerCallHandler$StreamingServerCallListener.onMessage(ServerCalls.java:262)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:330)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:313)
+	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
+	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
+	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
+	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
+	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 12:28:37 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:28:37 PM com.google.cloud.datastore.emulator.impl.util.WrappedStreamObserver onError
+INFO: operation failed: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+com.google.cloud.datastore.core.exception.DatastoreException: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+	at com.google.cloud.datastore.core.exception.DatastoreException.withProblem(DatastoreException.java:184)
+	at com.google.cloud.datastore.emulator.impl.util.FirestoreEmulatorConverters.checkMutation(FirestoreEmulatorConverters.java:169)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.commitHelper(CloudFirestoreV1.java:967)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:868)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:851)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.write(CloudFirestoreV1.java:840)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.handleRequest(CloudFirestoreV1WriteStream.java:208)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.write(CloudFirestoreV1WriteStream.java:136)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:92)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:25)
+	at io.grpc.stub.ServerCalls$StreamingServerCallHandler$StreamingServerCallListener.onMessage(ServerCalls.java:262)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:330)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:313)
+	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
+	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
+	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
+	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
+	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 12:29:11 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:29:11 PM com.google.cloud.datastore.emulator.impl.util.WrappedStreamObserver onError
+INFO: operation failed: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+com.google.cloud.datastore.core.exception.DatastoreException: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+	at com.google.cloud.datastore.core.exception.DatastoreException.withProblem(DatastoreException.java:184)
+	at com.google.cloud.datastore.emulator.impl.util.FirestoreEmulatorConverters.checkMutation(FirestoreEmulatorConverters.java:169)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.commitHelper(CloudFirestoreV1.java:967)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:868)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:851)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.write(CloudFirestoreV1.java:840)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.handleRequest(CloudFirestoreV1WriteStream.java:208)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.write(CloudFirestoreV1WriteStream.java:136)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:92)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:25)
+	at io.grpc.stub.ServerCalls$StreamingServerCallHandler$StreamingServerCallListener.onMessage(ServerCalls.java:262)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:330)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:313)
+	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
+	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
+	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
+	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
+	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
 INFO: Detected non-HTTP/2 connection.
-Oct 07, 2023 7:05:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
 INFO: Detected non-HTTP/2 connection.
-Oct 07, 2023 7:05:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
 INFO: Detected non-HTTP/2 connection.
-Oct 07, 2023 7:05:43 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel
+Oct 09, 2023 12:29:29 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler initChannel
 INFO: Connected to new websocket client
-Oct 07, 2023 7:05:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:41 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:29:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:45 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:29:45 PM com.google.cloud.datastore.emulator.impl.util.WrappedStreamObserver onError
+INFO: operation failed: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+com.google.cloud.datastore.core.exception.DatastoreException: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+	at com.google.cloud.datastore.core.exception.DatastoreException.withProblem(DatastoreException.java:184)
+	at com.google.cloud.datastore.emulator.impl.util.FirestoreEmulatorConverters.checkMutation(FirestoreEmulatorConverters.java:169)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.commitHelper(CloudFirestoreV1.java:967)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:868)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:851)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.write(CloudFirestoreV1.java:840)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.handleRequest(CloudFirestoreV1WriteStream.java:208)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.write(CloudFirestoreV1WriteStream.java:136)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:92)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:25)
+	at io.grpc.stub.ServerCalls$StreamingServerCallHandler$StreamingServerCallListener.onMessage(ServerCalls.java:262)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:330)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:313)
+	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
+	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
+	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
+	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
+	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 12:29:46 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:29:47 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:29:52 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:29:52 PM com.google.cloud.datastore.emulator.impl.util.WrappedStreamObserver onError
+INFO: operation failed: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+com.google.cloud.datastore.core.exception.DatastoreException: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+	at com.google.cloud.datastore.core.exception.DatastoreException.withProblem(DatastoreException.java:184)
+	at com.google.cloud.datastore.emulator.impl.util.FirestoreEmulatorConverters.checkMutation(FirestoreEmulatorConverters.java:169)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.commitHelper(CloudFirestoreV1.java:967)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:868)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:851)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.write(CloudFirestoreV1.java:840)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.handleRequest(CloudFirestoreV1WriteStream.java:208)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.write(CloudFirestoreV1WriteStream.java:136)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:92)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:25)
+	at io.grpc.stub.ServerCalls$StreamingServerCallHandler$StreamingServerCallListener.onMessage(ServerCalls.java:262)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:330)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:313)
+	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
+	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
+	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
+	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
+	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 12:30:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:30 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:30:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:06 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:31:07 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:31:07 PM com.google.cloud.datastore.emulator.impl.util.WrappedStreamObserver onError
+INFO: operation failed: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+com.google.cloud.datastore.core.exception.DatastoreException: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+	at com.google.cloud.datastore.core.exception.DatastoreException.withProblem(DatastoreException.java:184)
+	at com.google.cloud.datastore.emulator.impl.util.FirestoreEmulatorConverters.checkMutation(FirestoreEmulatorConverters.java:169)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.commitHelper(CloudFirestoreV1.java:967)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:868)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:851)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.write(CloudFirestoreV1.java:840)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.handleRequest(CloudFirestoreV1WriteStream.java:208)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.write(CloudFirestoreV1WriteStream.java:136)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:92)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:25)
+	at io.grpc.stub.ServerCalls$StreamingServerCallHandler$StreamingServerCallListener.onMessage(ServerCalls.java:262)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:330)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:313)
+	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
+	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
+	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
+	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
+	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 12:31:08 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:31:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:10 PM com.google.cloud.datastore.emulator.impl.context.EmulatorAuthorization warnAboutSecuredJwt
+WARNING: expected an unsecured JWT, the emulator does not validate JWTs and IS NOT SECURE
+Oct 09, 2023 12:31:10 PM com.google.cloud.datastore.emulator.impl.util.WrappedStreamObserver onError
+INFO: operation failed: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+com.google.cloud.datastore.core.exception.DatastoreException: no entity to update: app: "dev~cyclistance-cc715"
+path <
+  Element {
+    type: "users"
+    name: "FuqSkyZDI5azvTrAZvqJQsakXoe2"
+  }
+>
+
+	at com.google.cloud.datastore.core.exception.DatastoreException.withProblem(DatastoreException.java:184)
+	at com.google.cloud.datastore.emulator.impl.util.FirestoreEmulatorConverters.checkMutation(FirestoreEmulatorConverters.java:169)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.commitHelper(CloudFirestoreV1.java:967)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:868)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.internalCommit(CloudFirestoreV1.java:851)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1.write(CloudFirestoreV1.java:840)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.handleRequest(CloudFirestoreV1WriteStream.java:208)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.write(CloudFirestoreV1WriteStream.java:136)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:92)
+	at com.google.cloud.datastore.emulator.impl.CloudFirestoreV1WriteStream.onNext(CloudFirestoreV1WriteStream.java:25)
+	at io.grpc.stub.ServerCalls$StreamingServerCallHandler$StreamingServerCallListener.onMessage(ServerCalls.java:262)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.ForwardingServerCallListener.onMessage(ForwardingServerCallListener.java:33)
+	at io.grpc.Contexts$ContextualizedServerCallListener.onMessage(Contexts.java:76)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailableInternal(ServerCallImpl.java:330)
+	at io.grpc.internal.ServerCallImpl$ServerStreamListenerImpl.messagesAvailable(ServerCallImpl.java:313)
+	at io.grpc.internal.ServerImpl$JumpToApplicationThreadServerStreamListener$1MessagesAvailable.runInContext(ServerImpl.java:834)
+	at io.grpc.internal.ContextRunnable.run(ContextRunnable.java:37)
+	at io.grpc.internal.SerializingExecutor.run(SerializingExecutor.java:133)
+	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1136)
+	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:635)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 12:31:10 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:12 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:31:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:32:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:33:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:33:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:34:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:34:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:34:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected HTTP/2 connection.
+Oct 09, 2023 12:34:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:35:48 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:36:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:37:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:38:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:39:32 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:40:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:41:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:42:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:43:06 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:43:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:44:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:46:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:47:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:48:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:49:08 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:50:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:51:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:52:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:53:12 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:53:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:54:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:55:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:56:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:57:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:58:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:58:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:58:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:58:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:58:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 12:59:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:00:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:00:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:01:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:03:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:04:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:05:04 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:05:50 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:05:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:05:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:05:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:05:53 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:06:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:07:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:08:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:09:52 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:10:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:11:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:12:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:13:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:14:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:15:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:16:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:17:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:18:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:07 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:26 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:19:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:20:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:20:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:20:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:20:54 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:21:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:21:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:22:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:23:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:24:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:26:12 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:26:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:27:58 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:29:59 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:31:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:32:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:33:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:34:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:34:43 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:34:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:34:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:34:44 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:34:45 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:34:46 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:35:01 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:36:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:36:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:37:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:38:03 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:38:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:39:49 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:40:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:41:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:42:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:43:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:44:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:45:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:45:51 PM io.netty.channel.DefaultChannelPipeline onUnhandledInboundException
+WARNING: An exceptionCaught() event was fired, and it reached at the tail of the pipeline. It usually means the last handler in the pipeline did not handle the exception.
+java.net.SocketException: Connection reset
+	at java.base/sun.nio.ch.SocketChannelImpl.throwConnectionReset(SocketChannelImpl.java:394)
+	at java.base/sun.nio.ch.SocketChannelImpl.read(SocketChannelImpl.java:426)
+	at io.netty.buffer.PooledByteBuf.setBytes(PooledByteBuf.java:253)
+	at io.netty.buffer.AbstractByteBuf.writeBytes(AbstractByteBuf.java:1132)
+	at io.netty.channel.socket.nio.NioSocketChannel.doReadBytes(NioSocketChannel.java:350)
+	at io.netty.channel.nio.AbstractNioByteChannel$NioByteUnsafe.read(AbstractNioByteChannel.java:151)
+	at io.netty.channel.nio.NioEventLoop.processSelectedKey(NioEventLoop.java:722)
+	at io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized(NioEventLoop.java:658)
+	at io.netty.channel.nio.NioEventLoop.processSelectedKeys(NioEventLoop.java:584)
+	at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:496)
+	at io.netty.util.concurrent.SingleThreadEventExecutor$4.run(SingleThreadEventExecutor.java:986)
+	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)
+	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)
+	at java.base/java.lang.Thread.run(Thread.java:833)
+
+Oct 09, 2023 1:46:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:47:23 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:48:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:48:55 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:50:11 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:50:57 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:52:13 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:53:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:54:29 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:55:15 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:56:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:57:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:58:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 1:59:33 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:00:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:01:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
 INFO: Detected non-HTTP/2 connection.
-Oct 07, 2023 7:06:21 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+Oct 09, 2023 2:02:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
 INFO: Detected non-HTTP/2 connection.
-Oct 07, 2023 7:06:23 PM com.google.cloud.datastore.emulator.firestore.websocket.WebSocketChannelHandler channelClosed
-INFO: Websocket client disconnected
+Oct 09, 2023 2:03:19 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:03:37 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:03:39 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:04:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:05:35 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:06:17 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:06:51 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:07:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:07:09 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:07:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:07:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:08:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:09:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:10:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:11:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:12:20 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:13:36 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:14:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:15:22 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:16:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:17:05 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:17:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:18:38 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:19:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:20:24 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:21:40 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:22:56 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:23:42 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:24:28 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:25:14 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:26:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:27:00 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:28:16 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:29:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:30:02 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:31:18 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
+Oct 09, 2023 2:32:34 PM io.gapi.emulators.netty.HttpVersionRoutingHandler channelRead
+INFO: Detected non-HTTP/2 connection.
Index: app/src/main/java/com/example/cyclistance/navigation/NavViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.navigation\n\nimport androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.cyclistance.core.utils.constants.NavConstants.NAV_VM_STATE_KEY\nimport com.example.cyclistance.feature_authentication.domain.use_case.AuthenticationUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.MessagingUseCase\nimport com.example.cyclistance.feature_on_boarding.domain.use_case.IntroSliderUseCase\nimport com.example.cyclistance.navigation.event.NavEvent\nimport com.example.cyclistance.navigation.event.NavVmEvent\nimport com.example.cyclistance.navigation.state.NavState\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.catch\nimport kotlinx.coroutines.flow.launchIn\nimport kotlinx.coroutines.flow.onEach\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\nimport javax.inject.Inject\n\n@HiltViewModel\nclass NavViewModel @Inject constructor(\n    private val savedStateHandle: SavedStateHandle,\n    private val introSliderUseCase: IntroSliderUseCase,\n    private val authUseCase: AuthenticationUseCase,\n    private val messagingUseCase: MessagingUseCase\n) : ViewModel() {\n\n\n    private val _state = MutableStateFlow(savedStateHandle[NAV_VM_STATE_KEY] ?: NavState())\n    val state = _state.asStateFlow()\n\n    private val _event = MutableSharedFlow<NavEvent>()\n    val event = _event.asSharedFlow()\n\n    init {\n        getStartingDestination()\n        setUserAvailability(true)\n    }\n\n    private fun setUserAvailability(availability: Boolean){\n        viewModelScope.launch(SupervisorJob()) {\n            runCatching {\n                messagingUseCase.updateUserAvailability(availability)\n            }.onSuccess {\n                Timber.v(\"User Availability Updated Successfully\")\n            }.onFailure {\n                Timber.e(\"User Availability Update Failed: ${it.localizedMessage}\")\n            }\n        }\n    }\n\n    private fun getStartingDestination() {\n\n        introSliderUseCase.readIntroSliderUseCase().catch {\n            Timber.e(\"IntroSlider DataStore Reading Failed: ${it.localizedMessage}\")\n        }.onEach { userCompletedWalkThrough ->\n            if (!userCompletedWalkThrough) {\n                _state.update { it.copy(navigationStartingDestination = Screens.OnBoardingNavigation.ROUTE) }\n                return@onEach\n            }\n\n            if (isUserSignedIn()) {\n                _state.update { it.copy(navigationStartingDestination = Screens.MappingNavigation.ROUTE) }\n                return@onEach\n            }\n\n            _state.update { it.copy(navigationStartingDestination = Screens.AuthenticationNavigation.ROUTE) }\n        }.launchIn(viewModelScope).invokeOnCompletion {\n            savedStateHandle[NAV_VM_STATE_KEY] = state.value\n        }\n\n    }\n\n    fun onEvent(event: NavVmEvent) {\n        when (event) {\n            is NavVmEvent.DeleteMessagingToken -> deleteMessagingToken()\n        }\n    }\n\n    private fun deleteMessagingToken() {\n        viewModelScope.launch {\n            runCatching {\n                messagingUseCase.deleteTokenUseCase()\n            }.onSuccess {\n                _event.emit(value = NavEvent.DeleteMessagingTokenSuccess)\n            }.onFailure {\n                _event.emit(\n                    value = NavEvent.DeleteMessagingTokenFailure(\n                        it.message ?: \"Unknown Error\"))\n            }\n        }\n    }\n\n    private fun isUserSignedIn(): Boolean {\n        return (authUseCase.isSignedInWithProviderUseCase() == true || authUseCase.isEmailVerifiedUseCase() == true) &&\n               authUseCase.hasAccountSignedInUseCase()\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        setUserAvailability(false)\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/navigation/NavViewModel.kt b/app/src/main/java/com/example/cyclistance/navigation/NavViewModel.kt
--- a/app/src/main/java/com/example/cyclistance/navigation/NavViewModel.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/navigation/NavViewModel.kt	(date 1696832120609)
@@ -11,7 +11,6 @@
 import com.example.cyclistance.navigation.event.NavVmEvent
 import com.example.cyclistance.navigation.state.NavState
 import dagger.hilt.android.lifecycle.HiltViewModel
-import kotlinx.coroutines.SupervisorJob
 import kotlinx.coroutines.flow.MutableSharedFlow
 import kotlinx.coroutines.flow.MutableStateFlow
 import kotlinx.coroutines.flow.asSharedFlow
@@ -41,20 +40,9 @@
 
     init {
         getStartingDestination()
-        setUserAvailability(true)
     }
 
-    private fun setUserAvailability(availability: Boolean){
-        viewModelScope.launch(SupervisorJob()) {
-            runCatching {
-                messagingUseCase.updateUserAvailability(availability)
-            }.onSuccess {
-                Timber.v("User Availability Updated Successfully")
-            }.onFailure {
-                Timber.e("User Availability Update Failed: ${it.localizedMessage}")
-            }
-        }
-    }
+
 
     private fun getStartingDestination() {
 
@@ -105,7 +93,6 @@
 
     override fun onCleared() {
         super.onCleared()
-        setUserAvailability(false)
     }
 
 }
\ No newline at end of file
Index: app/src/main/java/com/example/cyclistance/feature_messaging/data/repository/MessagingRepositoryImpl.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_messaging.data.repository\n\nimport android.content.Context\nimport com.example.cyclistance.R\nimport com.example.cyclistance.core.utils.connection.ConnectionStatus.hasInternetConnection\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.CONVERSATION_ID\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_AVAILABILITY\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_COLLECTION_CHATS\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_CONVERSATIONS_COLLECTION\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_FCM_TOKEN\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_IS_SEEN\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_LAST_MESSAGE\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_MESSAGE\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_RECEIVER_ID\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_SENDER_ID\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.KEY_TIMESTAMP\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.REMOTE_MSG_DATA\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.REMOTE_MSG_REGISTRATION_IDS\nimport com.example.cyclistance.core.utils.constants.MessagingConstants.SAVED_TOKEN\nimport com.example.cyclistance.core.utils.constants.UtilConstants.KEY_NAME\nimport com.example.cyclistance.core.utils.constants.UtilConstants.USER_COLLECTION\nimport com.example.cyclistance.core.utils.contexts.dataStore\nimport com.example.cyclistance.core.utils.data_store_ext.editData\nimport com.example.cyclistance.core.utils.data_store_ext.getData\nimport com.example.cyclistance.feature_messaging.data.MessagingApi\nimport com.example.cyclistance.feature_messaging.data.data_source.remote.header.RemoteHeader\nimport com.example.cyclistance.feature_messaging.data.mapper.MessagingChatItemMapper.toConversionChatItem\nimport com.example.cyclistance.feature_messaging.data.mapper.MessagingConversationItemMapper.toConversationItem\nimport com.example.cyclistance.feature_messaging.data.mapper.MessagingUserItemMapper.toMessageUser\nimport com.example.cyclistance.feature_messaging.domain.exceptions.MessagingExceptions\nimport com.example.cyclistance.feature_messaging.domain.model.SendMessageModel\nimport com.example.cyclistance.feature_messaging.domain.model.SendNotificationModel\nimport com.example.cyclistance.feature_messaging.domain.model.ui.chats.ChatItemModel\nimport com.example.cyclistance.feature_messaging.domain.model.ui.chats.MessagingUserItemModel\nimport com.example.cyclistance.feature_messaging.domain.model.ui.conversation.ConversationItemModel\nimport com.example.cyclistance.feature_messaging.domain.model.ui.conversation.ConversationsModel\nimport com.example.cyclistance.feature_messaging.domain.repository.MessagingRepository\nimport com.google.firebase.auth.FirebaseAuth\nimport com.google.firebase.firestore.DocumentChange\nimport com.google.firebase.firestore.DocumentSnapshot\nimport com.google.firebase.firestore.FieldValue\nimport com.google.firebase.firestore.Filter\nimport com.google.firebase.firestore.FirebaseFirestore\nimport com.google.firebase.firestore.FirebaseFirestoreException\nimport com.google.firebase.firestore.ListenerRegistration\nimport com.google.firebase.firestore.MetadataChanges\nimport com.google.firebase.firestore.Query\nimport com.google.firebase.firestore.QuerySnapshot\nimport com.google.firebase.messaging.FirebaseMessaging\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.async\nimport kotlinx.coroutines.awaitAll\nimport kotlinx.coroutines.coroutineScope\nimport kotlinx.coroutines.flow.firstOrNull\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlinx.coroutines.tasks.await\nimport kotlinx.coroutines.withContext\nimport org.json.JSONArray\nimport org.json.JSONObject\nimport retrofit2.Call\nimport retrofit2.Callback\nimport retrofit2.Response\nimport timber.log.Timber\nimport java.util.Date\nimport kotlin.coroutines.CoroutineContext\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.resumeWithException\nimport kotlin.coroutines.suspendCoroutine\n\nclass MessagingRepositoryImpl(\n    private val fireStore: FirebaseFirestore,\n    private val firebaseMessaging: FirebaseMessaging,\n    private val auth: FirebaseAuth,\n    private val appContext: Context,\n    private val api: MessagingApi,\n\n    ) : MessagingRepository {\n    private var messageListener: ListenerRegistration? = null\n    private var chatListener: ListenerRegistration? = null\n    private var messageUserListener: ListenerRegistration? = null\n    private val scope: CoroutineContext = Dispatchers.IO\n    private var dataStore = appContext.dataStore\n\n    override suspend fun markAsSeen(messageId: String, conversionId: String) {\n        try {\n\n            coroutineScope {\n\n                val conversationUpdateTask = async {\n                    fireStore\n                        .collection(KEY_CONVERSATIONS_COLLECTION)\n                        .document(messageId)\n                        .update(KEY_IS_SEEN, true)\n                }\n\n                val chatUpdateTask = async {\n                    fireStore\n                        .collection(KEY_COLLECTION_CHATS)\n                        .document(conversionId)\n                        .update(KEY_IS_SEEN, true)\n                }\n\n                awaitAll(conversationUpdateTask, chatUpdateTask)\n            }\n        } catch (e: Exception) {\n            throw MessagingExceptions.MarkAsSeenFailure(\n                message = e.message ?: \"Mark as seen failure\"\n            )\n        }\n    }\n\n    override suspend fun reEnableNetworkSync() {\n        suspendCoroutine { continuation ->\n            fireStore.enableNetwork().addOnCompleteListener {\n                continuation.resume(Unit)\n            }.addOnFailureListener {\n                continuation.resumeWithException(MessagingExceptions.ReSyncFailure(message = it.message!!))\n            }\n        }\n    }\n\n    override suspend fun getMessagingUser(uid: String): MessagingUserItemModel {\n\n        return suspendCoroutine {\n            fireStore.collection(USER_COLLECTION)\n                .document(uid)\n                .get()\n                .addOnSuccessListener { documentSnapshot ->\n                    it.resume(documentSnapshot.toMessageUser())\n                }.addOnFailureListener { exception ->\n                    it.resumeWithException(MessagingExceptions.GetMessageUsersFailure(message = exception.message!!))\n                }\n        }\n    }\n\n\n\n    override suspend fun getConversionId(receiverId: String): String {\n        val userId = getUid()\n        return suspendCancellableCoroutine { continuation ->\n\n            fireStore.collection(KEY_COLLECTION_CHATS)\n                .where(\n                    Filter.and(\n                        Filter.or(\n                            Filter.equalTo(KEY_SENDER_ID, userId),\n                            Filter.equalTo(KEY_SENDER_ID, receiverId),\n                        ),\n                        Filter.or(\n                            Filter.equalTo(KEY_RECEIVER_ID, userId),\n                            Filter.equalTo(KEY_RECEIVER_ID, receiverId)\n                        )\n                    )\n                )\n                .get()\n                .addOnCompleteListener { task ->\n\n                    val documents = task.result?.documents ?: emptyList()\n                    if (!task.isSuccessful) {\n                        return@addOnCompleteListener\n                    }\n\n                    if (documents.isEmpty()) {\n                        return@addOnCompleteListener\n                    }\n\n                    val documentSnapshot = documents.first()\n                    continuation.resume(documentSnapshot.id)\n                }\n        }\n    }\n\n    override fun addConversion(\n        receiverId: String,\n        message: String,\n        onNewConversionId: (String) -> Unit) {\n\n        val senderId = getUid()\n        fireStore.collection(KEY_COLLECTION_CHATS).add(\n            mapOf(\n                KEY_SENDER_ID to senderId,\n                KEY_RECEIVER_ID to receiverId,\n                KEY_LAST_MESSAGE to message,\n                KEY_TIMESTAMP to Date(),\n                KEY_IS_SEEN to false\n            )\n        ).addOnSuccessListener { documentReference ->\n            onNewConversionId(documentReference.id)\n        }\n\n    }\n\n\n    override fun updateConversion(message: String, conversionId: String, receiverId: String) {\n        val senderId = getUid()\n        fireStore.collection(KEY_COLLECTION_CHATS)\n            .document(conversionId)\n            .update(\n                KEY_LAST_MESSAGE, message,\n                KEY_TIMESTAMP, Date(),\n                KEY_IS_SEEN, false,\n                KEY_SENDER_ID, senderId,\n                KEY_RECEIVER_ID, receiverId)\n            .addOnSuccessListener {\n                Timber.v(\"Conversion updated successfully\")\n            }.addOnFailureListener {\n                Timber.e(\"Conversion update failed ${it.message}\")\n            }\n    }\n\n    override fun getUserUid(): String {\n        return getUid()\n    }\n\n    override fun addMessageListener(\n        receiverId: String,\n        onNewMessage: (ConversationsModel) -> Unit\n    ) {\n\n        val userUid = getUid()\n\n        messageListener = fireStore.collection(KEY_CONVERSATIONS_COLLECTION)\n            .where(\n                Filter.and(\n                    Filter.or(\n                        Filter.equalTo(KEY_SENDER_ID, userUid),\n                        Filter.equalTo(KEY_SENDER_ID, receiverId),\n                    ),\n                    Filter.or(\n                        Filter.equalTo(KEY_RECEIVER_ID, userUid),\n                        Filter.equalTo(KEY_RECEIVER_ID, receiverId)\n                    )\n                )\n            )\n            .orderBy(KEY_TIMESTAMP, Query.Direction.ASCENDING)\n            .addSnapshotListener(MetadataChanges.INCLUDE, messageListener(onNewMessage))\n\n    }\n\n    override suspend fun refreshToken() {\n        withContext(scope) {\n\n            val token = getMessagingToken()\n            val savedToken = dataStore.getData(key = SAVED_TOKEN, defaultValue = \"\").firstOrNull()\n\n            if (token == savedToken) {\n                return@withContext\n            }\n\n            updateMessagingToken(token = token)\n        }\n    }\n\n\n    override fun updateUserAvailability(isUserAvailable: Boolean) {\n        val uid = getUid()\n        fireStore.collection(USER_COLLECTION)\n            .document(uid)\n            .update(KEY_AVAILABILITY, isUserAvailable)\n            .addOnSuccessListener {\n                Timber.v(\"User availability updated successfully\")\n            }.addOnFailureListener {\n                Timber.v(\"User availability update failed\")\n            }\n    }\n\n    override fun removeMessageListener() {\n        messageListener?.remove()\n    }\n\n    override suspend fun sendMessage(sendMessageModel: SendMessageModel) {\n\n        val uid = getUid()\n        val message = mapOf(\n            KEY_SENDER_ID to uid,\n            KEY_RECEIVER_ID to sendMessageModel.receiverId,\n            KEY_MESSAGE to sendMessageModel.message.trimEnd(),\n            KEY_TIMESTAMP to Date(),\n            KEY_IS_SEEN to false\n\n        )\n\n        suspendCancellableCoroutine { continuation ->\n            fireStore\n                .collection(KEY_CONVERSATIONS_COLLECTION)\n                .add(message)\n                .addOnSuccessListener {\n                    continuation.resume(Unit)\n                }.addOnFailureListener {\n                    continuation.resumeWithException(\n                        MessagingExceptions.SendMessagingFailure(\n                            message = it.message!!\n                        )\n                    )\n                }.addOnCanceledListener {\n                    Timber.e(\"Message sending cancelled by user\")\n                }\n        }\n\n    }\n\n    override suspend fun deleteToken() {\n        checkInternetConnection()\n        dataStore.editData(key = SAVED_TOKEN, value = \"\")\n        suspendCancellableCoroutine { continuation ->\n            fireStore.collection(\n                USER_COLLECTION\n            ).document(getUid()).update(KEY_FCM_TOKEN, FieldValue.delete()).addOnSuccessListener {\n                continuation.resume(Unit)\n            }.addOnFailureListener {\n                continuation.resumeWithException(MessagingExceptions.TokenException(message = it.message!!))\n            }\n        }\n    }\n\n    override suspend fun sendNotification(model: SendNotificationModel) {\n\n        val tokens = JSONArray().put(model.userReceiverToken)\n        val data = JSONObject().apply {\n            put(KEY_NAME, model.senderName)\n            put(KEY_MESSAGE, model.message)\n            put(CONVERSATION_ID, model.conversationId)\n        }\n\n        val body = JSONObject().apply {\n            put(REMOTE_MSG_DATA, data)\n            put(REMOTE_MSG_REGISTRATION_IDS, tokens)\n        }\n\n\n        api.sendMessage(\n            headers = RemoteHeader.getRemoteMsgHeader(appContext),\n            message = body.toString()\n        ).enqueue(object : Callback<String> {\n            override fun onResponse(call: Call<String>, response: Response<String>) {\n                Timber.v(\"Notification sent successfully ${response.isSuccessful} | ${response.raw()}\")\n            }\n\n            override fun onFailure(call: Call<String>, t: Throwable) {\n                Timber.v(\"Notification sending failed ${t.message}\")\n            }\n\n        })\n    }\n\n\n    private suspend fun getMessagingToken(): String {\n        return suspendCancellableCoroutine { continuation ->\n            firebaseMessaging.token.addOnSuccessListener { token: String ->\n                if (continuation.isActive) {\n                    continuation.resume(token)\n                }\n            }.addOnFailureListener {\n                continuation.resumeWithException(\n                    MessagingExceptions.TokenException(\n                        it.message!!\n                    )\n                )\n            }\n        }\n    }\n\n    private fun getUid(): String {\n        return auth.uid ?: throw MessagingExceptions.TokenException(message = \"User not logged in\")\n    }\n\n\n    private suspend fun updateMessagingToken(token: String) {\n        val uid = getUid()\n\n        try {\n            fireStore.collection(USER_COLLECTION).document(uid).update(\n                KEY_FCM_TOKEN, token\n            ).await()\n\n            withContext(Dispatchers.IO) {\n                dataStore.editData(key = SAVED_TOKEN, value = token)\n            }\n        } catch (exception: Exception) {\n            throw MessagingExceptions.TokenException(\n                message = exception.message ?: \"Token update failed\"\n            )\n        }\n    }\n\n    private fun checkInternetConnection() {\n        if (!appContext.hasInternetConnection()) {\n            throw MessagingExceptions.NetworkException(message = appContext.getString(R.string.no_internet_message))\n        }\n    }\n\n    private fun messageListener(onNewMessage: (ConversationsModel) -> Unit): (QuerySnapshot?, FirebaseFirestoreException?) -> Unit {\n        return { value: QuerySnapshot?, error: FirebaseFirestoreException? ->\n            if (value == null) {\n                throw MessagingExceptions.ListenMessagingFailure(message = \"Cannot listen to messages, value is null\")\n            }\n\n            if (error != null) {\n                throw MessagingExceptions.ListenMessagingFailure(\n                    message = error.message ?: \"Unknown error occurred\"\n                )\n            }\n\n            val messages: List<ConversationItemModel> =\n                value.documents\n                    .map {\n                        val conversationItem = it.toConversationItem()\n                        conversationItem.copy(isSent = !it.isDeviceOffline())\n                    }\n\n            onNewMessage(\n                ConversationsModel(\n                    messages = messages\n                )\n            )\n        }\n    }\n\n    private fun DocumentSnapshot.isDeviceOffline(): Boolean {\n        return with(this.metadata) { isFromCache.and(hasPendingWrites()) }\n    }\n\n    private inline fun chatListener(\n        crossinline onAddedChat: (ChatItemModel) -> Unit,\n        crossinline onModifiedChat: (ChatItemModel) -> Unit\n    ): (QuerySnapshot?, FirebaseFirestoreException?) -> Unit {\n\n        return { value: QuerySnapshot?, error: FirebaseFirestoreException? ->\n\n            val uid = getUid()\n\n            if (error != null) {\n                throw MessagingExceptions.GetChatsFailure(\n                    message = error.message ?: \"Unknown error occurred\"\n                )\n            }\n\n            if (value == null) {\n                throw MessagingExceptions.GetChatsFailure(message = \"Cannot get chats, value is null\")\n            }\n            Timber.v(\"Chat listener called ${value.documentChanges.size} | ${value.documents.size}\")\n\n            value.documentChanges.forEach { item ->\n\n                when (item.type) {\n\n                    DocumentChange.Type.ADDED -> {\n                        val chat = item.document.toConversionChatItem(uid = uid)\n                        onAddedChat(chat.copy(isSent = !item.document.isDeviceOffline()))\n                    }\n\n                    else -> {}\n                }\n            }\n\n\n\n            value.documents.forEach { item ->\n                val chat = item.toConversionChatItem(uid = uid)\n                onModifiedChat(chat.copy(isSent = !item.isDeviceOffline()))\n            }\n\n        }\n    }\n\n\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_messaging/data/repository/MessagingRepositoryImpl.kt b/app/src/main/java/com/example/cyclistance/feature_messaging/data/repository/MessagingRepositoryImpl.kt
--- a/app/src/main/java/com/example/cyclistance/feature_messaging/data/repository/MessagingRepositoryImpl.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_messaging/data/repository/MessagingRepositoryImpl.kt	(date 1696832957406)
@@ -368,14 +368,16 @@
     private suspend fun updateMessagingToken(token: String) {
         val uid = getUid()
 
+        Timber.v("Token updated successfully $uid")
         try {
-            fireStore.collection(USER_COLLECTION).document(uid).update(
-                KEY_FCM_TOKEN, token
-            ).await()
+            fireStore.collection(USER_COLLECTION)
+                .document(uid)
+                .update(KEY_FCM_TOKEN, token)
+                .await()
 
-            withContext(Dispatchers.IO) {
+          /*  withContext(Dispatchers.IO) {
                 dataStore.editData(key = SAVED_TOKEN, value = token)
-            }
+            }*/
         } catch (exception: Exception) {
             throw MessagingExceptions.TokenException(
                 message = exception.message ?: "Token update failed"
Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.BottomSheetScaffoldState\nimport androidx.compose.material.CircularProgressIndicator\nimport androidx.compose.material.ExperimentalMaterialApi\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.saveable.rememberSaveable\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.compose.ui.unit.dp\nimport androidx.constraintlayout.compose.ConstraintLayout\nimport androidx.constraintlayout.compose.Dimension\nimport com.example.cyclistance.core.domain.model.AlertDialogState\nimport com.example.cyclistance.core.presentation.dialogs.alert_dialog.AlertDialog\nimport com.example.cyclistance.core.presentation.dialogs.no_internet_dialog.NoInternetDialog\nimport com.example.cyclistance.core.presentation.dialogs.permissions_dialog.DialogForegroundLocationPermission\nimport com.example.cyclistance.core.presentation.dialogs.permissions_dialog.DialogNotificationPermission\nimport com.example.cyclistance.feature_authentication.presentation.common.visible\nimport com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.components.emergency_call.EmergencyCallDialog\nimport com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.state.EmergencyCallState\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.hazardous_lane.HazardousLaneMarker\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.CancelledRescueModel\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.banner.MappingExpandableBanner\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.bottomSheet.MappingBottomSheet\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.CancelRespondButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.RequestHelpButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.RespondToHelpButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.CancelOnGoingRescueDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.CancelSearchDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.DeleteHazardousLaneMarkerDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.DiscardHazardousLaneMarkerDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.fabs.ExpandableFABSection\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.fabs.FloatingButtonSection\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.request.MappingRequestAccepted\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.request.MappingRequestCancelled\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.rescue_request.RescueRequestDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.BottomSheetType\nimport com.google.accompanist.permissions.ExperimentalPermissionsApi\nimport com.google.accompanist.permissions.MultiplePermissionsState\nimport com.google.accompanist.permissions.rememberMultiplePermissionsState\nimport com.mapbox.mapboxsdk.maps.MapboxMap\nimport timber.log.Timber\n\n\n@OptIn(ExperimentalPermissionsApi::class, ExperimentalMaterialApi::class)\n@Composable\nfun MappingScreenContent(\n    modifier: Modifier,\n    bottomSheetScaffoldState: BottomSheetScaffoldState,\n    state: MappingState,\n    emergencyState: EmergencyCallState,\n    mapboxMap: MapboxMap?,\n\n    uiState: MappingUiState,\n    incidentDescription: TextFieldValue,\n    hazardousLaneMarkers: List<HazardousLaneMarker>,\n    locationPermissionState: MultiplePermissionsState = rememberMultiplePermissionsState(permissions = emptyList()),\n    event: (MappingUiEvent) -> Unit = {},\n) {\n\n    val respondentCount by remember(state.newRescueRequest?.request?.size) {\n        derivedStateOf { (state.newRescueRequest?.request)?.size ?: 0 }\n    }\n\n    var lastNotifiedRequestId by rememberSaveable{ mutableStateOf(\"\") }\n    var lastNotifiedAcceptedId by rememberSaveable { mutableStateOf(\"\") }\n\n    val configuration = LocalConfiguration.current\n    val markerPostedCount by remember(hazardousLaneMarkers.size){\n        derivedStateOf {\n            hazardousLaneMarkers.count { it.idCreator == state.userId }\n        }\n    }\n\n    LaunchedEffect(key1 = respondentCount){\n        val request = state.newRescueRequest?.request?.lastOrNull() ?: return@LaunchedEffect\n        if(lastNotifiedRequestId == request.id) {\n            return@LaunchedEffect\n        }\n\n        event(MappingUiEvent.NotifyUser(title = \"New Rescue Request\", message = \"Request from ${request.name}, distance is ${request.distance}\"))\n        lastNotifiedRequestId = request.id ?: \"\"\n    }\n\n    LaunchedEffect(key1 = uiState.rescueRequestAccepted, key2 = uiState.isRescueCancelled.not()){\n\n\n        val rescueeId = state.rescuee?.id\n        if(lastNotifiedAcceptedId == rescueeId){\n            return@LaunchedEffect\n        }\n        if (uiState.rescueRequestAccepted && uiState.isRescueCancelled.not()) {\n\n            event(MappingUiEvent.NotifyUser(\n                    title = \"Request Accepted\",\n                    message = \"${state.rescuee?.name} accepted your request\"))\n            lastNotifiedAcceptedId = rescueeId ?: \"\"\n        }\n    }\n\n\n    Surface(\n        modifier = modifier\n            .fillMaxSize(),\n        color = MaterialTheme.colors.background) {\n\n\n        Box {\n\n            if (uiState.isRescueRequestDialogVisible) {\n                RescueRequestDialog(\n                    modifier = Modifier\n                        .fillMaxSize(),\n                    mappingState = state,\n                    uiState = uiState,\n                    event = event\n                )\n            }\n\n            MappingBottomSheet(\n                state = state,\n                event = event,\n                bottomSheetScaffoldState = bottomSheetScaffoldState,\n                uiState = uiState,\n                incidentDescription = incidentDescription,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(horizontal = 12.dp)\n                    .align(Alignment.BottomCenter),\n                markerPostedCount = markerPostedCount) {\n\n\n                ConstraintLayout(modifier = Modifier.fillMaxSize()) {\n\n                    val (mapScreen, requestHelpButton, circularProgressbar, dialog, respondToHelpButton, fabSection, expandableFabSection) = createRefs()\n\n\n                    MappingMapsScreen(\n                        state = state,\n                        modifier = Modifier.constrainAs(mapScreen) {\n                            top.linkTo(parent.top)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                            bottom.linkTo(parent.bottom)\n                        },\n                        mapboxMap = mapboxMap,\n                        routeDirection = uiState.routeDirection,\n                        event = event,\n                        uiState = uiState,\n                        hazardousLaneMarkers = hazardousLaneMarkers\n                    )\n\n\n                    Timber.v(\"Banner Status: ${uiState.mapSelectedRescuee != null && bottomSheetScaffoldState.bottomSheetState.isCollapsed}\")\n\n\n                    AnimatedVisibility(\n                        visible = uiState.mapSelectedRescuee != null && bottomSheetScaffoldState.bottomSheetState.isCollapsed,\n                        enter = expandVertically(expandFrom = Alignment.Top) { 20 },\n                        exit = shrinkVertically(animationSpec = tween()) { fullHeight ->\n                            fullHeight / 2\n                        },\n                    ) {\n                        if (uiState.mapSelectedRescuee != null) {\n                            MappingExpandableBanner(\n                                modifier = Modifier\n                                    .padding(all = 6.dp)\n                                    .fillMaxWidth(), banner = uiState.mapSelectedRescuee,\n                                onClickDismissButton = { event(MappingUiEvent.DismissBanner) })\n                        }\n                    }\n\n                    FloatingButtonSection(\n                        modifier = Modifier\n                            .constrainAs(fabSection) {\n                                end.linkTo(parent.end, margin = 8.dp)\n                                bottom.linkTo(\n                                    parent.bottom,\n                                    margin = (configuration.screenHeightDp / 2.5).dp)\n                                top.linkTo(parent.top, margin = 15.dp)\n                                height = Dimension.fillToConstraints\n\n                            },\n                        locationPermissionGranted = locationPermissionState.allPermissionsGranted,\n                        onClickLocateUserButton = { event(MappingUiEvent.LocateUser) },\n                        onClickRouteOverviewButton = { event(MappingUiEvent.RouteOverview) },\n                        onClickRecenterButton = { event(MappingUiEvent.RecenterRoute) },\n                        onClickOpenNavigationButton = { event(MappingUiEvent.OpenNavigation) },\n                        onClickLayerButton = {\n                            val mapTypeBottomSheetVisibility =\n                                bottomSheetScaffoldState.bottomSheetState.isExpanded && uiState.bottomSheetType == BottomSheetType.MapType.type\n                            event(MappingUiEvent.MapTypeBottomSheet(visibility = !mapTypeBottomSheetVisibility))\n                        },\n                        uiState = uiState\n                    )\n\n                    ExpandableFABSection(\n                        onClickEmergencyCall = { event(MappingUiEvent.EmergencyCallDialog(visibility = true)) },\n                        onClickFamilyTracker = { event(MappingUiEvent.OpenFamilyTracker) },\n                        onClickRescueRequest = { event(MappingUiEvent.RescueRequestDialog(visibility = true)) },\n                        onClickFab = { event(MappingUiEvent.ExpandableFab(expanded = !uiState.isFabExpanded)) },\n                        onClickBikeTracker = { event(MappingUiEvent.OpenSinoTrack) },\n                        isFabExpanded = uiState.isFabExpanded,\n                        badgeCount = respondentCount,\n                        modifier = Modifier.constrainAs(expandableFabSection) {\n                            end.linkTo(parent.end, margin = 8.dp)\n                            if (bottomSheetScaffoldState.bottomSheetState.isCollapsed) bottom.linkTo(\n                                parent.bottom,\n                                margin = 15.dp) else top.linkTo(fabSection.bottom, margin = 8.dp)\n                        }\n                    )\n\n\n                    val buttonVisible =\n                        uiState.isNavigating.not() && uiState.isFabExpanded.not() && bottomSheetScaffoldState.bottomSheetState.isCollapsed\n                    val requestHelpVisible = uiState.requestHelpButtonVisible && buttonVisible\n                    val respondToHelpVisible = uiState.requestHelpButtonVisible.not() && buttonVisible\n\n                    val requestPending = state.user.isRescueRequestPending(uiState.mapSelectedRescuee?.userId) == true\n\n                    RequestHelpButton(\n                        modifier = Modifier.constrainAs(requestHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        }, onClickRequestHelpButton = { event(MappingUiEvent.RequestHelp) },\n                        state = state,\n                        visible = requestHelpVisible\n\n                    )\n\n                    RespondToHelpButton(\n                        modifier = Modifier.constrainAs(respondToHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        },\n                        onClickRespondButton = { event(MappingUiEvent.RespondToHelp) },\n                        state = state,\n                        visible = respondToHelpVisible && !requestPending\n                    )\n\n\n                    CancelRespondButton(\n                        cancelRespond = { event(MappingUiEvent.CancelRespondHelp) },\n                        modifier = Modifier.constrainAs(respondToHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        },\n                        state = state,\n                        visible = respondToHelpVisible && requestPending)\n\n\n\n                    if (state.isLoading) {\n                        CircularProgressIndicator(\n                            modifier = Modifier.constrainAs(\n                                circularProgressbar) {\n                                top.linkTo(parent.top)\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                this.centerTo(parent)\n                            })\n                    }\n\n\n                    if (uiState.cancelSearchDialogVisible) {\n                        CancelSearchDialog(onDismissRequest = {\n                            event(MappingUiEvent.CancelSearchDialog(visibility = false))\n                        }, onClickOkay = {\n                            event(MappingUiEvent.SearchCancelled)\n                        }, modifier = Modifier.constrainAs(dialog) {\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                            bottom.linkTo(parent.bottom)\n                            width = Dimension.matchParent\n                            height = Dimension.wrapContent\n                            this.centerTo(parent)\n                        })\n                    }\n\n                    if (uiState.cancelOnGoingRescueDialogVisible) {\n                        CancelOnGoingRescueDialog(\n                            onDismissRequest = {\n                                event(MappingUiEvent.CancelOnGoingRescueDialog(visibility = false))\n                            },\n                            onClickOkay = { event(MappingUiEvent.CancelOnGoingRescue) },\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            })\n                    }\n\n\n\n                    if (uiState.isEmergencyCallDialogVisible) {\n                        EmergencyCallDialog(\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            },\n                            onDismiss = { event(MappingUiEvent.EmergencyCallDialog(visibility = false)) },\n                            emergencyCallModel = emergencyState.emergencyCallModel,\n                            onClick = {\n                                event(\n                                    MappingUiEvent.OnEmergencyCall(\n                                        it.phoneNumber\n                                    )\n                                )\n                            }, onAddContact = {\n                                event(MappingUiEvent.OnAddEmergencyContact)\n                                event(MappingUiEvent.EmergencyCallDialog(visibility = false))\n                            }\n\n                        )\n                    }\n\n                    if (uiState.deleteHazardousMarkerDialogVisible) {\n                        DeleteHazardousLaneMarkerDialog(\n                            onDismissRequest = {\n                                event(MappingUiEvent.HazardousLaneMarkerDialog(\n                                    visibility = false))\n                            },\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            },\n                            onClickConfirmButton = {\n                                event(MappingUiEvent.OnConfirmDeleteIncident)\n                                event(MappingUiEvent.HazardousLaneMarkerDialog(visibility = false))\n                            })\n                    }\n\n                    if (uiState.isNoInternetVisible) {\n                        NoInternetDialog(\n                            onDismiss = { event(MappingUiEvent.NoInternetDialog(visibility = false)) },\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            })\n                    }\n\n                    if (uiState.locationPermissionDialogVisible) {\n                        DialogForegroundLocationPermission(\n                            modifier = Modifier.constrainAs(\n                                dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismiss = { event(MappingUiEvent.LocationPermission(visibility = false)) }\n                        )\n                    }\n\n\n                    if (uiState.notificationPermissionVisible) {\n                        DialogNotificationPermission(\n                            modifier = Modifier.constrainAs(\n                                dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismiss = {\n                                event(\n                                    MappingUiEvent.NotificationPermissionDialog(\n                                        visibility = false))\n                            }\n                        )\n                    }\n\n\n\n                    if(uiState.alertDialogState.visible()){\n                        AlertDialog(\n                            alertDialog = uiState.alertDialogState,\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismissRequest = { event(MappingUiEvent.AlertDialog(alertDialogState = AlertDialogState())) })\n                    }\n\n                    if (uiState.discardHazardousMarkerDialogVisible) {\n                        DiscardHazardousLaneMarkerDialog(\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismissRequest = {\n                                event(MappingUiEvent.DiscardChangesMarkerDialog(visibility = false))\n                            },\n                            onClickDiscard = {\n                                event(MappingUiEvent.DiscardChangesMarkerDialog(visibility = false))\n                                event(MappingUiEvent.DiscardMarkerChanges)\n                            }\n                        )\n                    }\n\n                    AnimatedVisibility(\n                        visible = uiState.isRescueCancelled && uiState.rescueRequestAccepted.not(),\n                        enter = fadeIn(),\n                        exit = fadeOut(animationSpec = tween(durationMillis = 220))) {\n\n                        val rescueTransaction = state.rescueTransaction ?: return@AnimatedVisibility\n\n                        MappingRequestCancelled(\n                            modifier = Modifier.fillMaxSize()\n                            ,\n                            onClickOkButton = { event(MappingUiEvent.CancelledRescueConfirmed) },\n                            cancelledRescueModel = CancelledRescueModel(\n                                transactionID = rescueTransaction.id,\n                                rescueCancelledBy = rescueTransaction.getCancellationName(),\n                                reason = rescueTransaction.getCancellationReason(),\n                                message = rescueTransaction.getCancellationMessage()\n                            ))\n                    }\n\n                    AnimatedVisibility(\n                        visible = uiState.rescueRequestAccepted && uiState.isRescueCancelled.not(),\n                        enter = fadeIn(),\n                        exit = fadeOut(animationSpec = tween(durationMillis = 220))) {\n                        MappingRequestAccepted(\n                            modifier = Modifier.fillMaxSize(),\n                            onClickOkButton = { event(MappingUiEvent.RescueRequestAccepted) },\n                            acceptedName = state.rescuee?.name ?: \"Name placeholder\",\n                        )\n                    }\n                }\n            }\n\n\n\n\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt	(date 1696833185696)
@@ -62,7 +62,6 @@
 import com.google.accompanist.permissions.MultiplePermissionsState
 import com.google.accompanist.permissions.rememberMultiplePermissionsState
 import com.mapbox.mapboxsdk.maps.MapboxMap
-import timber.log.Timber
 
 
 @OptIn(ExperimentalPermissionsApi::class, ExperimentalMaterialApi::class)
@@ -174,7 +173,6 @@
                     )
 
 
-                    Timber.v("Banner Status: ${uiState.mapSelectedRescuee != null && bottomSheetScaffoldState.bottomSheetState.isCollapsed}")
 
 
                     AnimatedVisibility(
Index: app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/MessagingUseCase.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_messaging.domain.use_case\n\nimport com.example.cyclistance.feature_messaging.domain.use_case.conversion.AddConversionUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.conversion.GetConversionIdUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.conversion.UpdateConversionUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetMessagingUserUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetUidUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.manage_user.UpdateUserAvailability\nimport com.example.cyclistance.feature_messaging.domain.use_case.message.AddMessageListenerUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.message.RemoveMessageListenerUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.message.SendMessageUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.network.ReEnableNetworkSyncUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.notification.SendNotificationUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.seen.MarkAsSeenUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.token.DeleteTokenUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.token.RefreshTokenUseCase\n\ndata class MessagingUseCase(\n    val refreshTokenUseCase: RefreshTokenUseCase,\n    val deleteTokenUseCase: DeleteTokenUseCase,\n    val sendMessageUseCase: SendMessageUseCase,\n    val addMessageListenerUseCase: AddMessageListenerUseCase,\n    val removeMessageListenerUseCase: RemoveMessageListenerUseCase,\n    val getUidUseCase: GetUidUseCase,\n    val getConversionIdUseCase: GetConversionIdUseCase,\n    val addConversionUseCase: AddConversionUseCase,\n    val updateConversionUseCase: UpdateConversionUseCase,\n    val updateUserAvailability: UpdateUserAvailability,\n    val sendNotificationUseCase: SendNotificationUseCase,\n    val getMessagingUserUseCase: GetMessagingUserUseCase,\n    val reEnableNetworkSyncUseCase: ReEnableNetworkSyncUseCase,\n    val markAsSeenUseCase: MarkAsSeenUseCase\n)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/MessagingUseCase.kt b/app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/MessagingUseCase.kt
--- a/app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/MessagingUseCase.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_messaging/domain/use_case/MessagingUseCase.kt	(date 1696832001146)
@@ -5,7 +5,6 @@
 import com.example.cyclistance.feature_messaging.domain.use_case.conversion.UpdateConversionUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetMessagingUserUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetUidUseCase
-import com.example.cyclistance.feature_messaging.domain.use_case.manage_user.UpdateUserAvailability
 import com.example.cyclistance.feature_messaging.domain.use_case.message.AddMessageListenerUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.message.RemoveMessageListenerUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.message.SendMessageUseCase
@@ -25,7 +24,6 @@
     val getConversionIdUseCase: GetConversionIdUseCase,
     val addConversionUseCase: AddConversionUseCase,
     val updateConversionUseCase: UpdateConversionUseCase,
-    val updateUserAvailability: UpdateUserAvailability,
     val sendNotificationUseCase: SendNotificationUseCase,
     val getMessagingUserUseCase: GetMessagingUserUseCase,
     val reEnableNetworkSyncUseCase: ReEnableNetworkSyncUseCase,
Index: app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_in/SignInViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_authentication.presentation.auth_sign_in\n\nimport android.content.Intent\nimport androidx.lifecycle.SavedStateHandle\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.cyclistance.core.domain.model.UserDetails\nimport com.example.cyclistance.core.utils.constants.AuthConstants.FACEBOOK_CONNECTION_FAILURE\nimport com.example.cyclistance.core.utils.constants.AuthConstants.SIGN_IN_VM_STATE_KEY\nimport com.example.cyclistance.feature_authentication.domain.exceptions.AuthExceptions\nimport com.example.cyclistance.feature_authentication.domain.model.AuthModel\nimport com.example.cyclistance.feature_authentication.domain.model.SignInCredential\nimport com.example.cyclistance.feature_authentication.domain.use_case.AuthenticationUseCase\nimport com.example.cyclistance.feature_authentication.domain.util.ActivityResultCallbackI\nimport com.example.cyclistance.feature_authentication.presentation.auth_sign_in.event.SignInEvent\nimport com.example.cyclistance.feature_authentication.presentation.auth_sign_in.event.SignInVmEvent\nimport com.example.cyclistance.feature_authentication.presentation.auth_sign_in.state.SignInState\nimport com.example.cyclistance.feature_messaging.domain.use_case.MessagingUseCase\nimport com.facebook.AccessToken\nimport com.facebook.CallbackManager\nimport com.facebook.FacebookCallback\nimport com.facebook.FacebookException\nimport com.facebook.login.LoginManager\nimport com.facebook.login.LoginResult\nimport dagger.hilt.android.lifecycle.HiltViewModel\nimport kotlinx.coroutines.CoroutineDispatcher\nimport kotlinx.coroutines.Job\nimport kotlinx.coroutines.flow.MutableSharedFlow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.SharedFlow\nimport kotlinx.coroutines.flow.asSharedFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.flow.update\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\nimport javax.inject.Inject\n\n\n@HiltViewModel\nclass SignInViewModel @Inject constructor(\n    private val savedStateHandle: SavedStateHandle,\n    private val authUseCase: AuthenticationUseCase,\n    private val messagingUseCase: MessagingUseCase,\n    private val defaultDispatcher: CoroutineDispatcher\n) : ViewModel(), ActivityResultCallbackI {\n\n    private var job: Job? = null\n    private var callbackManager = CallbackManager.Factory.create()\n\n    private val _state: MutableStateFlow<SignInState> =\n        MutableStateFlow(savedStateHandle[SIGN_IN_VM_STATE_KEY] ?: SignInState())\n    val state = _state.asStateFlow()\n\n    private val _eventFlow: MutableSharedFlow<SignInEvent> = MutableSharedFlow()\n    val eventFlow: SharedFlow<SignInEvent> = _eventFlow.asSharedFlow()\n\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?): Boolean {\n        return callbackManager.onActivityResult(requestCode, resultCode, data)\n    }\n\n    init {\n        registerFacebookSignInCallback()\n        removeFacebookUserAccountPreviousToken()\n    }\n\n    fun onEvent(event: SignInVmEvent) {\n\n        when (event) {\n            is SignInVmEvent.SignInFacebook -> {\n\n                _state.update { it.copy(isLoading = true) }\n                event.activity?.let {\n                    LoginManager.getInstance()\n                        .logInWithReadPermissions(\n                            it,\n                            listOf(\"email\", \"public_profile\", \"user_friends\"))\n                }\n            }\n\n            is SignInVmEvent.SignInGoogle -> {\n                signInWithCredential(event.authCredential)\n            }\n\n            is SignInVmEvent.SignInWithEmailAndPassword -> {\n                signInWithEmailAndPassword(email = event.email, password = event.password)\n            }\n\n            is SignInVmEvent.AgreedToPrivacyPolicy -> {\n                _state.update { it.copy(userAgreedToPrivacyPolicy = true) }\n            }\n\n        }\n        savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n    }\n\n\n    private fun signInWithEmailAndPassword(email: String, password: String) {\n\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                _state.update { it.copy(isLoading = true) }\n                with(state.value) {\n                    authUseCase.signInWithEmailAndPasswordUseCase(\n                        authModel = AuthModel(\n                            email = email.trim(),\n                            password = password.trim()))\n                }\n\n            }.onSuccess { isSuccess ->\n                _state.update { it.copy(isLoading = false) }\n                if (isSuccess) {\n                    _eventFlow.emit(SignInEvent.RefreshEmail)\n                } else {\n                    _eventFlow.emit(SignInEvent.SignInFailed())\n                }\n            }.onFailure { exception ->\n                _state.update { it.copy(isLoading = false) }\n                handleException(exception)\n            }\n        }.invokeOnCompletion {\n            savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n        }\n    }\n\n\n    private fun createUser(user: UserDetails) {\n        viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                _state.update { it.copy(isLoading = true) }\n                authUseCase.createUserUseCase(user = user)\n            }.onSuccess {\n                _state.update { it.copy(isLoading = false) }\n                messagingUseCase.updateUserAvailability(true)\n            }.onFailure { exception ->\n                _state.update { it.copy(isLoading = false) }\n                handleException(exception)\n            }\n        }.apply {\n            invokeOnCompletion {\n                savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n\n    private fun signInWithCredential(authCredential: SignInCredential) {\n        job?.cancel()\n        job = viewModelScope.launch(context = defaultDispatcher) {\n            runCatching {\n                _state.update { it.copy(isLoading = true) }\n                authUseCase.signInWithCredentialUseCase(authCredential)\n            }.onSuccess { task ->\n                _state.update { it.copy(isLoading = false) }\n                if (task.isSuccessful) {\n                    createUser(task.user)\n                    _eventFlow.emit(SignInEvent.SignInSuccess)\n                }\n            }.onFailure { exception ->\n                _state.update { it.copy(isLoading = false) }\n                handleException(exception)\n            }\n        }.apply {\n            invokeOnCompletion {\n                savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n            }\n        }\n    }\n\n    private suspend fun handleException(exception: Throwable) {\n        when (exception) {\n            is AuthExceptions.EmailException -> {\n                _eventFlow.emit(\n                    value = SignInEvent.InvalidEmail(\n                        exception.message ?: \"Email is Invalid.\"))\n            }\n\n            is AuthExceptions.NewPasswordException -> {\n                _eventFlow.emit(\n                    value = SignInEvent.InvalidPassword(\n                        exception.message ?: \"Password is Invalid.\"))\n            }\n\n            is AuthExceptions.TooManyRequestsException -> {\n                _eventFlow.emit(value = SignInEvent.AccountBlockedTemporarily)\n            }\n\n            is AuthExceptions.NetworkException -> {\n                _eventFlow.emit(value = SignInEvent.NoInternetConnection)\n            }\n\n            is AuthExceptions.ConflictFBTokenException -> {\n                removeFacebookUserAccountPreviousToken()\n                _eventFlow.emit(value = SignInEvent.ConflictFbToken)\n            }\n\n            is AuthExceptions.AccountDisabledException -> {\n                _eventFlow.emit(value = SignInEvent.AccountDisabled(exception.message ?: \"\"))\n            }\n\n            else -> {\n                Timber.e(\"${this@SignInViewModel.javaClass.name}: ${exception.message}\")\n            }\n        }\n        savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n    }\n\n    // TODO: move to repository\n    private fun registerFacebookSignInCallback() {\n        LoginManager.getInstance().registerCallback(\n            callbackManager,\n            object : FacebookCallback<LoginResult> {\n                override fun onSuccess(result: LoginResult) {\n                    _state.update { it.copy(isLoading = true) }\n                    signInWithCredential(authCredential = SignInCredential.Facebook(providerToken = result.accessToken.token))\n                    savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n                }\n\n                override fun onCancel() {\n                    _state.update { it.copy(isLoading = false) }\n                    savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n                    Timber.e(\"facebook:onCancel\")\n                }\n\n                override fun onError(error: FacebookException) {\n                    _state.update { it.copy(isLoading = false) }\n                    viewModelScope.launch(context = defaultDispatcher) {\n                        error.handleFacebookSignInException()\n                    }.invokeOnCompletion {\n                        savedStateHandle[SIGN_IN_VM_STATE_KEY] = state.value\n                    }\n                }\n            }\n        )\n    }\n\n\n    private suspend fun Exception.handleFacebookSignInException() {\n\n        if (message == FACEBOOK_CONNECTION_FAILURE) {\n            _eventFlow.emit(value = SignInEvent.NoInternetConnection)\n            return\n        }\n        message?.let {\n            _eventFlow.emit(value = SignInEvent.FacebookSignInFailed)\n            removeFacebookUserAccountPreviousToken()\n        }\n    }\n\n    //todo move this to repository\n    private fun removeFacebookUserAccountPreviousToken() {\n        val token = AccessToken.getCurrentAccessToken()\n        if (token != null && !token.isExpired) {\n            LoginManager.getInstance().logOut()\n        }\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        LoginManager.getInstance().unregisterCallback(callbackManager)\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_in/SignInViewModel.kt b/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_in/SignInViewModel.kt
--- a/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_in/SignInViewModel.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_authentication/presentation/auth_sign_in/SignInViewModel.kt	(date 1696832833803)
@@ -131,7 +131,9 @@
                 authUseCase.createUserUseCase(user = user)
             }.onSuccess {
                 _state.update { it.copy(isLoading = false) }
-                messagingUseCase.updateUserAvailability(true)
+                _eventFlow.emit(SignInEvent.SignInSuccess)
+
+
             }.onFailure { exception ->
                 _state.update { it.copy(isLoading = false) }
                 handleException(exception)
@@ -154,8 +156,8 @@
                 _state.update { it.copy(isLoading = false) }
                 if (task.isSuccessful) {
                     createUser(task.user)
-                    _eventFlow.emit(SignInEvent.SignInSuccess)
                 }
+
             }.onFailure { exception ->
                 _state.update { it.copy(isLoading = false) }
                 handleException(exception)
Index: app/google-services.json
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>{\n  \"project_info\": {\n    \"project_number\": \"297531421452\",\n    \"project_id\": \"cyclistance-cc715\",\n    \"storage_bucket\": \"cyclistance-cc715.appspot.com\"\n  },\n  \"client\": [\n    {\n      \"client_info\": {\n        \"mobilesdk_app_id\": \"1:297531421452:android:9599135169f47aa3208f29\",\n        \"android_client_info\": {\n          \"package_name\": \"com.example.cyclistance\"\n        }\n      },\n      \"oauth_client\": [\n        {\n          \"client_id\": \"297531421452-je1s63qvqb60neb5si46boorgk7mcapi.apps.googleusercontent.com\",\n          \"client_type\": 1,\n          \"android_info\": {\n            \"package_name\": \"com.example.cyclistance\",\n            \"certificate_hash\": \"7239184e5f13f736b14b170d046d139407ee715c\"\n          }\n        },\n        {\n          \"client_id\": \"297531421452-7kefpj7sm6rta6crg3u8k81uij5mg2ti.apps.googleusercontent.com\",\n          \"client_type\": 3\n        }\n      ],\n      \"api_key\": [\n        {\n          \"current_key\": \"AIzaSyBK1yc4oocYBKvlp-7FaJ2dCG_r1ZfrMBk\"\n        }\n      ],\n      \"services\": {\n        \"appinvite_service\": {\n          \"other_platform_oauth_client\": [\n            {\n              \"client_id\": \"297531421452-7kefpj7sm6rta6crg3u8k81uij5mg2ti.apps.googleusercontent.com\",\n              \"client_type\": 3\n            }\n          ]\n        }\n      }\n    },\n    {\n      \"client_info\": {\n        \"mobilesdk_app_id\": \"1:297531421452:android:6583ec0eea1b259c208f29\",\n        \"android_client_info\": {\n          \"package_name\": \"com.example.jetpack_testing\"\n        }\n      },\n      \"oauth_client\": [\n        {\n          \"client_id\": \"297531421452-7kefpj7sm6rta6crg3u8k81uij5mg2ti.apps.googleusercontent.com\",\n          \"client_type\": 3\n        }\n      ],\n      \"api_key\": [\n        {\n          \"current_key\": \"AIzaSyBK1yc4oocYBKvlp-7FaJ2dCG_r1ZfrMBk\"\n        }\n      ],\n      \"services\": {\n        \"appinvite_service\": {\n          \"other_platform_oauth_client\": [\n            {\n              \"client_id\": \"297531421452-7kefpj7sm6rta6crg3u8k81uij5mg2ti.apps.googleusercontent.com\",\n              \"client_type\": 3\n            }\n          ]\n        }\n      }\n    }\n  ],\n  \"configuration_version\": \"1\"\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/google-services.json b/app/google-services.json
--- a/app/google-services.json	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/google-services.json	(date 1696764018643)
@@ -1,6 +1,7 @@
 {
   "project_info": {
     "project_number": "297531421452",
+    "firebase_url": "https://cyclistance-cc715-default-rtdb.asia-southeast1.firebasedatabase.app",
     "project_id": "cyclistance-cc715",
     "storage_bucket": "cyclistance-cc715.appspot.com"
   },
@@ -22,35 +23,6 @@
           }
         },
         {
-          "client_id": "297531421452-7kefpj7sm6rta6crg3u8k81uij5mg2ti.apps.googleusercontent.com",
-          "client_type": 3
-        }
-      ],
-      "api_key": [
-        {
-          "current_key": "AIzaSyBK1yc4oocYBKvlp-7FaJ2dCG_r1ZfrMBk"
-        }
-      ],
-      "services": {
-        "appinvite_service": {
-          "other_platform_oauth_client": [
-            {
-              "client_id": "297531421452-7kefpj7sm6rta6crg3u8k81uij5mg2ti.apps.googleusercontent.com",
-              "client_type": 3
-            }
-          ]
-        }
-      }
-    },
-    {
-      "client_info": {
-        "mobilesdk_app_id": "1:297531421452:android:6583ec0eea1b259c208f29",
-        "android_client_info": {
-          "package_name": "com.example.jetpack_testing"
-        }
-      },
-      "oauth_client": [
-        {
           "client_id": "297531421452-7kefpj7sm6rta6crg3u8k81uij5mg2ti.apps.googleusercontent.com",
           "client_type": 3
         }
Index: app/src/main/java/com/example/cyclistance/feature_authentication/data/repository/AuthRepositoryImpl.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_authentication.data.repository\n\nimport android.content.Context\nimport com.example.cyclistance.R\nimport com.example.cyclistance.core.domain.model.UserDetails\nimport com.example.cyclistance.core.utils.connection.ConnectionStatus.hasInternetConnection\nimport com.example.cyclistance.core.utils.constants.AuthConstants.FACEBOOK_CONNECTION_FAILURE\nimport com.example.cyclistance.core.utils.constants.AuthConstants.USER_ACCOUNT_DISABLED\nimport com.example.cyclistance.core.utils.constants.AuthConstants.USER_NOT_FOUND\nimport com.example.cyclistance.core.utils.constants.UtilConstants.USER_COLLECTION\nimport com.example.cyclistance.feature_authentication.data.mapper.AuthResultMapper.toAuthenticationResult\nimport com.example.cyclistance.feature_authentication.domain.exceptions.AuthExceptions\nimport com.example.cyclistance.feature_authentication.domain.model.AuthenticationResult\nimport com.example.cyclistance.feature_authentication.domain.model.SignInCredential\nimport com.example.cyclistance.feature_authentication.domain.repository.AuthRepository\nimport com.google.firebase.FirebaseNetworkException\nimport com.google.firebase.FirebaseTooManyRequestsException\nimport com.google.firebase.auth.EmailAuthProvider\nimport com.google.firebase.auth.FacebookAuthProvider\nimport com.google.firebase.auth.FirebaseAuth\nimport com.google.firebase.auth.FirebaseAuthInvalidCredentialsException\nimport com.google.firebase.auth.FirebaseAuthInvalidUserException\nimport com.google.firebase.auth.FirebaseAuthUserCollisionException\nimport com.google.firebase.auth.FirebaseAuthWeakPasswordException\nimport com.google.firebase.auth.GoogleAuthProvider\nimport com.google.firebase.firestore.FirebaseFirestore\nimport kotlinx.coroutines.CancellableContinuation\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.suspendCancellableCoroutine\nimport kotlinx.coroutines.withContext\nimport timber.log.Timber\nimport kotlin.coroutines.CoroutineContext\nimport kotlin.coroutines.resume\nimport kotlin.coroutines.resumeWithException\n\n\nclass AuthRepositoryImpl(\n    private val appContext: Context,\n    private val auth: FirebaseAuth,\n    private val fireStore: FirebaseFirestore,\n    private val scope: CoroutineContext = Dispatchers.IO\n) : AuthRepository {\n\n\n    override suspend fun createUser(user: UserDetails) {\n\n        checkInternetConnection()\n\n        suspendCancellableCoroutine { continuation ->\n            fireStore.document(\"${USER_COLLECTION}/${user.uid}\").set(user).addOnSuccessListener {\n                Timber.v(\"User created successfully\")\n                continuation.resume(Unit)\n            }.addOnFailureListener { exception ->\n\n                if (exception is FirebaseNetworkException) {\n                    continuation.resumeWithException(\n                        AuthExceptions.NetworkException(\n                            message = appContext.getString(\n                                R.string.no_internet_message)))\n                }\n\n                continuation.resumeWithException(\n                    AuthExceptions.CreateUserException(\n                        message = appContext.getString(R.string.failed_create_user)))\n            }\n\n        }\n    }\n\n    private fun checkInternetConnection() {\n        if (!appContext.hasInternetConnection()) {\n            throw AuthExceptions.NetworkException(message = appContext.getString(R.string.no_internet_message))\n        }\n    }\n\n    override suspend fun reloadEmail(): Boolean {\n        return withContext(scope) {\n            suspendCancellableCoroutine { continuation ->\n                auth.currentUser?.reload()?.addOnCompleteListener { reload ->\n                    reload.exception?.let { exception ->\n                        if (exception is FirebaseNetworkException) {\n                            continuation.resumeWithException(\n                                AuthExceptions.NetworkException(\n                                    message = appContext.getString(\n                                        R.string.no_internet_message)))\n                        }\n                    }\n                    if (continuation.isActive) {\n                        continuation.resume(reload.isSuccessful)\n                    }\n                }\n            }\n        }\n    }\n\n    override suspend fun sendEmailVerification(): Boolean {\n        return withContext(scope) {\n\n            suspendCancellableCoroutine { continuation ->\n                auth.currentUser?.sendEmailVerification()?.addOnCompleteListener { sendEmail ->\n                    sendEmail.exception?.let {\n                        continuation.resumeWithException(\n                            AuthExceptions.EmailVerificationException(\n                                message = appContext.getString(\n                                    R.string.failed_email_verification)))\n                    }\n                    if (continuation.isActive) {\n                        continuation.resume(sendEmail.isSuccessful)\n                    }\n                }\n            }\n        }\n    }\n\n    override suspend fun createUserWithEmailAndPassword(\n        email: String,\n        password: String): AuthenticationResult? {\n\n        checkInternetConnection()\n\n        return withContext(scope) {\n            suspendCancellableCoroutine { continuation ->\n                auth.createUserWithEmailAndPassword(email.trim(), password.trim())\n                    .addOnCompleteListener { task ->\n                        task.exception?.let { exception ->\n                            continuation.handleCreateUserWithEmailAndPassword(exception)\n                            return@addOnCompleteListener\n                        }\n                        if (continuation.isActive) {\n\n                            continuation.resume(task.toAuthenticationResult())\n                        }\n                    }\n            }\n        }\n    }\n\n\n    override suspend fun signInWithEmailAndPassword(\n        email: String,\n        password: String): Boolean {\n\n        checkInternetConnection()\n\n        return withContext(scope) {\n            suspendCancellableCoroutine { continuation ->\n                auth.signInWithEmailAndPassword(email.trim(), password.trim())\n                    .addOnCompleteListener { task ->\n\n                        task.exception?.let {\n                            continuation.handleSignInWithEmailAndPasswordException(exception = it)\n                            return@addOnCompleteListener\n                        }\n\n                        if (continuation.isActive) {\n                            continuation.resume(task.isSuccessful)\n                        }\n                    }\n            }\n        }\n    }\n\n\n    private fun CancellableContinuation<AuthenticationResult?>.handleCreateUserWithEmailAndPassword(\n        exception: Exception) {\n        if (exception is FirebaseNetworkException) {\n            resumeWithException(\n                AuthExceptions.NetworkException(\n                    message = appContext.getString(\n                        R.string.no_internet_message)))\n            return\n        }\n\n        if (exception is FirebaseAuthUserCollisionException) {\n            resumeWithException(\n                AuthExceptions.UserAlreadyExistsException(\n                    title = appContext.getString(R.string.userAlreadyExists),\n                    message = appContext.getString(R.string.accountAlreadyInUse)))\n            return\n        }\n        resumeWithException(exception)\n    }\n\n\n    private fun CancellableContinuation<Boolean>.handleSignInWithEmailAndPasswordException(\n        exception: Exception) {\n        if (exception is FirebaseNetworkException) {\n            resumeWithException(\n                AuthExceptions.NetworkException(\n                    message = appContext.getString(\n                        R.string.no_internet_message)))\n            return\n        }\n\n        if (exception is FirebaseAuthInvalidCredentialsException) {\n            resumeWithException(\n                AuthExceptions.NewPasswordException(\n                    message = appContext.getString(\n                        R.string.incorrectPasswordMessage)))\n            return\n        }\n\n        if (exception is FirebaseAuthInvalidUserException) {\n            if (exception.errorCode == USER_NOT_FOUND) {\n                resumeWithException(\n                    AuthExceptions.EmailException(\n                        message = appContext.getString(\n                            R.string.couldntFindAccount)))\n                return\n            }\n\n            if (exception.errorCode == USER_ACCOUNT_DISABLED){\n                resumeWithException(\n                    AuthExceptions.AccountDisabledException(\n                        message = exception.message ?: \"Account is disabled please contact support.\"))\n                return\n            }\n        }\n\n        if (exception is FirebaseTooManyRequestsException) {\n            resumeWithException(\n                AuthExceptions.TooManyRequestsException(\n                    title = appContext.getString(\n                        R.string.tooManyFailedAttempts),\n                    message = appContext.getString(R.string.manyFailedAttempts)))\n            return\n        }\n\n        if (exception is IllegalStateException) {\n            Timber.e(exception.message)\n        }\n\n        resumeWithException(exception)\n    }\n\n    override suspend fun signInWithCredential(credential: SignInCredential): AuthenticationResult {\n        return withContext(scope) {\n            suspendCancellableCoroutine { continuation ->\n\n                val signInCredential = when (credential) {\n                    is SignInCredential.Google -> GoogleAuthProvider.getCredential(\n                        credential.providerToken,\n                        null)\n\n                    is SignInCredential.Facebook -> FacebookAuthProvider.getCredential(credential.providerToken)\n                }\n\n\n                auth.signInWithCredential(signInCredential)\n                    .addOnCompleteListener { task ->\n\n                        task.exception?.let { exception ->\n                            if (exception.message == FACEBOOK_CONNECTION_FAILURE) {\n                                continuation.resumeWithException(\n                                    AuthExceptions.NetworkException(\n                                        message = appContext.getString(\n                                            R.string.no_internet_message)))\n                            }\n\n                            if (exception is FirebaseNetworkException) {\n                                continuation.resumeWithException(\n                                    AuthExceptions.NetworkException(\n                                        message = appContext.getString(R.string.no_internet_message)))\n                                return@addOnCompleteListener\n                            }\n\n                            continuation.resumeWithException(\n                                AuthExceptions.ConflictFBTokenException(\n                                    exception.message\n                                    ?: \"Sorry, something went wrong. Please try again.\"))\n                        }\n                        if (continuation.isActive) {\n                            continuation.resume(task.toAuthenticationResult())\n                        }\n                    }\n            }\n        }\n    }\n\n    override fun signOut() {\n        auth.signOut()\n    }\n\n    override fun getId(): String? {\n        return auth.currentUser?.uid\n    }\n\n    override fun getEmail(): String? {\n        return auth.currentUser?.email\n    }\n\n\n    override fun isSignedInWithProvider(): Boolean? {\n        return auth.currentUser?.providerData?.any {\n            it.providerId == FacebookAuthProvider.PROVIDER_ID ||\n            it.providerId == GoogleAuthProvider.PROVIDER_ID\n        }\n    }\n\n    override fun isEmailVerified(): Boolean? {\n        return auth.currentUser?.isEmailVerified\n    }\n\n    override fun hasAccountSignedIn(): Boolean {\n        return auth.currentUser != null\n    }\n\n    override suspend fun sendPasswordResetEmail(email: String) {\n        checkInternetConnection()\n        suspendCancellableCoroutine { continuation ->\n            auth.sendPasswordResetEmail(email).addOnSuccessListener {\n                continuation.resume(Unit)\n            }.addOnFailureListener { exception ->\n                if (exception is FirebaseNetworkException) {\n                    continuation.resumeWithException(\n                        AuthExceptions.NetworkException(\n                            message = appContext.getString(\n                                R.string.no_internet_message)))\n                }\n                if (exception is FirebaseAuthInvalidUserException) {\n                    if (exception.errorCode == USER_NOT_FOUND) {\n                        continuation.resumeWithException(\n                            AuthExceptions.EmailException(\n                                message = appContext.getString(\n                                    R.string.couldntFindAccount)))\n                    }\n                }\n            }\n        }\n    }\n\n    override suspend fun changePassword(currentPassword: String, confirmPassword: String) {\n        checkInternetConnection()\n\n\n        val user = auth.currentUser\n        val email = auth.currentUser?.email\n        val credential = EmailAuthProvider.getCredential(email!!, currentPassword)\n\n        suspendCancellableCoroutine { continuation ->\n\n            user?.reauthenticate(credential)?.addOnSuccessListener {\n                user.updatePassword(confirmPassword).addOnSuccessListener {\n                    continuation.resume(Unit)\n                }.addOnFailureListener { exception ->\n\n                    if (exception is FirebaseAuthWeakPasswordException) {\n                        continuation.resumeWithException(\n                            AuthExceptions.ConfirmPasswordException(\n                                message = exception.message\n                                          ?: \"Password must be at least 8 characters long.\"))\n                    }\n\n                    if (exception is FirebaseAuthInvalidUserException) {\n                        if (exception.errorCode == USER_NOT_FOUND) {\n                            continuation.resumeWithException(\n                                AuthExceptions.CurrentPasswordException(\n                                    message = appContext.getString(\n                                        R.string.couldntFindAccount)))\n                        }\n                    }\n\n\n                }\n            }?.addOnFailureListener { exception ->\n\n                if (exception is FirebaseAuthInvalidUserException) {\n                    if (exception.errorCode == USER_NOT_FOUND) {\n                        continuation.resumeWithException(\n                            AuthExceptions.CurrentPasswordException(\n                                message = appContext.getString(\n                                    R.string.couldntFindAccount)))\n                    }\n                }\n\n\n                if (exception is FirebaseAuthInvalidCredentialsException) {\n                    continuation.resumeWithException(\n                        AuthExceptions.CurrentPasswordException(\n                            message = appContext.getString(\n                                R.string.incorrectPasswordMessage)))\n                }\n\n            }\n\n        }\n\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_authentication/data/repository/AuthRepositoryImpl.kt b/app/src/main/java/com/example/cyclistance/feature_authentication/data/repository/AuthRepositoryImpl.kt
--- a/app/src/main/java/com/example/cyclistance/feature_authentication/data/repository/AuthRepositoryImpl.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_authentication/data/repository/AuthRepositoryImpl.kt	(date 1696828226993)
@@ -47,7 +47,13 @@
         checkInternetConnection()
 
         suspendCancellableCoroutine { continuation ->
-            fireStore.document("${USER_COLLECTION}/${user.uid}").set(user).addOnSuccessListener {
+            fireStore
+                .document("${USER_COLLECTION}/${user.uid}")
+                .set(user)
+                .addOnCanceledListener {
+                 Timber.v("User creation cancelled")
+                }
+                .addOnSuccessListener {
                 Timber.v("User created successfully")
                 continuation.resume(Unit)
             }.addOnFailureListener { exception ->
Index: app/src/main/java/com/example/cyclistance/di/authentication/AuthSingletonModule.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.di.authentication\n\nimport com.example.cyclistance.BuildConfig\nimport com.example.cyclistance.feature_authentication.domain.use_case.create_account.*\nimport com.example.cyclistance.feature_authentication.domain.use_case.read_account.*\nimport com.example.cyclistance.feature_authentication.domain.use_case.verify_account.*\nimport com.google.firebase.auth.FirebaseAuth\nimport com.google.firebase.firestore.FirebaseFirestore\nimport com.google.firebase.firestore.FirebaseFirestoreSettings\nimport com.google.firebase.firestore.ktx.firestore\nimport com.google.firebase.ktx.Firebase\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.components.SingletonComponent\nimport javax.inject.Singleton\n\n@Module\n@InstallIn(SingletonComponent::class)\nobject AuthSingletonModule {\n\n    //emulator host = 10.0.2.2\n    @Provides\n    @Singleton\n    fun provideFirebaseAuth(): FirebaseAuth {\n        return FirebaseAuth.getInstance().apply {\n            if (BuildConfig.DEBUG) {\n                useEmulator(\"192.168.18.21\", 9099)\n            }\n        }\n    }\n\n\n    @Provides\n    @Singleton\n    fun provideFirebaseFireStore(): FirebaseFirestore {\n\n        val settings = FirebaseFirestoreSettings.Builder()\n            .setPersistenceEnabled(true)\n            .setCacheSizeBytes(FirebaseFirestoreSettings.CACHE_SIZE_UNLIMITED)\n            .build()\n        return Firebase.firestore.apply {\n            if (BuildConfig.DEBUG) {\n                useEmulator(\"192.168.18.21\", 9299)\n            }\n            firestoreSettings = settings\n        }\n    }\n\n\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/di/authentication/AuthSingletonModule.kt b/app/src/main/java/com/example/cyclistance/di/authentication/AuthSingletonModule.kt
--- a/app/src/main/java/com/example/cyclistance/di/authentication/AuthSingletonModule.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/di/authentication/AuthSingletonModule.kt	(date 1696826146596)
@@ -25,7 +25,7 @@
     fun provideFirebaseAuth(): FirebaseAuth {
         return FirebaseAuth.getInstance().apply {
             if (BuildConfig.DEBUG) {
-                useEmulator("192.168.18.21", 9099)
+//                useEmulator("192.168.18.21", 9099)
             }
         }
     }
@@ -41,7 +41,7 @@
             .build()
         return Firebase.firestore.apply {
             if (BuildConfig.DEBUG) {
-                useEmulator("192.168.18.21", 9299)
+//                useEmulator("192.168.18.21", 9299)
             }
             firestoreSettings = settings
         }
Index: app/build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\nimport org.jetbrains.kotlin.gradle.tasks.KotlinCompile\nimport java.io.FileInputStream\nimport java.util.Properties\n\nval compose_version = \"1.3.1\"\nval kotlin_version = \"1.9.10\"\nplugins {\n    id(\"com.android.application\")\n    kotlin(\"android\")\n    id(\"dagger.hilt.android.plugin\")\n    id(\"com.google.gms.google-services\")\n    id(\"kotlin-parcelize\")\n    id(\"com.google.dagger.hilt.android\")\n    id(\"com.google.firebase.crashlytics\")\n    id(\"com.google.devtools.ksp\")\n}\napply(plugin = \"com.android.application\")\napply(plugin = \"dagger.hilt.android.plugin\")\napply(plugin = \"com.google.firebase.crashlytics\")\napply(plugin = \"kotlin-parcelize\")\nandroid {\n    compileSdk = 34\n\n    defaultConfig {\n        applicationId = \"com.example.cyclistance\"\n        minSdk = 21\n        targetSdk = 33\n\n        versionCode = 1\n        versionName = \"1.0\"\n        multiDexEnabled = true\n        namespace = \"com.example.cyclistance\"\n\n        testInstrumentationRunner = \"com.example.cyclistance.HiltTestRunner\"\n        vectorDrawables {\n            useSupportLibrary = true\n        }\n    }\n    buildTypes {\n        val localProperties = Properties()\n        localProperties.load(FileInputStream(rootProject.file(\"local.properties\")))\n\n        getByName(\"debug\") {\n            isCrunchPngs = true\n            manifestPlaceholders[\"cleartextTrafficPermitted\"] = \"true\"\n            resValue(\n                \"string\",\n                \"MapsDownloadToken\",\n                localProperties.getProperty(\"MAPBOX_DOWNLOADS_TOKEN\"))\n            resValue(\"string\", \"FacebookAppID\", localProperties.getProperty(\"FACEBOOK_APP_ID\"))\n            resValue(\n                \"string\",\n                \"FacebookLoginProtocolScheme\",\n                localProperties.getProperty(\"FACEBOOK_LOGIN_PROTOCOL_SCHEME\"))\n            resValue(\n                \"string\",\n                \"FacebookClientToken\",\n                localProperties.getProperty(\"FACEBOOK_CLIENT_TOKEN\"))\n            resValue(\n                \"string\",\n                \"DefaultWebClientId\",\n                localProperties.getProperty(\"DEFAULT_WEB_CLIENT_ID\"))\n            resValue(\n                \"string\",\n                \"CyclistanceApiBaseUrl\",\n                localProperties.getProperty(\"CYCLISTANCE_API_BASE_URL_LOCAL\"))\n            resValue(\"string\", \"FcmServerKey\", localProperties.getProperty(\"FCM_SERVER_KEY\"))\n            resValue(\"string\", \"FcmBaseUrl\", localProperties.getProperty(\"FCM_BASE_URL\"))\n        }\n        getByName(\"release\") {\n            isMinifyEnabled = true\n            isShrinkResources = true\n            isCrunchPngs = true\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n            resValue(\n                \"string\",\n                \"MapsDownloadToken\",\n                localProperties.getProperty(\"MAPBOX_DOWNLOADS_TOKEN\"))\n            resValue(\"string\", \"FacebookAppID\", localProperties.getProperty(\"FACEBOOK_APP_ID\"))\n            resValue(\n                \"string\",\n                \"FacebookLoginProtocolScheme\",\n                localProperties.getProperty(\"FACEBOOK_LOGIN_PROTOCOL_SCHEME\"))\n            resValue(\n                \"string\",\n                \"FacebookClientToken\",\n                localProperties.getProperty(\"FACEBOOK_CLIENT_TOKEN\"))\n            resValue(\n                \"string\",\n                \"DefaultWebClientId\",\n                localProperties.getProperty(\"DEFAULT_WEB_CLIENT_ID\"))\n            resValue(\n                \"string\",\n                \"CyclistanceApiBaseUrl\",\n                localProperties.getProperty(\"CYCLISTANCE_API_BASE_URL\"))\n            resValue(\"string\", \"FcmServerKey\", localProperties.getProperty(\"FCM_SERVER_KEY\"))\n            resValue(\"string\", \"FcmBaseUrl\", localProperties.getProperty(\"FCM_BASE_URL\"))\n        }\n    }\n\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_17\n        targetCompatibility = JavaVersion.VERSION_17\n    }\n    kotlinOptions {\n        jvmTarget = \"17\"\n    }\n\n    buildFeatures {\n        compose = true\n        viewBinding = true\n    }\n\n    composeOptions {\n        kotlinCompilerExtensionVersion = \"1.5.3\"\n        kotlinCompilerVersion = kotlin_version\n\n    }\n\n    packagingOptions {\n        resources {\n            excludes += \"/META-INF/{AL2.0,LGPL2.1}\"\n        }\n    }\n\n\n    subprojects {\n        tasks.withType<KotlinCompile>().configureEach {\n            kotlinOptions {\n                if (project.findProperty(\"myapp.enableComposeCompilerReports\") == \"true\") {\n                    val compilerArgs = mutableListOf<String>()\n                    compilerArgs.add(\n                        \"-P\"\n                    )\n                    compilerArgs.add(\n                        \"plugin:androidx.compose.compiler.plugins.kotlin:reportsDestination=\" +\n                        project.buildDir.absolutePath + \"/compose_metrics\"\n                    )\n                    compilerArgs.add(\n                        \"-P\"\n                    )\n                    compilerArgs.add(\n                        \"plugin:androidx.compose.compiler.plugins.kotlin:metricsDestination=\" +\n                        project.buildDir.absolutePath + \"/compose_metrics\"\n                    )\n\n                    freeCompilerArgs = compilerArgs\n                }\n            }\n        }\n    }\n\n\n\n\n}\n\ndependencies {\n    implementation(\"androidx.lifecycle:lifecycle-runtime-compose:2.6.1\")\n    implementation(\"androidx.core:core-ktx:1.10.1\")\n    implementation(\"androidx.compose.ui:ui:1.6.0-alpha01\")\n    implementation(\"androidx.compose.material:material:1.6.0-alpha01\")\n    implementation(\"androidx.compose.ui:ui-tooling-preview:1.5.0\")\n    implementation(\"androidx.navigation:navigation-compose:2.7.0\")\n    implementation(\"androidx.compose.material:material-icons-extended:1.5.0\")\n    implementation(\"androidx.lifecycle:lifecycle-runtime-ktx:2.6.1\")\n    implementation(\"androidx.activity:activity-compose:1.7.2\")\n    implementation(\"androidx.legacy:legacy-support-v4:1.0.0\")\n    implementation(\"com.google.android.material:material:1.9.0\")\n    implementation(\"androidx.constraintlayout:constraintlayout:2.1.4\")\n    implementation(\"com.google.android.gms:play-services-auth:20.6.0\")\n    implementation(\"com.google.android.gms:play-services-maps:18.1.0\")\n    implementation(\"androidx.compose.material:material:1.5.0\")\n    implementation(\"androidx.compose.material3:material3:1.1.1\")\n    implementation(\"androidx.test.ext:junit-ktx:1.1.5\")\n    implementation(\"androidx.core:core-ktx:1.10.1\")\n    implementation(\"androidx.compose.foundation:foundation:1.4.3\")\n    debugImplementation(\"androidx.compose.ui:ui-tooling:1.5.0\")\n    implementation(\"androidx.compose.compiler:compiler:1.5.1\")\n    implementation(\"androidx.constraintlayout:constraintlayout-compose:1.0.1\")\n\n    //unit test\n    testImplementation(\"junit:junit:4.13.2\")\n    testImplementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.4\")\n    androidTestImplementation(\"com.google.dagger:hilt-android-testing:2.48\")\n    kspAndroidTest(\"com.google.dagger:hilt-android-compiler:2.48\")\n    androidTestImplementation(\"androidx.arch.core:core-testing:2.2.0\")\n\n    //integration test\n    androidTestImplementation(\"androidx.test.ext:junit:1.1.5\")\n    androidTestImplementation(\"androidx.compose.ui:ui-test-junit4:1.4.3\")\n    androidTestImplementation(\"androidx.test.espresso:espresso-core:3.5.1\")\n\n\n    implementation(\"com.google.dagger:hilt-android:2.48\")\n    ksp(\"com.google.dagger:hilt-android-compiler:2.48\")\n    ksp(\"androidx.hilt:hilt-compiler:1.0.0\")\n    implementation(\"androidx.hilt:hilt-navigation-compose:1.0.0\")\n\n\n    val retrofit_version = \"2.9.0\"\n    implementation(\"com.squareup.retrofit2:retrofit:$retrofit_version\")\n    implementation(\"com.squareup.retrofit2:converter-gson:$retrofit_version\")\n    implementation(\"com.squareup.retrofit2:converter-scalars:$retrofit_version\")\n\n    // Coroutines\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4\")\n    implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4\")\n\n    // Coroutine Lifecycle Scopes\n    implementation(\"androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.1\")\n    implementation(\"androidx.lifecycle:lifecycle-viewmodel-compose:2.6.1\")\n\n    implementation(\"androidx.lifecycle:lifecycle-runtime-ktx:2.6.1\")\n\n    //leakCanary\n    debugImplementation(\"com.squareup.leakcanary:leakcanary-android:2.8.1\")\n\n    // Compose dependencies\n\n    implementation(\"com.google.accompanist:accompanist-flowlayout:0.17.0\")\n\n    implementation(\"com.google.accompanist:accompanist-swiperefresh:0.31.5-beta\")\n    //Timber\n    implementation(\"com.jakewharton.timber:timber:5.0.1\")\n\n//    Coil\n    implementation(\"io.coil-kt:coil-compose:2.3.0\")\n    implementation(\"io.coil-kt:coil-gif:2.2.2\")\n\n\n    //for notification color\n    implementation(\"com.google.accompanist:accompanist-systemuicontroller:0.26.1-alpha\")\n\n    //paging\n    implementation(\"com.google.accompanist:accompanist-pager:0.26.4-beta\")\n\n    //paging indicator\n    implementation(\"com.google.accompanist:accompanist-pager-indicators:0.26.4-beta\")\n\n    //datastore\n    implementation(\"androidx.datastore:datastore-preferences:1.0.0\")\n\n\n    //permissions\n    implementation(\"com.google.accompanist:accompanist-permissions:0.31.3-beta\")\n\n    //animatedNavHost\n    implementation(\"com.google.accompanist:accompanist-navigation-animation:0.31.4-beta\")\n\n    //mapbox\n\n    implementation(\"com.mapbox.mapboxsdk:mapbox-android-plugin-annotation-v9:0.9.0\")\n\n    //location provider\n    implementation(\"com.google.android.gms:play-services-location:20.0.0\")\n\n\n    // Make sure the version of appcompat is 1.3.0+\n    implementation(\"androidx.appcompat:appcompat:1.6.1\")\n\n\n    //lottie animation\n    implementation(\"com.airbnb.android:lottie-compose:5.2.0\")\n\n    //Facebook Login\n    implementation(\"com.facebook.android:facebook-android-sdk:latest.release\")\n\n\n    implementation(\"com.google.maps.android:maps-compose:2.0.0\")\n\n\n    //Firebase\n    implementation(platform(\"com.google.firebase:firebase-bom:32.2.0\"))\n    implementation(\"com.google.firebase:firebase-auth\")\n    implementation(\"com.google.gms:google-services:4.3.15\")\n    implementation(\"com.google.firebase:firebase-crashlytics\")\n    implementation(\"com.google.firebase:firebase-analytics\")\n    implementation(\"com.google.firebase:firebase-auth-ktx\")\n    implementation(\"com.google.firebase:firebase-firestore-ktx\")\n    implementation(\"com.google.firebase:firebase-storage-ktx\")\n    implementation(\"com.google.firebase:firebase-common-ktx\")\n    implementation(\"com.google.firebase:firebase-messaging-ktx\")\n\n\n    //IOSocket Websocket\n    implementation(\"io.socket:socket.io-client:2.1.0\") {\n        exclude(group = \"org.json\", module = \"json\")\n    }\n\n\n    //mapbox navigation sdk\n    implementation(\"androidx.compose.ui:ui-viewbinding:1.4.3\")\n\n    //mapbox directions\n    implementation(\"com.mapbox.mapboxsdk:mapbox-sdk-services:6.9.0\")\n    testImplementation(\"androidx.arch.core:core-testing:2.2.0\")\n    testImplementation(\"app.cash.turbine:turbine:0.12.1\")\n    implementation(\"javax.annotation:javax.annotation-api:1.3.2\")\n    implementation(\"com.github.a914-gowtham:compose-ratingbar:1.3.4\")\n\n\n    val room_version = \"2.5.2\"\n\n    implementation(\"androidx.room:room-runtime:$room_version\")\n    implementation(\"androidx.room:room-ktx:$room_version\")\n    ksp(\"androidx.room:room-compiler:$room_version\")\n\n    val multidex_version = \"2.0.1\"\n    implementation(\"androidx.multidex:multidex:$multidex_version\")\n\n    implementation(\"com.github.ahmmedrejowan.CuteToast:CuteToast:1.2\")\n    implementation(\"com.google.code.gson:gson:2.10.1\")\n    implementation(\"com.google.maps.android:android-maps-utils:0.5\")\n}\n\napply(plugin = \"com.google.gms.google-services\")\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
--- a/app/build.gradle.kts	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/build.gradle.kts	(date 1696831695496)
@@ -57,10 +57,7 @@
                 "string",
                 "FacebookClientToken",
                 localProperties.getProperty("FACEBOOK_CLIENT_TOKEN"))
-            resValue(
-                "string",
-                "DefaultWebClientId",
-                localProperties.getProperty("DEFAULT_WEB_CLIENT_ID"))
+
             resValue(
                 "string",
                 "CyclistanceApiBaseUrl",
@@ -89,10 +86,7 @@
                 "string",
                 "FacebookClientToken",
                 localProperties.getProperty("FACEBOOK_CLIENT_TOKEN"))
-            resValue(
-                "string",
-                "DefaultWebClientId",
-                localProperties.getProperty("DEFAULT_WEB_CLIENT_ID"))
+
             resValue(
                 "string",
                 "CyclistanceApiBaseUrl",
Index: app/src/main/java/com/example/cyclistance/di/messaging/MessagingViewModelModule.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.di.messaging\n\nimport com.example.cyclistance.feature_messaging.domain.repository.MessagingRepository\nimport com.example.cyclistance.feature_messaging.domain.use_case.MessagingUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.conversion.AddConversionUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.conversion.GetConversionIdUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.conversion.UpdateConversionUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetMessagingUserUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetUidUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.manage_user.UpdateUserAvailability\nimport com.example.cyclistance.feature_messaging.domain.use_case.message.AddMessageListenerUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.message.RemoveMessageListenerUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.message.SendMessageUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.network.ReEnableNetworkSyncUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.notification.SendNotificationUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.seen.MarkAsSeenUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.token.DeleteTokenUseCase\nimport com.example.cyclistance.feature_messaging.domain.use_case.token.RefreshTokenUseCase\nimport dagger.Module\nimport dagger.Provides\nimport dagger.hilt.InstallIn\nimport dagger.hilt.android.components.ViewModelComponent\nimport dagger.hilt.android.scopes.ViewModelScoped\n\n\n@Module\n@InstallIn(ViewModelComponent::class)\nobject MessagingViewModelModule {\n\n\n\n    @Provides\n    @ViewModelScoped\n    fun providesMessagingUseCase(repository: MessagingRepository): MessagingUseCase {\n        return MessagingUseCase(\n            refreshTokenUseCase = RefreshTokenUseCase(repository = repository),\n            deleteTokenUseCase = DeleteTokenUseCase(repository = repository),\n            sendMessageUseCase = SendMessageUseCase(repository = repository),\n            addMessageListenerUseCase = AddMessageListenerUseCase(repository = repository),\n            removeMessageListenerUseCase = RemoveMessageListenerUseCase(repository = repository),\n            getUidUseCase = GetUidUseCase(repository = repository),\n            getConversionIdUseCase = GetConversionIdUseCase(repository = repository),\n            addConversionUseCase = AddConversionUseCase(repository = repository),\n            updateConversionUseCase = UpdateConversionUseCase(repository = repository),\n            updateUserAvailability = UpdateUserAvailability(repository = repository),\n            sendNotificationUseCase = SendNotificationUseCase(repository = repository),\n            getMessagingUserUseCase = GetMessagingUserUseCase(repository = repository),\n            reEnableNetworkSyncUseCase = ReEnableNetworkSyncUseCase(repository = repository),\n            markAsSeenUseCase = MarkAsSeenUseCase(repository = repository)\n        )\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/di/messaging/MessagingViewModelModule.kt b/app/src/main/java/com/example/cyclistance/di/messaging/MessagingViewModelModule.kt
--- a/app/src/main/java/com/example/cyclistance/di/messaging/MessagingViewModelModule.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/di/messaging/MessagingViewModelModule.kt	(date 1696832001139)
@@ -7,7 +7,6 @@
 import com.example.cyclistance.feature_messaging.domain.use_case.conversion.UpdateConversionUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetMessagingUserUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.manage_user.GetUidUseCase
-import com.example.cyclistance.feature_messaging.domain.use_case.manage_user.UpdateUserAvailability
 import com.example.cyclistance.feature_messaging.domain.use_case.message.AddMessageListenerUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.message.RemoveMessageListenerUseCase
 import com.example.cyclistance.feature_messaging.domain.use_case.message.SendMessageUseCase
@@ -42,7 +41,6 @@
             getConversionIdUseCase = GetConversionIdUseCase(repository = repository),
             addConversionUseCase = AddConversionUseCase(repository = repository),
             updateConversionUseCase = UpdateConversionUseCase(repository = repository),
-            updateUserAvailability = UpdateUserAvailability(repository = repository),
             sendNotificationUseCase = SendNotificationUseCase(repository = repository),
             getMessagingUserUseCase = GetMessagingUserUseCase(repository = repository),
             reEnableNetworkSyncUseCase = ReEnableNetworkSyncUseCase(repository = repository),
Index: app/src/main/java/com/example/cyclistance/feature_authentication/domain/util/AuthResult.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_authentication.domain.util\n\nimport android.app.Activity\nimport android.content.Context\nimport android.content.Intent\nimport androidx.activity.result.contract.ActivityResultContract\nimport com.example.cyclistance.R\nimport com.google.android.gms.auth.api.signin.GoogleSignIn\nimport com.google.android.gms.auth.api.signin.GoogleSignInAccount\nimport com.google.android.gms.auth.api.signin.GoogleSignInOptions\nimport com.google.android.gms.tasks.Task\n\n\nclass AuthResult :\n    ActivityResultContract<Int, Task<GoogleSignInAccount>?>() {\n\n\n    override fun createIntent(context: Context, input: Int): Intent {\n\n        val googleSignInOptions = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)\n            .requestEmail()\n            .requestIdToken(context.getString(R.string.DefaultWebClientId))\n            .build()\n\n        val signInClient =  GoogleSignIn.getClient(context, googleSignInOptions)\n        return signInClient.signInIntent.putExtra(\"Input\", input)\n    }\n\n    override fun parseResult(resultCode: Int, intent: Intent?): Task<GoogleSignInAccount>? {\n        return when (resultCode) {\n            Activity.RESULT_OK -> GoogleSignIn.getSignedInAccountFromIntent(intent)\n            else -> null\n        }\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_authentication/domain/util/AuthResult.kt b/app/src/main/java/com/example/cyclistance/feature_authentication/domain/util/AuthResult.kt
--- a/app/src/main/java/com/example/cyclistance/feature_authentication/domain/util/AuthResult.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/feature_authentication/domain/util/AuthResult.kt	(date 1696827401203)
@@ -18,11 +18,13 @@
     override fun createIntent(context: Context, input: Int): Intent {
 
         val googleSignInOptions = GoogleSignInOptions.Builder(GoogleSignInOptions.DEFAULT_SIGN_IN)
+            .requestIdToken(context.getString(R.string.default_web_client_id))
+            .requestServerAuthCode(context.getString(R.string.default_web_client_id), false)
             .requestEmail()
-            .requestIdToken(context.getString(R.string.DefaultWebClientId))
+            .requestProfile()
             .build()
 
-        val signInClient =  GoogleSignIn.getClient(context, googleSignInOptions)
+        val signInClient = GoogleSignIn.getClient(context, googleSignInOptions)
         return signInClient.signInIntent.putExtra("Input", input)
     }
 
Index: app/src/main/java/com/example/cyclistance/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance\n\nimport android.app.NotificationChannel\nimport android.app.NotificationManager\nimport android.content.Intent\nimport android.os.Build\nimport android.os.Bundle\nimport android.view.WindowManager\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.annotation.RequiresApi\nimport androidx.compose.runtime.CompositionLocalProvider\nimport com.example.cyclistance.core.utils.constants.LocationServiceConstants.LOCATION_CHANNEL_DESCRIPTION\nimport com.example.cyclistance.core.utils.constants.LocationServiceConstants.LOCATION_NOTIFICATION_NAME\nimport com.example.cyclistance.core.utils.constants.LocationServiceConstants.LOCATION_SERVICE_CHANNEL_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.RESCUE_NOTIFICATION_CHANNEL_DESCRIPTION\nimport com.example.cyclistance.core.utils.constants.MappingConstants.RESCUE_NOTIFICATION_CHANNEL_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.RESCUE_NOTIFICATION_CHANNEL_NAME\nimport com.example.cyclistance.core.utils.constants.MessagingConstants\nimport com.example.cyclistance.feature_authentication.domain.util.ActivityResultCallbackManager\nimport com.example.cyclistance.feature_authentication.domain.util.LocalActivityResultCallbackManager\nimport com.example.cyclistance.navigation.NavScreen\nimport com.facebook.FacebookSdk.sdkInitialize\nimport com.facebook.appevents.AppEventsLogger\nimport com.mapbox.mapboxsdk.Mapbox\nimport dagger.hilt.android.AndroidEntryPoint\nimport javax.inject.Inject\n\n\n@AndroidEntryPoint\nclass MainActivity : ComponentActivity() {\n\n    /*@Inject\n    @Named(\"messagingNotificationChannel\") lateinit var notificationChannel: NotificationChannel*/\n\n   /* @Inject\n    @Named(\"rescueNotificationChannel\") lateinit var rescueNotificationChannel: NotificationChannel*/\n\n    @Inject lateinit var notificationManager: NotificationManager\n\n\n    private var callbackManager = ActivityResultCallbackManager()\n\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        Mapbox.getInstance(this, getString(R.string.MapsDownloadToken))\n        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);\n\n        setTheme(R.style.Theme_Cyclistance)\n        sdkInitialize(applicationContext);\n        AppEventsLogger.activateApp(application);\n        addNotificationChannel()\n\n        setContent {\n            CompositionLocalProvider(LocalActivityResultCallbackManager provides callbackManager) {\n                NavScreen()\n            }\n        }\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    private fun getTrackingNotificationChannel() = NotificationChannel(\n        LOCATION_SERVICE_CHANNEL_ID,\n        LOCATION_NOTIFICATION_NAME,\n        NotificationManager.IMPORTANCE_LOW).apply {\n        description = LOCATION_CHANNEL_DESCRIPTION\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    private fun getMessagingNotificationChannel() = NotificationChannel(\n        MessagingConstants.CHANNEL_ID,\n        MessagingConstants.CHANNEL_NAME,\n        NotificationManager.IMPORTANCE_HIGH).apply {\n        description = MessagingConstants.CHANNEL_DESCRIPTION\n\n    }\n\n    @RequiresApi(Build.VERSION_CODES.O)\n    private fun getRescueNotificationChannel()=\n         NotificationChannel(\n            RESCUE_NOTIFICATION_CHANNEL_ID,\n            RESCUE_NOTIFICATION_CHANNEL_NAME,\n            NotificationManager.IMPORTANCE_HIGH).apply {\n            description = RESCUE_NOTIFICATION_CHANNEL_DESCRIPTION\n        }\n\n\n\n    private fun addNotificationChannel(){\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {\n            notificationManager.createNotificationChannels(\n                listOf(\n                    getTrackingNotificationChannel(),\n                    getMessagingNotificationChannel(),\n                    getRescueNotificationChannel()\n\n                )\n\n\n            )\n\n        }\n    }\n\n\n    @Deprecated(\"Deprecated in Java\")\n    override fun onActivityResult(\n        requestCode: Int,\n        resultCode: Int,\n        data: Intent?\n    ) {\n        if (!callbackManager.onActivityResult(requestCode, resultCode, data)) {\n            super.onActivityResult(requestCode, resultCode, data)\n        }\n    }\n\n}\n\n\n\n\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/MainActivity.kt b/app/src/main/java/com/example/cyclistance/MainActivity.kt
--- a/app/src/main/java/com/example/cyclistance/MainActivity.kt	(revision a6285a5ae58f45299d0e89851b4dbb6154bc8d89)
+++ b/app/src/main/java/com/example/cyclistance/MainActivity.kt	(date 1696679018527)
@@ -30,11 +30,6 @@
 @AndroidEntryPoint
 class MainActivity : ComponentActivity() {
 
-    /*@Inject
-    @Named("messagingNotificationChannel") lateinit var notificationChannel: NotificationChannel*/
-
-   /* @Inject
-    @Named("rescueNotificationChannel") lateinit var rescueNotificationChannel: NotificationChannel*/
 
     @Inject lateinit var notificationManager: NotificationManager
 
