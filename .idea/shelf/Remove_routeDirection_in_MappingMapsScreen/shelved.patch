Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components\n\nimport androidx.compose.animation.AnimatedVisibility\nimport androidx.compose.animation.core.tween\nimport androidx.compose.animation.expandVertically\nimport androidx.compose.animation.fadeIn\nimport androidx.compose.animation.fadeOut\nimport androidx.compose.animation.shrinkVertically\nimport androidx.compose.foundation.layout.Box\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material.BottomSheetScaffoldState\nimport androidx.compose.material.CircularProgressIndicator\nimport androidx.compose.material.ExperimentalMaterialApi\nimport androidx.compose.material.MaterialTheme\nimport androidx.compose.material.Surface\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.derivedStateOf\nimport androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.remember\nimport androidx.compose.runtime.saveable.rememberSaveable\nimport androidx.compose.runtime.setValue\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalConfiguration\nimport androidx.compose.ui.text.input.TextFieldValue\nimport androidx.compose.ui.unit.dp\nimport androidx.constraintlayout.compose.ConstraintLayout\nimport androidx.constraintlayout.compose.Dimension\nimport com.example.cyclistance.core.domain.model.AlertDialogState\nimport com.example.cyclistance.core.presentation.dialogs.alert_dialog.AlertDialog\nimport com.example.cyclistance.core.presentation.dialogs.no_internet_dialog.NoInternetDialog\nimport com.example.cyclistance.core.presentation.dialogs.permissions_dialog.DialogForegroundLocationPermission\nimport com.example.cyclistance.core.presentation.dialogs.permissions_dialog.DialogNotificationPermission\nimport com.example.cyclistance.feature_authentication.presentation.common.visible\nimport com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.components.emergency_call.EmergencyCallDialog\nimport com.example.cyclistance.feature_emergency_call.presentation.emergency_call_screen.state.EmergencyCallState\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.hazardous_lane.HazardousLaneMarker\nimport com.example.cyclistance.feature_mapping.domain.model.ui.rescue.CancelledRescueModel\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.banner.MappingExpandableBanner\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.bottomSheet.MappingBottomSheet\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.CancelRespondButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.RequestHelpButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.buttons.RespondToHelpButton\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.CancelOnGoingRescueDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.CancelSearchDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.DeleteHazardousLaneMarkerDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.dialog.DiscardHazardousLaneMarkerDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.fabs.ExpandableFABSection\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.fabs.FloatingButtonSection\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.request.MappingRequestAccepted\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.request.MappingRequestCancelled\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components.rescue_request.RescueRequestDialog\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.BottomSheetType\nimport com.google.accompanist.permissions.ExperimentalPermissionsApi\nimport com.google.accompanist.permissions.MultiplePermissionsState\nimport com.google.accompanist.permissions.rememberMultiplePermissionsState\nimport com.mapbox.mapboxsdk.maps.MapboxMap\n\n\n@OptIn(ExperimentalPermissionsApi::class, ExperimentalMaterialApi::class)\n@Composable\nfun MappingScreenContent(\n    modifier: Modifier,\n    bottomSheetScaffoldState: BottomSheetScaffoldState,\n    state: MappingState,\n    emergencyState: EmergencyCallState,\n    mapboxMap: MapboxMap?,\n\n    uiState: MappingUiState,\n    incidentDescription: TextFieldValue,\n    hazardousLaneMarkers: List<HazardousLaneMarker>,\n    locationPermissionState: MultiplePermissionsState = rememberMultiplePermissionsState(permissions = emptyList()),\n    event: (MappingUiEvent) -> Unit = {},\n) {\n\n    val respondentCount by remember(state.newRescueRequest?.request?.size) {\n        derivedStateOf { (state.newRescueRequest?.request)?.size ?: 0 }\n    }\n\n    var lastNotifiedRequestId by rememberSaveable{ mutableStateOf(\"\") }\n    var lastNotifiedAcceptedId by rememberSaveable { mutableStateOf(\"\") }\n\n    val configuration = LocalConfiguration.current\n    val markerPostedCount by remember(hazardousLaneMarkers.size){\n        derivedStateOf {\n            hazardousLaneMarkers.count { it.idCreator == state.userId }\n        }\n    }\n\n    LaunchedEffect(key1 = respondentCount){\n        val request = state.newRescueRequest?.request?.lastOrNull() ?: return@LaunchedEffect\n        if(lastNotifiedRequestId == request.id) {\n            return@LaunchedEffect\n        }\n\n        event(MappingUiEvent.NotifyNewRescueRequest(message = \"Request from ${request.name}, distance is ${request.distance}\"))\n        lastNotifiedRequestId = request.id ?: \"\"\n    }\n\n    LaunchedEffect(key1 = uiState.rescueRequestAccepted, key2 = uiState.isRescueCancelled.not()){\n\n\n        val rescueeId = state.rescuee?.id\n        if(lastNotifiedAcceptedId == rescueeId){\n            return@LaunchedEffect\n        }\n        if (uiState.rescueRequestAccepted && uiState.isRescueCancelled.not()) {\n\n            event(MappingUiEvent.NotifyRequestAccepted(\n                    message = \"${state.rescuee?.name} accepted your request\"))\n            lastNotifiedAcceptedId = rescueeId ?: \"\"\n        }\n    }\n\n\n    Surface(\n        modifier = modifier\n            .fillMaxSize(),\n        color = MaterialTheme.colors.background) {\n\n\n        Box {\n\n            if (uiState.isRescueRequestDialogVisible) {\n                RescueRequestDialog(\n                    modifier = Modifier\n                        .fillMaxSize(),\n                    mappingState = state,\n                    uiState = uiState,\n                    event = event\n                )\n            }\n\n            MappingBottomSheet(\n                state = state,\n                event = event,\n                bottomSheetScaffoldState = bottomSheetScaffoldState,\n                uiState = uiState,\n                incidentDescription = incidentDescription,\n                modifier = Modifier\n                    .fillMaxWidth()\n                    .padding(horizontal = 12.dp)\n                    .align(Alignment.BottomCenter),\n                markerPostedCount = markerPostedCount) {\n\n\n                ConstraintLayout(modifier = Modifier.fillMaxSize()) {\n\n                    val (mapScreen, requestHelpButton, circularProgressbar, dialog, respondToHelpButton, fabSection, expandableFabSection) = createRefs()\n\n\n                    MappingMapsScreen(\n                        state = state,\n                        modifier = Modifier.constrainAs(mapScreen) {\n                            top.linkTo(parent.top)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                            bottom.linkTo(parent.bottom)\n                        },\n                        mapboxMap = mapboxMap,\n                        routeDirection = uiState.routeDirection,\n                        event = event,\n                        uiState = uiState,\n                        hazardousLaneMarkers = hazardousLaneMarkers\n                    )\n\n\n\n\n                    AnimatedVisibility(\n                        visible = uiState.mapSelectedRescuee != null && bottomSheetScaffoldState.bottomSheetState.isCollapsed,\n                        enter = expandVertically(expandFrom = Alignment.Top) { 20 },\n                        exit = shrinkVertically(animationSpec = tween()) { fullHeight ->\n                            fullHeight / 2\n                        },\n                    ) {\n                        if (uiState.mapSelectedRescuee != null) {\n                            MappingExpandableBanner(\n                                modifier = Modifier\n                                    .padding(all = 6.dp)\n                                    .fillMaxWidth(), banner = uiState.mapSelectedRescuee,\n                                onClickDismissButton = { event(MappingUiEvent.DismissBanner) })\n                        }\n                    }\n\n                    FloatingButtonSection(\n                        modifier = Modifier\n                            .constrainAs(fabSection) {\n                                end.linkTo(parent.end, margin = 8.dp)\n                                bottom.linkTo(\n                                    parent.bottom,\n                                    margin = (configuration.screenHeightDp / 2.5).dp)\n                                top.linkTo(parent.top, margin = 15.dp)\n                                height = Dimension.fillToConstraints\n\n                            },\n                        locationPermissionGranted = locationPermissionState.allPermissionsGranted,\n                        onClickLocateUserButton = { event(MappingUiEvent.LocateUser) },\n                        onClickRouteOverviewButton = { event(MappingUiEvent.RouteOverview) },\n                        onClickRecenterButton = { event(MappingUiEvent.RecenterRoute) },\n                        onClickOpenNavigationButton = { event(MappingUiEvent.OpenNavigation) },\n                        onClickLayerButton = {\n                            val mapTypeBottomSheetVisibility =\n                                bottomSheetScaffoldState.bottomSheetState.isExpanded && uiState.bottomSheetType == BottomSheetType.MapType.type\n                            event(MappingUiEvent.MapTypeBottomSheet(visibility = !mapTypeBottomSheetVisibility))\n                        },\n                        uiState = uiState\n                    )\n\n                    ExpandableFABSection(\n                        onClickEmergencyCall = { event(MappingUiEvent.EmergencyCallDialog(visibility = true)) },\n                        onClickFamilyTracker = { event(MappingUiEvent.OpenFamilyTracker) },\n                        onClickRescueRequest = { event(MappingUiEvent.RescueRequestDialog(visibility = true)) },\n                        onClickFab = { event(MappingUiEvent.ExpandableFab(expanded = !uiState.isFabExpanded)) },\n                        onClickBikeTracker = { event(MappingUiEvent.OpenSinoTrack) },\n                        isFabExpanded = uiState.isFabExpanded,\n                        badgeCount = respondentCount,\n                        modifier = Modifier.constrainAs(expandableFabSection) {\n                            end.linkTo(parent.end, margin = 8.dp)\n                            if (bottomSheetScaffoldState.bottomSheetState.isCollapsed) bottom.linkTo(\n                                parent.bottom,\n                                margin = 15.dp) else top.linkTo(fabSection.bottom, margin = 8.dp)\n                        }\n                    )\n\n\n                    val buttonVisible =\n                        uiState.isNavigating.not() && uiState.isFabExpanded.not() && bottomSheetScaffoldState.bottomSheetState.isCollapsed\n                    val requestHelpVisible = uiState.requestHelpButtonVisible && buttonVisible\n                    val respondToHelpVisible = uiState.requestHelpButtonVisible.not() && buttonVisible\n\n                    val requestPending = state.user.isRescueRequestPending(uiState.mapSelectedRescuee?.userId) == true\n\n                    RequestHelpButton(\n                        modifier = Modifier.constrainAs(requestHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        }, onClickRequestHelpButton = { event(MappingUiEvent.RequestHelp) },\n                        state = state,\n                        visible = requestHelpVisible\n\n                    )\n\n                    RespondToHelpButton(\n                        modifier = Modifier.constrainAs(respondToHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        },\n                        onClickRespondButton = { event(MappingUiEvent.RespondToHelp) },\n                        state = state,\n                        visible = respondToHelpVisible && !requestPending\n                    )\n\n\n                    CancelRespondButton(\n                        cancelRespond = { event(MappingUiEvent.CancelRespondHelp) },\n                        modifier = Modifier.constrainAs(respondToHelpButton) {\n                            bottom.linkTo(parent.bottom, margin = 15.dp)\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                        },\n                        state = state,\n                        visible = respondToHelpVisible && requestPending)\n\n\n\n                    if (state.isLoading) {\n                        CircularProgressIndicator(\n                            modifier = Modifier.constrainAs(\n                                circularProgressbar) {\n                                top.linkTo(parent.top)\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                this.centerTo(parent)\n                            })\n                    }\n\n\n                    if (uiState.cancelSearchDialogVisible) {\n                        CancelSearchDialog(onDismissRequest = {\n                            event(MappingUiEvent.CancelSearchDialog(visibility = false))\n                        }, onClickOkay = {\n                            event(MappingUiEvent.SearchCancelled)\n                        }, modifier = Modifier.constrainAs(dialog) {\n                            end.linkTo(parent.end)\n                            start.linkTo(parent.start)\n                            bottom.linkTo(parent.bottom)\n                            width = Dimension.matchParent\n                            height = Dimension.wrapContent\n                            this.centerTo(parent)\n                        })\n                    }\n\n                    if (uiState.cancelOnGoingRescueDialogVisible) {\n                        CancelOnGoingRescueDialog(\n                            onDismissRequest = {\n                                event(MappingUiEvent.CancelOnGoingRescueDialog(visibility = false))\n                            },\n                            onClickOkay = { event(MappingUiEvent.CancelOnGoingRescue) },\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            })\n                    }\n\n\n\n                    if (uiState.isEmergencyCallDialogVisible) {\n                        EmergencyCallDialog(\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            },\n                            onDismiss = { event(MappingUiEvent.EmergencyCallDialog(visibility = false)) },\n                            emergencyCallModel = emergencyState.emergencyCallModel,\n                            onClick = {\n                                event(\n                                    MappingUiEvent.OnEmergencyCall(\n                                        it.phoneNumber\n                                    )\n                                )\n                            }, onAddContact = {\n                                event(MappingUiEvent.OnAddEmergencyContact)\n                                event(MappingUiEvent.EmergencyCallDialog(visibility = false))\n                            }\n\n                        )\n                    }\n\n                    if (uiState.deleteHazardousMarkerDialogVisible) {\n                        DeleteHazardousLaneMarkerDialog(\n                            onDismissRequest = {\n                                event(MappingUiEvent.HazardousLaneMarkerDialog(\n                                    visibility = false))\n                            },\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            },\n                            onClickConfirmButton = {\n                                event(MappingUiEvent.OnConfirmDeleteIncident)\n                                event(MappingUiEvent.HazardousLaneMarkerDialog(visibility = false))\n                            })\n                    }\n\n                    if (uiState.isNoInternetVisible) {\n                        NoInternetDialog(\n                            onDismiss = { event(MappingUiEvent.NoInternetDialog(visibility = false)) },\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                width = Dimension.matchParent\n                                height = Dimension.wrapContent\n                                this.centerTo(parent)\n                            })\n                    }\n\n                    if (uiState.locationPermissionDialogVisible) {\n                        DialogForegroundLocationPermission(\n                            modifier = Modifier.constrainAs(\n                                dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismiss = { event(MappingUiEvent.LocationPermission(visibility = false)) }\n                        )\n                    }\n\n\n                    if (uiState.notificationPermissionVisible) {\n                        DialogNotificationPermission(\n                            modifier = Modifier.constrainAs(\n                                dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismiss = {\n                                event(\n                                    MappingUiEvent.NotificationPermissionDialog(\n                                        visibility = false))\n                            }\n                        )\n                    }\n\n\n\n                    if(uiState.alertDialogState.visible()){\n                        AlertDialog(\n                            alertDialog = uiState.alertDialogState,\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismissRequest = { event(MappingUiEvent.AlertDialog(alertDialogState = AlertDialogState())) })\n                    }\n\n                    if (uiState.discardHazardousMarkerDialogVisible) {\n                        DiscardHazardousLaneMarkerDialog(\n                            modifier = Modifier.constrainAs(dialog) {\n                                end.linkTo(parent.end)\n                                start.linkTo(parent.start)\n                                bottom.linkTo(parent.bottom)\n                                height = Dimension.wrapContent\n                                centerTo(parent)\n                            },\n                            onDismissRequest = {\n                                event(MappingUiEvent.DiscardChangesMarkerDialog(visibility = false))\n                            },\n                            onClickDiscard = {\n                                event(MappingUiEvent.DiscardChangesMarkerDialog(visibility = false))\n                                event(MappingUiEvent.DiscardMarkerChanges)\n                            }\n                        )\n                    }\n\n                    AnimatedVisibility(\n                        visible = uiState.isRescueCancelled && uiState.rescueRequestAccepted.not(),\n                        enter = fadeIn(),\n                        exit = fadeOut(animationSpec = tween(durationMillis = 220))) {\n\n                        val rescueTransaction = state.rescueTransaction ?: return@AnimatedVisibility\n\n                        MappingRequestCancelled(\n                            modifier = Modifier.fillMaxSize()\n                            ,\n                            onClickOkButton = { event(MappingUiEvent.CancelledRescueConfirmed) },\n                            cancelledRescueModel = CancelledRescueModel(\n                                transactionID = rescueTransaction.id,\n                                rescueCancelledBy = rescueTransaction.getCancellationName(),\n                                reason = rescueTransaction.getCancellationReason(),\n                                message = rescueTransaction.getCancellationMessage()\n                            ))\n                    }\n\n                    AnimatedVisibility(\n                        visible = uiState.rescueRequestAccepted && uiState.isRescueCancelled.not(),\n                        enter = fadeIn(),\n                        exit = fadeOut(animationSpec = tween(durationMillis = 220))) {\n                        MappingRequestAccepted(\n                            modifier = Modifier.fillMaxSize(),\n                            onClickOkButton = { event(MappingUiEvent.RescueRequestAccepted) },\n                            acceptedName = state.rescuee?.name ?: \"Name placeholder\",\n                        )\n                    }\n                }\n            }\n\n\n\n\n        }\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt	(revision 7d7b9144b66bee06653fd3bb8c3d415f8db079c9)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingScreenContent.kt	(date 1697619160849)
@@ -165,7 +165,6 @@
                             bottom.linkTo(parent.bottom)
                         },
                         mapboxMap = mapboxMap,
-                        routeDirection = uiState.routeDirection,
                         event = event,
                         uiState = uiState,
                         hazardousLaneMarkers = hazardousLaneMarkers
Index: app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.components\n\nimport android.annotation.SuppressLint\nimport android.os.Bundle\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.core.content.ContextCompat\nimport androidx.core.graphics.drawable.toBitmap\nimport androidx.lifecycle.*\nimport com.example.cyclistance.R\nimport com.example.cyclistance.core.utils.constants.MappingConstants\nimport com.example.cyclistance.core.utils.constants.MappingConstants.DEFAULT_CAMERA_ANIMATION_DURATION\nimport com.example.cyclistance.core.utils.constants.MappingConstants.ICON_SOURCE_ID\nimport com.example.cyclistance.core.utils.constants.MappingConstants.LOCATE_USER_ZOOM_LEVEL\nimport com.example.cyclistance.core.utils.constants.MappingConstants.TRANSACTION_ICON_ID\nimport com.example.cyclistance.core.utils.formatter.IconFormatter.getHazardousLaneImage\nimport com.example.cyclistance.core.utils.formatter.IconFormatter.getNearbyCyclistImage\nimport com.example.cyclistance.feature_mapping.domain.model.Role\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.hazardous_lane.HazardousLaneMarker\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.rescue_transaction.RouteDirection\nimport com.example.cyclistance.feature_mapping.domain.model.remote_models.user.LocationModel\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.*\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.animateCameraPosition\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.initLayers\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.initSource\nimport com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.setDefaultSettings\nimport com.example.cyclistance.navigation.IsDarkTheme\nimport com.mapbox.geojson.Feature\nimport com.mapbox.geojson.FeatureCollection\nimport com.mapbox.geojson.Point\nimport com.mapbox.mapboxsdk.annotations.IconFactory\nimport com.mapbox.mapboxsdk.annotations.Marker\nimport com.mapbox.mapboxsdk.annotations.MarkerOptions\nimport com.mapbox.mapboxsdk.geometry.LatLng\nimport com.mapbox.mapboxsdk.maps.MapView\nimport com.mapbox.mapboxsdk.maps.MapboxMap\nimport com.mapbox.mapboxsdk.maps.Style\nimport com.mapbox.mapboxsdk.style.expressions.Expression.*\nimport com.mapbox.mapboxsdk.style.layers.PropertyFactory.*\nimport com.mapbox.mapboxsdk.style.sources.GeoJsonSource\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\n\n\n@SuppressLint(\"MissingPermission\")\n@Suppress(\"Deprecation\")\n@Composable\nfun MappingMapsScreen(\n    modifier: Modifier,\n    state: MappingState,\n    uiState: MappingUiState,\n    mapboxMap: MapboxMap?,\n    routeDirection: RouteDirection?,\n    hazardousLaneMarkers: List<HazardousLaneMarker>,\n    event: (MappingUiEvent) -> Unit\n//    requestNavigationCameraToOverview: () -> Unit, //todo use this one\n) {\n\n\n    val context = LocalContext.current\n    val nearbyCyclist = state.nearbyCyclist?.users\n\n\n    val nearbyUserMarkers = remember { mutableStateListOf<Marker>() }\n\n    val dismissNearbyUserMarkers = remember(mapboxMap) {\n        {\n            nearbyUserMarkers.apply {\n                forEach { mapboxMap?.removeMarker(it) }\n                clear()\n            }\n        }\n    }\n\n    val showNearbyCyclistsIcon = remember(nearbyCyclist, mapboxMap,state.userLocation?.latitude) {\n        {\n            dismissNearbyUserMarkers()\n            nearbyCyclist?.filter {\n                it.id != state.user.id\n            }?.filter {user ->\n\n                user.isUserNeedHelp() == true\n            }?.filter { user ->\n\n                val markerLocation = LatLng(user.location?.latitude!!, user.location.longitude!!)\n                val userLocation = LatLng(\n                    state.userLocation?.latitude!!,\n                    state.userLocation.longitude!!\n                )\n                markerLocation.distanceTo(userLocation)< MappingConstants.DEFAULT_RADIUS\n            }?.forEach { cyclist ->\n                Timber.v(\"Cyclist Name: ${cyclist.name}\")\n                val location = cyclist.location\n                val latitude = location?.latitude ?: return@forEach\n                val longitude = location.longitude ?: return@forEach\n                val description = cyclist.getDescription()\n                val iconImage = description?.getNearbyCyclistImage(context)\n                    ?.toBitmap(width = 120, height = 120)\n                iconImage?.let { bitmap ->\n                    mapboxMap ?: return@let\n                    val icon = IconFactory.getInstance(context).fromBitmap(bitmap)\n                    val markerOptions = MarkerOptions().apply {\n                        setIcon(icon)\n                        position(LatLng(latitude, longitude))\n                        title = cyclist.id\n                        this.snippet = MarkerSnippet.NearbyCyclistSnippet.type\n                    }\n                    val addedMarker = mapboxMap.addMarker(markerOptions)\n                    addedMarker.let { nearbyUserMarkers.add(it) }\n                }\n            }\n        }\n    }\n\n    val hazardousMarkers = remember { mutableStateListOf<Marker>() }\n\n\n    val dismissHazardousMarkers = remember(mapboxMap) {\n        {\n            hazardousMarkers.apply {\n                forEach { mapboxMap?.removeMarker(it) }\n                clear()\n            }\n        }\n    }\n    val showHazardousLaneIcon = remember(hazardousLaneMarkers.size, mapboxMap, state.userLocation) {\n        {\n\n            dismissHazardousMarkers()\n            hazardousLaneMarkers.filter { marker ->\n                val markerLocation = LatLng(marker.latitude!!, marker.longitude!!)\n                val userLocation = LatLng(\n                    state.getCurrentLocation()?.latitude!!,\n                    state.getCurrentLocation()?.longitude!!\n                )\n                markerLocation.distanceTo(userLocation) < MappingConstants.DEFAULT_RADIUS\n            }.forEach { marker ->\n                mapboxMap ?: return@forEach\n                val latitude = marker.latitude ?: return@forEach\n                val longitude = marker.longitude ?: return@forEach\n                val iconImage =\n                    marker.label.getHazardousLaneImage(\n                        context = context,\n                        isMarkerYours = marker.idCreator == state.userId)\n                        ?.toBitmap(width = 120, height = 120)\n\n                iconImage?.let { bitmap ->\n\n                    val icon = IconFactory.getInstance(context).fromBitmap(bitmap)\n                    val markerOptions = MarkerOptions().apply {\n                        setIcon(icon)\n                        position(LatLng(latitude, longitude))\n                        title = marker.id\n                        snippet = MarkerSnippet.HazardousLaneSnippet.type\n\n                    }\n                    val addedMarker = mapboxMap.addMarker(markerOptions)\n                    addedMarker.let { hazardousMarkers.add(it) }\n                }\n            }\n        }\n    }\n\n\n    val hasActiveTransaction = remember(uiState.hasTransaction, uiState.isRescueCancelled) {\n        uiState.hasTransaction || uiState.isRescueCancelled\n    }\n\n    val isUserNavigating = remember(key1 = uiState.isNavigating, key2 = routeDirection?.geometry) {\n        val geometry = routeDirection?.geometry\n        uiState.isNavigating || geometry?.isNotEmpty() == true\n    }\n\n    val shouldDismissIcons =\n        remember(nearbyCyclist, isUserNavigating, hasActiveTransaction) {\n            isUserNavigating || hasActiveTransaction\n\n        }\n    val dismissibleNearbyUserMapTypes =\n        remember { listOf(MapType.HazardousLane.type, MapType.Traffic.type) }\n    val dismissibleHazardousMapTypes =\n        remember { listOf(MapType.Default.type, MapType.Traffic.type) }\n\n\n    LaunchedEffect(key1 = state.mapType, key2 = shouldDismissIcons, key3 = mapboxMap) {\n\n        if (state.mapType in dismissibleNearbyUserMapTypes) {\n            dismissNearbyUserMarkers()\n            return@LaunchedEffect\n        }\n\n        if (shouldDismissIcons) {\n            dismissNearbyUserMarkers()\n            return@LaunchedEffect\n        }\n\n    }\n\n    fun observeNearbyCyclistsIcon(){\n        if (state.mapType in dismissibleNearbyUserMapTypes) {\n            return\n        }\n\n        if (shouldDismissIcons) {\n            return\n        }\n\n        if(uiState.searchingAssistance){\n            return\n        }\n\n        if(state.userLocation == null){\n            return\n        }\n\n        showNearbyCyclistsIcon()\n    }\n\n    LaunchedEffect(key1 = nearbyCyclist, key2 = state.userLocation, key3 = mapboxMap) {\n        observeNearbyCyclistsIcon()\n    }\n\n\n    LaunchedEffect(key1 = nearbyCyclist, key2 = state.mapType, key3 = mapboxMap) {\n        observeNearbyCyclistsIcon()\n    }\n\n\n\n    LaunchedEffect(\n        key1 = shouldDismissIcons,\n        key2 = state.mapType,\n        key3 = mapboxMap) {\n\n        if (shouldDismissIcons) {\n            dismissHazardousMarkers()\n            return@LaunchedEffect\n        }\n\n        if (state.mapType in dismissibleHazardousMapTypes) {\n            dismissHazardousMarkers()\n            return@LaunchedEffect\n        }\n    }\n\n\n   fun observeHazardousMarker() {\n        val isLocationAvailable = state.userLocation?.latitude != null && state.userLocation.longitude != null\n\n        if (!isLocationAvailable) {\n            return\n        }\n\n        if (shouldDismissIcons) {\n            return\n        }\n\n        if (state.mapType in dismissibleHazardousMapTypes) {\n            return\n        }\n\n        if(uiState.searchingAssistance){\n            return\n        }\n\n        showHazardousLaneIcon()\n    }\n\n    LaunchedEffect(key1 = hazardousLaneMarkers.size, key2 = mapboxMap, key3 = state.mapType) {\n        observeHazardousMarker()\n    }\n\n\n    LaunchedEffect(key1 = mapboxMap, key2 = state.userLocation) {\n        observeHazardousMarker()\n    }\n\n    LaunchedEffect(key1 = mapboxMap, uiState.isFabExpanded) {\n\n        mapboxMap?.setOnMarkerClickListener {\n\n            mapboxMap.animateCameraPosition(\n                latLng = it.position,\n                zoomLevel = LOCATE_USER_ZOOM_LEVEL,\n                cameraAnimationDuration = DEFAULT_CAMERA_ANIMATION_DURATION)\n            event(MappingUiEvent.OnClickMapMarker(markerSnippet = it.snippet, markerId = it.title))\n            true\n        }\n\n        mapboxMap?.addOnMapClickListener {\n            event(MappingUiEvent.OnMapClick)\n            true\n        }\n\n        mapboxMap?.addOnCameraMoveListener {\n            if (uiState.isFabExpanded) {\n                event(MappingUiEvent.ExpandableFab(false))\n            }\n        }\n\n        mapboxMap?.addOnMapLongClickListener {\n            event(MappingUiEvent.OnMapLongClick(it))\n            true\n        }\n\n    }\n\n\n    val clientLocation =\n        remember(state.transactionLocation, state.rescuer?.location, state.rescuee?.location) {\n            with(state) {\n                transactionLocation ?: rescuer?.location ?: rescuee?.location\n            }\n        }\n\n    val transactionLocationChanges = remember(clientLocation) {\n        clientLocation != null\n    }\n\n    val dismissTransactionLocationIcon = remember(mapboxMap) {\n        {\n            mapboxMap?.getStyle { style ->\n                if (style.isFullyLoaded) {\n                    style.removeImage(TRANSACTION_ICON_ID)\n                    val geoJsonSource = style.getSourceAs<GeoJsonSource>(ICON_SOURCE_ID)\n                    geoJsonSource?.setGeoJson(FeatureCollection.fromFeatures(arrayOf()))\n                }\n            }\n        }\n    }\n\n    val showTransactionLocationIcon = remember(mapboxMap, state.user) {\n        { location: LocationModel ->\n            dismissTransactionLocationIcon()\n            val role = state.user.getRole()\n            val mapIcon = if (role == Role.Rescuee.name) {\n                R.drawable.ic_map_rescuer\n            } else {\n                R.drawable.ic_map_rescuee\n            }\n            mapboxMap?.getStyle { style ->\n                if (style.isFullyLoaded) {\n                    val longitude = location.longitude ?: return@getStyle\n                    val latitude = location.latitude ?: return@getStyle\n                    style.removeImage(TRANSACTION_ICON_ID)\n                    ContextCompat.getDrawable(context, mapIcon)?.toBitmap(width = 100, height = 100)\n                        ?.let { iconBitmap ->\n                            style.addImage(TRANSACTION_ICON_ID, iconBitmap)\n                            val geoJsonSource = style.getSourceAs<GeoJsonSource>(ICON_SOURCE_ID)\n                            val feature =\n                                Feature.fromGeometry(Point.fromLngLat(longitude, latitude))\n                            geoJsonSource?.setGeoJson(feature)\n                        }\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(\n        key1 = hasActiveTransaction,\n        key2 = transactionLocationChanges,\n        key3 = clientLocation) {\n\n        if (transactionLocationChanges.not() || hasActiveTransaction.not()) {\n            dismissTransactionLocationIcon()\n            return@LaunchedEffect\n        }\n\n        clientLocation?.latitude ?: return@LaunchedEffect\n        showTransactionLocationIcon(clientLocation)\n    }\n    val isDarkTheme = IsDarkTheme.current\n    LaunchedEffect(key1 = state.mapType, key2 = mapboxMap) {\n        val darkThemeMap =\n            if (state.mapType == MapType.Traffic.type) Style.TRAFFIC_NIGHT else Style.DARK\n        val lightThemeMap =\n            if (state.mapType == MapType.Traffic.type) Style.TRAFFIC_DAY else Style.LIGHT\n\n        mapboxMap?.setStyle(if (isDarkTheme) darkThemeMap else lightThemeMap){ loadedStyle ->\n\n            if (loadedStyle.isFullyLoaded) {\n                loadedStyle.initSource()\n                loadedStyle.initLayers(context)\n            }\n        }\n    }\n    Map(\n        modifier = modifier,\n        mapType = state.mapType,\n        event = event)\n\n}\n\n\n\n@Composable\nprivate fun Map(\n    modifier: Modifier,\n    mapType: String,\n    event: (MappingUiEvent) -> Unit) {\n\n\n    val isDarkTheme = IsDarkTheme.current\n    val mapView = rememberMapViewWithLifecycle()\n    var isInitialized by remember {\n        mutableStateOf(false)\n    }\n\n\n    Column(\n        modifier = modifier\n            .fillMaxHeight()\n            .fillMaxWidth()\n\n    ) {\n\n\n        AndroidView(factory = { mapView }) { view ->\n            if (isInitialized) {\n                return@AndroidView\n            }\n            CoroutineScope(Dispatchers.Main).launch {\n\n                val darkThemeMap =\n                    if (mapType == MapType.Traffic.type) Style.TRAFFIC_NIGHT else Style.DARK\n                val lightThemeMap =\n                    if (mapType == MapType.Traffic.type) Style.TRAFFIC_DAY else Style.LIGHT\n                mapView.getMapAsync { mapbox ->\n                    mapbox.setStyle(if (isDarkTheme) darkThemeMap else lightThemeMap) { loadedStyle ->\n\n                        if (loadedStyle.isFullyLoaded) {\n                            event(MappingUiEvent.OnInitializeMap(mapbox))\n                            loadedStyle.initSource()\n                            loadedStyle.initLayers(view.context)\n\n                        }\n                    }\n                    mapbox.setDefaultSettings()\n                }\n                isInitialized = true\n\n            }\n        }\n\n    }\n}\n\n@Composable\nfun rememberMapViewWithLifecycle(): MapView {\n    val context = LocalContext.current\n    val mapView = remember {\n        MapView(context).apply {\n            id = R.id.mapView\n        }\n    }\n\n    // Makes MapView follow the lifecycle of this composable\n    val lifecycleObserver = rememberMapLifecycleObserver(mapView)\n    val lifecycle = LocalLifecycleOwner.current.lifecycle\n    DisposableEffect(lifecycle) {\n        lifecycle.addObserver(lifecycleObserver)\n        onDispose {\n            lifecycle.removeObserver(lifecycleObserver)\n        }\n    }\n\n    return mapView\n}\n\n@Composable\nfun rememberMapLifecycleObserver(mapView: MapView): LifecycleEventObserver =\n    remember(mapView) {\n        LifecycleEventObserver { _, event ->\n            when (event) {\n                Lifecycle.Event.ON_CREATE -> mapView.onCreate(Bundle())\n                Lifecycle.Event.ON_START -> mapView.onStart()\n                Lifecycle.Event.ON_RESUME -> mapView.onResume()\n                Lifecycle.Event.ON_PAUSE -> mapView.onPause()\n                Lifecycle.Event.ON_STOP -> mapView.onStop()\n                Lifecycle.Event.ON_DESTROY -> mapView.onDestroy()\n                else -> throw IllegalStateException()\n            }\n        }\n    }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt
--- a/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt	(revision 7d7b9144b66bee06653fd3bb8c3d415f8db079c9)
+++ b/app/src/main/java/com/example/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt	(date 1697610915433)
@@ -23,7 +23,6 @@
 import com.example.cyclistance.core.utils.formatter.IconFormatter.getNearbyCyclistImage
 import com.example.cyclistance.feature_mapping.domain.model.Role
 import com.example.cyclistance.feature_mapping.domain.model.remote_models.hazardous_lane.HazardousLaneMarker
-import com.example.cyclistance.feature_mapping.domain.model.remote_models.rescue_transaction.RouteDirection
 import com.example.cyclistance.feature_mapping.domain.model.remote_models.user.LocationModel
 import com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent
 import com.example.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState
@@ -61,7 +60,6 @@
     state: MappingState,
     uiState: MappingUiState,
     mapboxMap: MapboxMap?,
-    routeDirection: RouteDirection?,
     hazardousLaneMarkers: List<HazardousLaneMarker>,
     event: (MappingUiEvent) -> Unit
 //    requestNavigationCameraToOverview: () -> Unit, //todo use this one
@@ -177,8 +175,8 @@
         uiState.hasTransaction || uiState.isRescueCancelled
     }
 
-    val isUserNavigating = remember(key1 = uiState.isNavigating, key2 = routeDirection?.geometry) {
-        val geometry = routeDirection?.geometry
+    val isUserNavigating = remember(key1 = uiState.isNavigating, key2 = uiState.routeDirection?.geometry) {
+        val geometry = uiState.routeDirection?.geometry
         uiState.isNavigating || geometry?.isNotEmpty() == true
     }
 
