Index: app/src/main/java/com/myapp/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.components\n\nimport android.annotation.SuppressLint\nimport android.os.Bundle\nimport androidx.compose.foundation.layout.Column\nimport androidx.compose.foundation.layout.fillMaxHeight\nimport androidx.compose.foundation.layout.fillMaxWidth\nimport androidx.compose.runtime.*\nimport androidx.compose.runtime.saveable.rememberSaveable\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.platform.LocalLifecycleOwner\nimport androidx.compose.ui.viewinterop.AndroidView\nimport androidx.core.content.ContextCompat\nimport androidx.core.graphics.drawable.toBitmap\nimport androidx.lifecycle.*\nimport com.mapbox.geojson.Feature\nimport com.mapbox.geojson.FeatureCollection\nimport com.mapbox.geojson.Point\nimport com.mapbox.mapboxsdk.annotations.IconFactory\nimport com.mapbox.mapboxsdk.annotations.Marker\nimport com.mapbox.mapboxsdk.annotations.MarkerOptions\nimport com.mapbox.mapboxsdk.geometry.LatLng\nimport com.mapbox.mapboxsdk.maps.MapView\nimport com.mapbox.mapboxsdk.maps.MapboxMap\nimport com.mapbox.mapboxsdk.maps.Style\nimport com.mapbox.mapboxsdk.style.expressions.Expression.*\nimport com.mapbox.mapboxsdk.style.layers.PropertyFactory.*\nimport com.mapbox.mapboxsdk.style.sources.GeoJsonSource\nimport com.myapp.cyclistance.R\nimport com.myapp.cyclistance.core.utils.constants.MappingConstants\nimport com.myapp.cyclistance.core.utils.constants.MappingConstants.DEFAULT_CAMERA_ANIMATION_DURATION\nimport com.myapp.cyclistance.core.utils.constants.MappingConstants.ICON_SOURCE_ID\nimport com.myapp.cyclistance.core.utils.constants.MappingConstants.LOCATE_USER_ZOOM_LEVEL\nimport com.myapp.cyclistance.core.utils.constants.MappingConstants.TRANSACTION_ICON_ID\nimport com.myapp.cyclistance.core.utils.formatter.IconFormatter.getHazardousLaneImage\nimport com.myapp.cyclistance.core.utils.formatter.IconFormatter.getNearbyCyclistImage\nimport com.myapp.cyclistance.feature_mapping.domain.model.Role\nimport com.myapp.cyclistance.feature_mapping.domain.model.remote_models.hazardous_lane.HazardousLaneMarker\nimport com.myapp.cyclistance.feature_mapping.domain.model.remote_models.user.LocationModel\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.event.MappingUiEvent\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingState\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.state.MappingUiState\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.*\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.animateCameraPosition\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.initLayers\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.initSource\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.setDefaultSettings\nimport com.myapp.cyclistance.feature_mapping.presentation.mapping_main_screen.utils.MappingUtils.showRoute\nimport com.myapp.cyclistance.navigation.IsDarkTheme\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport timber.log.Timber\n\n\n@SuppressLint(\"MissingPermission\")\n@Suppress(\"Deprecation\")\n@Composable\nfun MappingMapsScreen(\n    modifier: Modifier,\n    state: MappingState,\n    uiState: MappingUiState,\n    mapboxMap: MapboxMap?,\n    hazardousLaneMarkers: List<HazardousLaneMarker>,\n    event: (MappingUiEvent) -> Unit\n//    requestNavigationCameraToOverview: () -> Unit, //todo use this one\n) {\n\n\n    val context = LocalContext.current\n    val nearbyCyclist = state.nearbyCyclist?.users\n\n\n    val nearbyUserMarkers = remember { mutableStateListOf<Marker>() }\n\n    val dismissNearbyUserMarkers = remember(mapboxMap) {\n        {\n            nearbyUserMarkers.apply {\n                forEach { mapboxMap?.removeMarker(it) }\n                clear()\n            }\n        }\n    }\n\n    val showNearbyCyclistsIcon = remember(nearbyCyclist, mapboxMap,state.userLocation?.latitude) {\n        {\n            dismissNearbyUserMarkers()\n            nearbyCyclist?.filter {\n                it.id != state.user.id\n            }?.filter {user ->\n                val locationAvailable = user.location?.latitude != null && user.location.longitude != null\n                locationAvailable && user.isUserNeedHelp() == true\n            }?.filter { user ->\n\n                val markerLocation = LatLng(user.location?.latitude!!, user.location.longitude!!)\n                val userLocation = LatLng(\n                    state.userLocation?.latitude!!,\n                    state.userLocation.longitude!!\n                )\n                markerLocation.distanceTo(userLocation) < MappingConstants.DEFAULT_RADIUS\n            }?.forEach { cyclist ->\n                Timber.v(\"Cyclist Name: ${cyclist.name}\")\n                val location = cyclist.location\n                val latitude = location?.latitude ?: return@forEach\n                val longitude = location.longitude ?: return@forEach\n                val description = cyclist.getDescription()\n                val iconImage = description?.getNearbyCyclistImage(context)\n                    ?.toBitmap(width = 120, height = 120)\n                iconImage?.let { bitmap ->\n                    mapboxMap ?: return@let\n                    val icon = IconFactory.getInstance(context).fromBitmap(bitmap)\n                    val markerOptions = MarkerOptions().apply {\n                        setIcon(icon)\n                        position(LatLng(latitude, longitude))\n                        title = cyclist.id\n                        this.snippet = MarkerSnippet.NearbyCyclistSnippet.type\n                    }\n                    val addedMarker = mapboxMap.addMarker(markerOptions)\n                    addedMarker.let { nearbyUserMarkers.add(it) }\n                }\n            }\n        }\n    }\n\n    val hazardousMarkers = remember { mutableStateListOf<Marker>() }\n\n\n    val dismissHazardousMarkers = remember(mapboxMap) {\n        {\n            hazardousMarkers.apply {\n                forEach { mapboxMap?.removeMarker(it) }\n                clear()\n            }\n        }\n    }\n    val showHazardousLaneIcon = remember(hazardousLaneMarkers.size, mapboxMap, state.userLocation) {\n        {\n\n            dismissHazardousMarkers()\n            hazardousLaneMarkers.filter { marker ->\n                val markerLocation = LatLng(marker.latitude!!, marker.longitude!!)\n                val userLocation = LatLng(\n                    state.getCurrentLocation()?.latitude!!,\n                    state.getCurrentLocation()?.longitude!!\n                )\n                markerLocation.distanceTo(userLocation) < MappingConstants.DEFAULT_RADIUS\n            }.forEach { marker ->\n                mapboxMap ?: return@forEach\n                val latitude = marker.latitude ?: return@forEach\n                val longitude = marker.longitude ?: return@forEach\n                val iconImage =\n                    marker.label.getHazardousLaneImage(\n                        context = context,\n                        isMarkerYours = marker.idCreator == state.userId)\n                        ?.toBitmap(width = 120, height = 120)\n\n                iconImage?.let { bitmap ->\n\n                    val icon = IconFactory.getInstance(context).fromBitmap(bitmap)\n                    val markerOptions = MarkerOptions().apply {\n                        setIcon(icon)\n                        position(LatLng(latitude, longitude))\n                        title = marker.id\n                        snippet = MarkerSnippet.HazardousLaneSnippet.type\n\n                    }\n                    val addedMarker = mapboxMap.addMarker(markerOptions)\n                    addedMarker.let { hazardousMarkers.add(it) }\n                }\n            }\n        }\n    }\n\n\n    val hasActiveTransaction = remember(uiState.hasTransaction, uiState.isRescueCancelled) {\n        uiState.hasTransaction || uiState.isRescueCancelled\n    }\n\n    val isUserNavigating = remember(key1 = uiState.isNavigating, key2 = uiState.routeDirection?.geometry) {\n        val geometry = uiState.routeDirection?.geometry\n        uiState.isNavigating || geometry?.isNotEmpty() == true\n    }\n\n    val shouldDismissIcons =\n        remember(nearbyCyclist, isUserNavigating, hasActiveTransaction) {\n            isUserNavigating || hasActiveTransaction\n        }\n\n\n    LaunchedEffect(key1 = state.defaultMapTypeSelected, key2 = shouldDismissIcons, key3 = mapboxMap) {\n\n        if (!state.defaultMapTypeSelected) {\n            dismissNearbyUserMarkers()\n            return@LaunchedEffect\n        }\n\n        if (shouldDismissIcons) {\n            dismissNearbyUserMarkers()\n            return@LaunchedEffect\n        }\n\n    }\n\n    fun observeNearbyCyclistsIcon(){\n        val userLocation = state.userLocation\n\n\n        if (!state.defaultMapTypeSelected) {\n            return\n        }\n\n        if (shouldDismissIcons) {\n            return\n        }\n\n        if(uiState.searchingAssistance){\n            return\n        }\n\n        if(userLocation == null){\n            return\n        }\n\n        if(userLocation.latitude == null){\n            return\n        }\n\n        if (userLocation.longitude == null){\n            return\n        }\n\n        showNearbyCyclistsIcon()\n    }\n\n    LaunchedEffect(key1 = nearbyCyclist, key2 = state.userLocation, key3 = mapboxMap) {\n        observeNearbyCyclistsIcon()\n    }\n\n\n    LaunchedEffect(key1 = nearbyCyclist, key2 = state.defaultMapTypeSelected, key3 = mapboxMap) {\n        observeNearbyCyclistsIcon()\n    }\n\n\n\n    LaunchedEffect(\n        key1 = shouldDismissIcons,\n        key2 = state.hazardousMapTypeSelected,\n        key3 = mapboxMap) {\n\n        if (shouldDismissIcons) {\n            dismissHazardousMarkers()\n            return@LaunchedEffect\n        }\n\n        if (!state.hazardousMapTypeSelected) {\n            dismissHazardousMarkers()\n            return@LaunchedEffect\n        }\n    }\n\n\n   fun observeHazardousMarker() {\n        val isLocationAvailable = state.userLocation?.latitude != null && state.userLocation.longitude != null\n\n        if (!isLocationAvailable) {\n            return\n        }\n\n        if (shouldDismissIcons) {\n            return\n        }\n\n        if (!state.hazardousMapTypeSelected) {\n            return\n        }\n\n        if(uiState.searchingAssistance){\n            return\n        }\n\n        showHazardousLaneIcon()\n    }\n\n    LaunchedEffect(key1 = hazardousLaneMarkers.size, key2 = mapboxMap, key3 = state.hazardousMapTypeSelected) {\n        observeHazardousMarker()\n    }\n\n\n    LaunchedEffect(key1 = mapboxMap, key2 = state.userLocation) {\n        observeHazardousMarker()\n    }\n\n    LaunchedEffect(key1 = mapboxMap, uiState.isFabExpanded) {\n\n        mapboxMap?.setOnMarkerClickListener {\n\n            mapboxMap.animateCameraPosition(\n                latLng = it.position,\n                zoomLevel = LOCATE_USER_ZOOM_LEVEL,\n                cameraAnimationDuration = DEFAULT_CAMERA_ANIMATION_DURATION)\n            event(MappingUiEvent.OnClickMapMarker(markerSnippet = it.snippet, markerId = it.title))\n            true\n        }\n\n        mapboxMap?.addOnMapClickListener {\n            event(MappingUiEvent.OnMapClick)\n            true\n        }\n\n        mapboxMap?.addOnCameraMoveListener {\n            if (uiState.isFabExpanded) {\n                event(MappingUiEvent.ExpandableFab(false))\n            }\n        }\n\n        mapboxMap?.addOnMapLongClickListener {\n            event(MappingUiEvent.OnMapLongClick(it))\n            true\n        }\n\n    }\n\n\n    val clientLocation =\n        remember(state.transactionLocation, state.rescuer?.location, state.rescuee?.location) {\n            with(state) {\n                transactionLocation ?: rescuer?.location ?: rescuee?.location\n            }\n        }\n\n    val transactionLocationChanges = remember(clientLocation) {\n        clientLocation != null\n    }\n\n    val dismissTransactionLocationIcon = remember(mapboxMap) {\n        {\n            mapboxMap?.getStyle { style ->\n                if (style.isFullyLoaded) {\n                    style.removeImage(TRANSACTION_ICON_ID)\n                    runCatching {\n                        val geoJsonSource = style.getSourceAs<GeoJsonSource>(ICON_SOURCE_ID)\n                        geoJsonSource?.setGeoJson(FeatureCollection.fromFeatures(arrayOf()))\n                    }.onFailure {\n                        Timber.v(\"Mapbox style not loaded ${it.message}\")\n                    }\n\n                }\n            }\n        }\n    }\n\n    val showTransactionLocationIcon = remember(mapboxMap, state.user) {\n        { location: LocationModel ->\n            dismissTransactionLocationIcon()\n            val role = state.user.getRole()\n            val mapIcon = if (role == Role.Rescuee.name) {\n                R.drawable.ic_map_rescuer\n            } else {\n                R.drawable.ic_map_rescuee\n            }\n            mapboxMap?.getStyle { style ->\n                if (style.isFullyLoaded) {\n                    val longitude = location.longitude ?: return@getStyle\n                    val latitude = location.latitude ?: return@getStyle\n                    style.removeImage(TRANSACTION_ICON_ID)\n                    ContextCompat.getDrawable(context, mapIcon)?.toBitmap(width = 100, height = 100)\n                        ?.let { iconBitmap ->\n                            style.addImage(TRANSACTION_ICON_ID, iconBitmap)\n                            runCatching {\n                                val geoJsonSource = style.getSourceAs<GeoJsonSource>(ICON_SOURCE_ID)\n                                val feature =\n                                    Feature.fromGeometry(Point.fromLngLat(longitude, latitude))\n                                geoJsonSource?.setGeoJson(feature)\n                            }.onFailure {\n                                Timber.v(\"Mapbox style not loaded ${it.message}\")\n                            }\n                        }\n                }\n            }\n        }\n    }\n\n    LaunchedEffect(\n        key1 = hasActiveTransaction,\n        key2 = transactionLocationChanges,\n        key3 = clientLocation) {\n\n        if (transactionLocationChanges.not() || hasActiveTransaction.not()) {\n            dismissTransactionLocationIcon()\n            return@LaunchedEffect\n        }\n\n        clientLocation?.latitude ?: return@LaunchedEffect\n        showTransactionLocationIcon(clientLocation)\n    }\n    val isDarkTheme = IsDarkTheme.current\n\n    LaunchedEffect(\n        key1 = state.trafficMapTypeSelected,\n        key2 = mapboxMap) {\n\n        val geometry = uiState.routeDirection?.geometry\n        val darkThemeMap = if (state.trafficMapTypeSelected) Style.TRAFFIC_NIGHT else Style.DARK\n        val lightThemeMap = if (state.trafficMapTypeSelected) Style.TRAFFIC_DAY else Style.LIGHT\n\n        mapboxMap?.setStyle(if (isDarkTheme) darkThemeMap else lightThemeMap) { loadedStyle ->\n\n            if (!loadedStyle.isFullyLoaded) {\n                return@setStyle\n            }\n\n            loadedStyle.initSource()\n            loadedStyle.initLayers(context)\n\n            if (geometry == null) {\n                return@setStyle\n            }\n\n            loadedStyle.showRoute(geometry = geometry)\n        }\n    }\n    Map(\n        modifier = modifier,\n        uiState = uiState,\n        trafficMapTypeSelected = state.trafficMapTypeSelected,\n        event = event)\n\n}\n\n\n\n@Composable\nprivate fun Map(\n    modifier: Modifier,\n    uiState: MappingUiState,\n    trafficMapTypeSelected: Boolean,\n    event: (MappingUiEvent) -> Unit) {\n\n\n    val isDarkTheme = IsDarkTheme.current\n    val mapView = rememberMapViewWithLifecycle()\n    var isInitialized by rememberSaveable {\n        mutableStateOf(false)\n    }\n\n\n    Column(\n        modifier = modifier\n            .fillMaxHeight()\n            .fillMaxWidth()\n\n    ) {\n\n\n        AndroidView(factory = { mapView }) { view ->\n            if (isInitialized) {\n                return@AndroidView\n            }\n            CoroutineScope(Dispatchers.Main).launch {\n\n                val geometry = uiState.routeDirection?.geometry\n                val darkThemeMap = if (trafficMapTypeSelected) Style.TRAFFIC_NIGHT else Style.DARK\n                val lightThemeMap = if (trafficMapTypeSelected) Style.TRAFFIC_DAY else Style.LIGHT\n\n\n                mapView.getMapAsync { mapbox ->\n                    mapbox.setStyle(if (isDarkTheme) darkThemeMap else lightThemeMap) { loadedStyle ->\n\n                        if (!loadedStyle.isFullyLoaded) {\n                            return@setStyle\n                        }\n\n                        event(MappingUiEvent.OnInitializeMap(mapbox))\n                        loadedStyle.initSource()\n                        loadedStyle.initLayers(view.context)\n\n                        if (geometry == null) {\n                            return@setStyle\n                        }\n\n                        loadedStyle.showRoute(geometry = geometry)\n\n                    }\n                    mapbox.setDefaultSettings()\n                }\n                isInitialized = true\n\n            }\n        }\n\n    }\n}\n\n@Composable\nfun rememberMapViewWithLifecycle(): MapView {\n    val context = LocalContext.current\n    val mapView = remember {\n        MapView(context).apply {\n            id = R.id.mapView\n        }\n    }\n\n    // Makes MapView follow the lifecycle of this composable\n    val lifecycleObserver = rememberMapLifecycleObserver(mapView)\n    val lifecycle = LocalLifecycleOwner.current.lifecycle\n    DisposableEffect(lifecycle) {\n        lifecycle.addObserver(lifecycleObserver)\n        onDispose {\n            lifecycle.removeObserver(lifecycleObserver)\n        }\n    }\n\n    return mapView\n}\n\n@Composable\nfun rememberMapLifecycleObserver(mapView: MapView): LifecycleEventObserver =\n    remember(mapView) {\n        LifecycleEventObserver { _, event ->\n            when (event) {\n                Lifecycle.Event.ON_CREATE -> mapView.onCreate(Bundle())\n                Lifecycle.Event.ON_START -> mapView.onStart()\n                Lifecycle.Event.ON_RESUME -> mapView.onResume()\n                Lifecycle.Event.ON_PAUSE -> mapView.onPause()\n                Lifecycle.Event.ON_STOP -> mapView.onStop()\n                Lifecycle.Event.ON_DESTROY -> mapView.onDestroy()\n                else -> throw IllegalStateException()\n            }\n        }\n    }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/myapp/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt b/app/src/main/java/com/myapp/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt
--- a/app/src/main/java/com/myapp/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt	(revision a030997938f61522e027f3227589cada04599c37)
+++ b/app/src/main/java/com/myapp/cyclistance/feature_mapping/presentation/mapping_main_screen/components/MappingMapsScreen.kt	(date 1700757480806)
@@ -6,7 +6,6 @@
 import androidx.compose.foundation.layout.fillMaxHeight
 import androidx.compose.foundation.layout.fillMaxWidth
 import androidx.compose.runtime.*
-import androidx.compose.runtime.saveable.rememberSaveable
 import androidx.compose.ui.Modifier
 import androidx.compose.ui.platform.LocalContext
 import androidx.compose.ui.platform.LocalLifecycleOwner
@@ -441,7 +440,7 @@
 
     val isDarkTheme = IsDarkTheme.current
     val mapView = rememberMapViewWithLifecycle()
-    var isInitialized by rememberSaveable {
+    var isInitialized by remember {
         mutableStateOf(false)
     }
 
